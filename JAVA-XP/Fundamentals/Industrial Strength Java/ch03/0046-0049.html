<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Planning Your Application:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0042-0045.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0050-0053.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-46"><P>Page 46</P></A>


<P>which is done by first generating a list of moves with generateMoves(), which creates
a list of valid moves for the piece, given the context of the current board. The most
important feature of this method is that it is a generic function that works for all types of
chess pieces. By calling generateMoves(), an abstract method, you are guaranteed that
the moves returned will be for the current class of piece. If the class was Pawn and extends
the class Piece, and the program calls isMoveValid() for a pawn, this method will call
the generateMoves() for the class Pawn.
</P>

<P>Listing 3.2dPiece Class: The Implementation for the isMoveValid() Method
</P>

<PRE>
    public final boolean isMoveValid(Board board, Move move){
        // Check to see if we are moving this piece
        if (move.movedPiece.ID() != id){
            return(false);
        }
        // Generate a list of moves to check against
        Vector moves = generateMoves(board);
        for (Enumeration e = moves.elements() ; e.hasMoreElements() ;) {
            Move temp = (Move)e.nextElement();
            if (move.equals(temp)){
                return(true);
            }

        }
        // If we got here then there were no matching moves.
        return (false);

    }
</PRE>

<P>Many programmers not used to object-oriented programming find the concepts of
such behavior quite perplexing. The key to understanding is to remember that the call
to generateMoves() is actually seen as &quot;this. generateMoves().&quot; The &quot;this&quot; is a reference
to the current object and its type, so the result is that the method belonging to the object
is called.
</P>

<P>The remaining implementations of the class are the accessor methods and the
private fields that define the state of a Piece object.
</P>

<P>Listing 3.2ePiece Class: The Implementation for Public Accessor Methods
and Private Data
</P>


<A NAME="PAGENUM-47"><P>Page 47</P></A>


<PRE>
public final int ID(){
              return(id);
    }

    public final void voidCapture(){
              captured = false;
    }

    public final void setCaptured(){
              captured = true;
    }

    public final boolean isCaptured(){
              return(captured);
    }

    public final Color getColor(){
        return (color);
    }
    // private protected data
    private  boolean captured; // true if captured
    private  Color color; // Black or White piece color
    private  int value; // Point value
    private  int id; // ID of piece
}
</PRE>

<P>To understand why the class Piece was created as an abstract base, observe the
class definition in listing 3.3a for the Pawn class.
</P>

<P>Listing 3.3aClass Pawn: Imports, Class Definition, and Constructor
</P>

<PRE>
/** Pawn.java
    Implementation for a Pawn Piece.
*/
import Piece;
import Move;
import Board;
import java.awt.Color;
import java.awt.Point;
import java.util.*;
class Pawn extends Piece{
    Pawn(int id,Color color){
        super(id,color,15);
    }
</PRE>

<P>Notice first that class Pawn extends class Piece. The &quot;extends&quot; keyword is used to
show
</P>

<A NAME="PAGENUM-48"><P>Page 48</P></A>


<P>that the class on the left, Pawn, inherits the class on the right, Pawn. The word &quot;extends&quot;
is used rather than &quot;inherits&quot; because, unlike biological inheritance, we will always
be extending the functionality of the parent.
</P>

<P>The constructor, as discussed earlier, calls super(), which is the constructor for the
class Piece. The keyword &quot;super&quot; designates that the next superior class's constructor in
the inheritance tree is to be called. In this example, the next super class is Piece.
Remember that there are actually three classes in this class hierarchy. The first, and most base class,
is java.lang.Object.
</P>

<P>The abstract method generateMoves() is implemented in listing 3.3b. The method
first determines what square it is on by asking the board for its position. A vector is
next created in which to return moves, followed by the actual generation of the moves.
The base class method addMove() is used to ensure that the move will be valid.
</P>

<P>Listing 3.3bClass Pawn: Imports, Class Definition, and Constructor
</P>

<PRE>
    public Vector generateMoves(Board board){
        Point point = board.getPointForPiece(ID());
        // validate that piece was on board
        if (point == null){
            // Piece was not on board, escape!
            return null;
        }
        // Create a Vector to hold moves
        Vector vector = new Vector();
        Point tempMove;
        if (getColor() == Color.white){
            tempMove = new Point(point.x,point.y+1);
            addMove(vector,board,new Point(point.x,point.y),tempMove);
            tempMove = new Point(point.x+1,point.y+1);
            addMove(vector,board,new Point(point.x,point.y),tempMove);
            tempMove = new Point(point.x-1,point.y+1);
            addMove(vector,board,new Point(point.x,point.y),tempMove);
        }else{
            tempMove = new Point(point.x,point.y-1);
            addMove(vector,board,new Point(point.x,point.y),tempMove);
            tempMove = new Point(point.x+1,point.y-1);
            addMove(vector,board,new Point(point.x,point.y),tempMove);
            tempMove = new Point(point.x-1,point.y-1);
            addMove(vector,board,new Point(point.x,point.y),tempMove);
        }

        return vector;
    }
}
</PRE>


<A NAME="PAGENUM-49"><P>Page 49</P></A>


<P>There is overall very little code in class Pawn. Pawn only needs a constructor and
an implementation of the abstract class generateMoves(). Note that there is a lot of
code saved by using the addMove() method from the base class.
</P>

<P>This example features many advantages to the inheritance. First, common generic
functions that work for any class inheriting from the base do not require reimplementing
base functionality. Also, the benefit gained by addMove() when writing the
generateMoves() method greatly decreases the amount of code required. The definition of
generateMoves() as an abstract method also means that any class inheriting from class Piece can be
operated on generically, as seen by the use of the abstract method from within
the isMoveValid() method.
</P>

<H4><A NAME="ch03_ 18">
Interfaces
</A></H4>

<P>Interfaces are Java's way of implementing safe multiple inheritance. Interfaces add
pure abstract methods and constants to classes. The class must implement the abstract
functions in the same way that a child class implements abstract functions of abstract classes. This
is better than classic multiple inheritance because it avoids the common problem of
name clashing and multiple copies of inherited base classes. It does this by treating the
inheritance only as an interface and not as an implementation.
</P>

<P>A class can have only one inherited class and any number of interface classes.
Each interface implemented in a class enables it to cast as an object of that class. Once cast
to the interface class, methods or constants within the interface definition can be used.
</P>

<P>Interfaces are quite useful; they enable classes to communicate with each other as
uniform classes. In other words, an interface can act as a class translator between different
classes. The observer example that follows is a classic representation of this concept.
</P>

<H4><A NAME="ch03_ 19">
Bypassing Multiple Inheritance Problems
</A></H4>

<P>Multiple inheritance is often described as dangerous because multiple inheritance
can make classes very complex, which is especially true with C++ because there is
little control over which parts of classes are inherited. But there are other reasons.
Inherited classes have multiple constructors and destructors, creating hard-to-follow sequences
that affect the state of an object. Data in base classes can be similar or duplicated, making
it confusing for a child class to use the data. There are ways to fix these problems in
C++, but the 
</P>

<P><CENTER>
<a href="0042-0045.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0050-0053.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



