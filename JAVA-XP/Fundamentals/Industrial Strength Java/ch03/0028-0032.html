<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Planning Your Application:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0025-0027.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0033-0036.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-28"><P>Page 28</P></A>


<P><a href="images\ch03fg01.jpg"><img src="images\tn_ch03fg01.jpg"></a><BR>
Figure 3.1 A top-down design cycle.
</P>

<P>the user's immediate needs are implemented.
</P>

<P>This may seem like the user is completely in the driver's seat. This is somewhat
true because, after all, the user is the customer who needs to be satisfied.
Communication between developer and user is not unidirectional. The developer must also make sure
that the user actually requires certain functions and uses them when they are supplied.
The developer is responsible for knowing what is difficult or simple to design, too.
The developer should work with the user to prove each solution is viable before it
ever 
</P>


<A NAME="PAGENUM-29"><P>Page 29</P></A>


<P><a href="images\ch03fg02.jpg"><img src="images\tn_ch03fg02.jpg"></a><BR>
Figure 3.2 The incremental delivery cycle.
</P>

<P>becomes part of the application.</P>

<P>When the results of each stage of development are in use by users between each cycle,
the developer can simply look to determine whether features are actually being used.
Information about usage can be used as a measurement of how accurate the design is versus how
it is used or if it is even required. Features that are not used can be removed so that
maintenance can be avoided in the future. Removing unused functions also reduces
documentation and training tasks. It is important to remember that the biggest of all bugs is
</P>


<A NAME="PAGENUM-30"><P>Page 30</P></A>


<P>unused software!
</P>

<H4><A NAME="ch03_ 8">
Identifying User Requirements
</A></H4>

<P>As features are developed, some may become more important than others, and some
may prove to be unnecessary. A few simple steps help developers and customers create
a specification of features and their importance. They help you to avoid useless
functions and features, and as an added benefit, they help schedule incremental deliveries.
This process also helps to loosen up reluctant customers who have difficulty defining
their requirements.
</P>

<OL>
<LI>     List the major tasks requested by the customer.
<LI>     Have the customer use this list to prioritize each feature and task (this helps
to perform the next step).
<LI>     Determine the core functions. These are the tasks that the customer
must have in the first delivery. Be careful to distinguish between &quot;nice to have&quot; and &quot;I cannot
do my work without it.&quot; The first delivery should be as small as possible, but still
be adequate. If it is too large, break the development into stages that the user
can successfully verify as correct. This helps to ensure that you are still on the
right track.
<LI>     Write clear descriptions of every function. Include both the &quot;must have&quot; group
and each of the lesser functions. Include their perceived complexity and
probable design times along with the customer's specified judgments of importance.
<LI>     Create a schedule of phased deliveries. Each phase can be as small as a
single, testable function or a group of tightly coupled functions. Try to avoid
delivery increments of greater than a month. The preferred delivery cycle is one to
two weeks. Remember that the smaller the cycle, the lower the development
risk. Having to throw away a week of work is far cheaper than losing two months.
</OL>

<P>At the end of this process, you should have enough information to begin an
object-oriented analysis. The target model should be the only set of features designed in
detail. Attempting to model the entire set of deliverable features could be a waste of time.
The initial model should take into account key features that may affect future
deliveries. Certain key classes may need to be designed from the start to ensure success later on.
</P>

<P>For instance, an employee database may be designed to hold the name, address, and
a picture of the employee. The code for loading the picture from the employee database
is required. Code for displaying the picture of the employee can be added in a future version.
</P>


<A NAME="PAGENUM-31"><P>Page 31</P></A>


<P>The first analysis should not attempt to make the first delivery overly generic. A
program enabling additional functionality in the future sometimes takes much more time
to produce. It may be more effective to simply rewrite small portions as the program
evolves. The trap hidden in many plug-and-play features is that they usually limit the features to
be added or grow too large because developers attempt to cover too many possibilities.
</P>

<P>Java does have a way for developers to easily implement a simple plug-and-play
interface. See the section &quot;Dynamic Class Loading&quot; later in this chapter.
</P>

<H3><A NAME="ch03_ 9">
Pick Your Environment
</A></H3>

<P>There are several Java runtime models that can be used to accomplish various tasks
(see table 3.1). It is important to understand the details of these models because they
each dramatically change the design of your application.
</P>

<P>Table 3.1
</P>

<P>Common Runtime Models
</P>

<TABLE>

<TR><TD>
Application
Model
</TD><TD>
Environment
</TD><TD>
Advantages
</TD><TD>
Disadvantages
</TD><TD>
Uses
</TD></TR><TR><TD>
Applet
</TD><TD>
Runs in applet
or web browser.
</TD><TD>
Very secure.
Loaded via
browser.
</TD><TD>
Integrates with
HTML content. Only     
one copy used by     
all users. No     
access to local     
resources. No read     
or write of local     
files. Reloaded on    
each use. Must     
have a browser to  
use.
</TD><TD>
Live content for
HTML pages. Front
end (client) for
client server.
</TD></TR><TR><TD>
Windows
</TD><TD>
Class files
loaded from
the local file
system are run
in a Java VM.
User interacts
</TD><TD>
Access to     
local re-     
sources. Can     
use native     
methods to     
access hard-   
</TD><TD>
Unsecured access
to local resources.
Users must have
a local copy
to use.
</TD><TD>
Can be used like
any window
application.
</TD></TR></TABLE>

<PRE>
                                                           continues
</PRE>

<A NAME="PAGENUM-32"><P>Page 32</P></A>


<TABLE>

<TR><TD>
Application
Model
</TD><TD>
Environment
</TD><TD>
Advantages
</TD><TD>
Disadvantages
</TD><TD>
Uses
</TD></TR><TR><TD>
</TD><TD>
with the appli-
cation with
AWT windows
and dialogs.
</TD><TD>
ware or
integrate with
non-Java
applications.
</TD><TD>
</TD><TD>
</TD></TR><TR><TD>
Console
</TD><TD>
Class files
loaded from the
local file
system are run
in a Java VM.
User interacts
via command
line prompts
(if at all).
</TD><TD>
Access to
local re-
sources. Can     
use native
methods to
access hard-
ware or
integrate with
non-Java
applications.
</TD><TD>
Unsecured access
to local resources.
Users must have
a local copy to
use.
</TD><TD>
Used where user
interaction is
simple or
unnecessary. Can
be used as a server
for client server
applications.
</TD></TR><TR><TD>
Client/Server
</TD><TD>
One application,
the server,
runs on a host.
The host
controls access
to information
and resources.
Another
application,
the client,
interacts with
the server to
use and control
information and
resources.
</TD><TD>
Multiple
lightweight
clients can
access
resources
on a single
server,
decreasing
need for
client-side
resources.
Server
consolidates
control of
resources.
Security
access
can be
controlled by
the server,
limiting   
access     
</TD><TD>
Client and server
applications must
be maintained.
Server is a single
point of failure
for multiple users.
Communication
between client and
server can be
monitored.
</TD><TD>
Multiuser 
applications.
</TD></TR></TABLE>

<P><CENTER>
<a href="0025-0027.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0033-0036.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



