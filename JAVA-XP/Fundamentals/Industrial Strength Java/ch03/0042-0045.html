<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Planning Your Application:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0037-0041.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0046-0049.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-42"><P>Page 42</P></A>


<P>sections show you how this is done and relate this structure to Booch method
class notation. This section also expands the information covered in Chapter 2.
</P>

<H4><A NAME="ch03_ 17">
Classes
</A></H4>

<P>Classes are the basic building blocks of object-oriented
programming with Java. A Java class can contain data or methods or
both data and methods.
</P>

<P><B>
Inheritance
</B></P>

<P>The following example designs chess pieces for a chess game,
as illustrated in figure 3.7. Chess pieces are very easily represented
as an inheritance tree.
</P>

<P><a href="images\ch03fg07.jpg"><img src="images\tn_ch03fg07.jpg"></a><BR>
Figure 3.7 A Booch diagram of class inheritance with a chess
piece model.
</P>

<P>The Piece class in the diagram has an &quot;A&quot; within an
inverted triangle. This designates that Piece is an
abstract class. The arrows drawn from the classes, such as Queen or Pawn, designate that
they inherit from the class Piece. Arrows point to parent classes. 
</P>

<BR>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The figures used in this chapter are Booch
diagrams, developed by Grady Booch. For a more detailed discussion
of this notation, refer to Grady Booch's book,
Object-oriented Analysis and Design with
Applications, Second Edition.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>The lack of the abstract symbol on specific chess pieces, such as
the Queen, designates that they are concrete classes.
</P>

<P>The code in listing 3.1 shows the class specification for the
class Piece. ( The &Acirc; symbol indicates a line that would fit on the
previous line were this a computer screen.) The listing was produced by
the 
</P>

<BR>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Abstract classes are used to define common
functionality that is not completely implemented.
There may be several fields and methods defined, but at least
one method must contain no implementation. The
implemented methods must be supplied by a child class.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>


<A NAME="PAGENUM-43"><P>Page 43</P></A>


<P>javap tool, which dumps information from a class file. The
listing shows the public class definition that can be accessed by
other classes. The javap class disassembler also prints the fully
qualified names of classes used. In other words, the package that a
type comes from is included.
</P>

<P>Listing 3.1The Piece Class, Public Definition
</P>

<PRE>
public abstract class Piece extends java.lang.Object {
    private boolean captured;
    private java.awt.Color color;
    private int value;
    private int id;

    public abstract java.util.Vector
 generateMoves(Board);

    public Piece(int,java.awt.Color,int);

    protected final boolean addMove
        &Acirc;(java.util.Vector,Board,java.awt.Point,java.
    &Acirc;awt.Point);

    public final boolean isMoveValid(Board,Move);
    public final int ID();
    public final void voidCapture();
    public final void setCaptured();
    public final boolean isCaptured();
    public final java.awt.Color getColor();
}
</PRE>

<P>Notice that the generateMoves() method is abstract. Because of this one abstract
method, the entire class becomes abstract and the compiler forces you to use the abstract
modifier on the class, before it can be compiled.
</P>

<P>Another interesting method is addMove(). This method is
used exclusively by child classes to perform part of the functionality
of the generateMoves() method. Because it is exclusive to the
child class, its access is set to protected private to make it only
accessible from child classes.
</P>

<BR>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Concrete classes are classes that can be instantiated
as objects. In other words, you cannot have an object
of class Piece, but you can have an object of type Queen. If you
did try to create an object, as the following line
of Java demonstrates, the compiler would generate an error:

<PRE>
Piece chessPiece = new
Piece();// Causes
Invalid Declaration Error
</PRE>
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The class also inherits from the java.lang.Object
class. The javap disassembler added this information to
the listing even though the class did not specify
it. All classes inherit from java.lang.Object.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>


<A NAME="PAGENUM-44"><P>Page 44</P></A>


<P>Limiting access is done to prevent other classes not inheriting
this class from calling the function. By being protected private, the
Piece class specifies that the method is specific to the class and
has nothing to do with any other class. Additionally, the
addMove() method could depend on the current state of the object. This is
very important in the Piece class because moves are added based
on internal state.
</P>

<P>The rest of the methods are public final, preventing these methods from becoming
redefined by child classes. This is done as a precaution and to clarify the intent behind the design of
the base class. By being final, it prevents programmers from inadvertently rewriting the
method and changing its meaning. The intent that this is the &quot;final&quot; implementation also informs
the programmer that there is no need to reimplement the method because its design is
complete and its meaning will not change. These methods are used only to access private
fields. Between the final modifier on these methods and the private modifiers used on the
fields, you have effectively prevented any bugs from being created in the child classes by
method overloading. This is probably overkill, but it costs very little to make this class
hierarchy safer. Also, the use of the final modifier should enable the compiler to generate faster
code (see the following discussion on final). Listing 3.2a shows the source code for class
Piece.
</P>

<P>Listing 3.2aPiece Class: Imports, Class Definition and the Abstract Method
generateMoves()
</P>

<PRE>
/** Piece.java
    This class is an abstract base class for chess pieces.
*/
import Move;
import Board;
import java.awt.Color;
import java.awt.Point;
import java.util.*;
public abstract class Piece{
    // Abstract function specific to each piece
    public abstract Vector generateMoves(Board board);
</PRE>

<P>The constructor for the Piece class is implemented in listing 3.2b. This constructor does
all the busy work that is required to set up basic information about a piece. A child class
calls this method with the super() method call. Super, in the case of this constructor,
would have the definition of void super(int id, Color color, int value);.
</P>

<P>Listing 3.2bClass Constructor for the Piece Class
</P>

<A NAME="PAGENUM-45"><P>Page 45</P></A>



<PRE>
public Piece(int id, Color color, int value){
        // Set up piece points and ID
        this.id = id;
        this.color = color;
        this.value = value;
        // Set default capture state
        captured = false;
    }
</PRE>

<P>To help make the definition of this method easier to read, the names of the values
passed into the method are the same as those used to define the private members of the class.
The &quot;this&quot; is a reference to the current object, used to distinguish the difference between
the fields in the method definition and those of the class.
</P>

<P>Because &quot;this&quot; is a base class, it implicitly inherits from the java.lang.Object class, so
this class has all additional methods that are not visible here. An implicit call to super()
creates an Object class instance.
</P>

<P>This function is used to lower the work load of
generateMoves(). It checks to see whether the piece can be put at this
position. If it is okay, then add it to a move vector and
return true, else return false.
</P>

<P>Listing 3.2cPiece Class: The Implementation for the addMove() Method
</P>

<PRE>
    protected final boolean addMove(Vector moved,Board board,Point
       &Acirc;from,Point to){
        Piece capturedPiece = board.getPiece(to);
        if (capturedPiece == null){
            moved.addElement(new Move(this,from,null,to));
        }else{
            if (capturedPiece.getColor() != color){
                //Capturing a piece
                moved.addElement(new Move(this,from,capturedPiece,to));
            }else{
                // Move was blocked by my own color
                return (false);
            }
        }
        return (false);
    }
</PRE>

<P>The isMoveValid() method, shown in listing 3.2d, is used to validate that a move
is possible. This method would normally be used when a user moves a piece on the
board,
</P>

<P><CENTER>
<a href="0037-0041.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0046-0049.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



