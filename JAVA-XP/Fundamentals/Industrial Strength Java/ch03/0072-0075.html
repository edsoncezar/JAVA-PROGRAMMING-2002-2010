<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Planning Your Application:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0067-0071.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0076-0080.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-72"><P>Page 72</P></A>


<P>As mentioned in the chess piece example, abstract methods are used to define
common interfaces to classes without defining their implementations. Abstract classes are
used when the base class method has no meaning. For instance, the base class of Piece
cannot have an implementation because it only represents the concept of a generic piece and not
a real piece. After the piece is subclassed, as a King for example, the information
for movement is implemented in the generateMoves() method.
</P>

<P>Abstract methods also help to enforce proper implementation of child classes.
Abstract methods &quot;must&quot; be implemented, so the programmer cannot depend on a default
method to handle the new instance. This was important in the chess example because all
pieces move differently and no default is possible or allowed.
</P>

<H4>
static
</H4>

<P>Static methods and fields are accessible as a class and do not depend on an object of
the class being initialized. A good example of a static method is the main() method that
starts all console and window application classes. Another use for statics is for storing data
that is relevant to objects in the same class.
</P>

<P>Static methods and fields are also called class
methods and class fields. They are associated with the class instance and not the instance of objects of the class.
</P>

<P>Statics are used to hold and access information such as object counters that are used
to count the number of objects created by a class, or to limit the number of objects that
may be created by the class. Statics can be used to hold information, such as values last used
by any one of the classes, or sequence information that all objects need access to.
</P>

<P>Because statics are associated with the class, you must understand the effects they
can have. The following sections describe their behavior in different situations.
</P>

<P><B>
Static Initializer Block
</B></P>

<P>Static method variables can be initialized in a special parameter-less method called a
static initializer block. The static initializer
block is similar to a constructor, except that it
gets executed when a class is loaded. Also, static initializer blocks, like static methods,
cannot access anything but static members. Here is an example class that uses a static array
to hold pre-calculated powers of 2.
</P>

<P>Listing 3.21a shows the static initializer block used to fill the table. Note that it takes
no functions&#151;it is never called from within the program like a method. Only the class
loader can call the static block.
</P>


<A NAME="PAGENUM-73"><P>Page 73</P></A>



<P>Listing 3.21aClass StaticInit: Imports, Class Definition, Static Variables,
and Static Block
</P>

<PRE>
/** StaticInit.java
    Demonstation of static initializer block
*/
import java.awt.*;
import java.io.IOException;

public class StaticInit {
    // Static array to be initialized
    static int [] powersOf2;
    static final int maxPower = 16;
    // Static initializer gets called when class is loaded
    static{
        // Create an array of powers of 2
        powersOf2 = new int[maxPower];
        for (int i = 0;i&lt;maxPower;i++){
            powersOf2[i] = (int)Math.pow(2,i);
        }


    }
</PRE>

<P>Listing 3.21b defines the main() method, which is always static because it does not
depend upon an instance of the class being in existence. In fact, the main() method, as it is
used here, creates an instance of the StaticInit class. It is important to note that the static
block has already been called before main() is called. It would have to have been called by
the class loaded before the main() method can be called.
</P>

<P>Listing 3.21bClass StaticInit: The main() Method
</P>

<PRE>
public static void main(String args[]) {
    new StaticInit();
}
</PRE>

<P>The constructor for this class simply prints the contents of the static variable (see
listing 3.21c). This is done to validate that they were correctly initialized.
</P>

<P>Listing 3.21cClass StaticInit: The Class Constructor
</P>

<PRE>
    StaticInit(){
        System.out.println(&quot;Demonstation of static initializer block&quot;);
        System.out.println(&quot;&quot;);

        System.out.println(&quot;Powers of 2 initialized when class was
</PRE>


<A NAME="PAGENUM-74"><P>Page 74</P></A>


<PRE>
                &Acirc;loaded:&quot;);
        for (int i = 0;i&lt;maxPower;i++){
            System.out.println(&quot;2^&quot;+i+&quot;=&quot;+powersOf2[i]);
        }
        System.out.println(&quot;&quot;);
        System.out.println(&quot;(press Enter to exit)&quot;);
        try {
            System.in.read();
        } catch (IOException e) {
            return;
        }

    }
}
</PRE>

<P><B>
Statics and Inheritance
</B></P>

<P>Statics should be used with care when classes are inherited. The output in listing 3.22
was generated by the StaticJava.java test. This application shows what happens when statics
are inherited. Notice that the Counter and SonOfCounter have the same object count
because when SonOfCounter extends Counter, it does not get a new copy of the static field count.
</P>

<P>Listing 3.22Output of the StaticJava Test Program
</P>

<PRE>
Demonstration of class counter
Object count at start
There are 0 copies of class Counter
There are 0 copies of class SonOfCounter
There are 0 copies of class SonOfCounter
There are 0 copies of class SecondSonOfCounter

Object count after new Counter() &amp; new SonOfCounter()
There are 2 copies of class Counter
There are 2 copies of class SonOfCounter
There are 0 copies of class SecondSonOfCounter

Object count after new SonOfCounter()
There are 3 copies of class Counter
There are 3 copies of class SonOfCounter
There are 1 copies of class SecondSonOfCounter

Object count after SonOfCounter a dereferenced  &amp; b finalized
There are 2 copies of class Counter
There are 2 copies of class SonOfCounter
There are 1 copies of class SecondSonOfCounter
</PRE>


<A NAME="PAGENUM-75"><P>Page 75</P></A>


<P>In order to fix this problem, the field count and the methods getCount() and finalize()
must be overloaded. In addition the constructor must also control the incrementing of the
count. Notice that this is still not a good solution because even SecondSonOfCounter,
which overloads the static access, still causes the other classes to increment because of
the implicit call to super (which increments the static for Counter) (see fig. 3.12).
</P>

<P>To add to the woes of statics, the programmer must be careful to call the objects
finalizer to ensure that the object count is decremented.
</P>

<P>To begin this example, the class Counter is created (see listing 3.23). It is a
simple example of a class that counts its instances. Note that the counter is set to zero where
the count field is defined. The count is incremented when its constructor is called
and decremented when the finalizer is called.
</P>

<P><a href="images\ch03fg12.jpg"><img src="images\tn_ch03fg12.jpg"></a><BR>
Figure 3.12 A Booch diagram for a static counter test.
</P>

<P>Listing 3.23A Class Counter
</P>

<PRE>
class Counter{
    private static int count = 0;
    public static int getCount(){
        return (count);
</PRE>


<P><CENTER>
<a href="0067-0071.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0076-0080.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



