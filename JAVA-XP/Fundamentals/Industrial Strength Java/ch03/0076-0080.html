<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Planning Your Application:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0072-0075.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0081-0086.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-76"><P>Page 76</P></A>


<PRE>
    }

    Counter(){
        count++;
    }
    public static void printStatus(){
        System.out.println(&quot;There are &quot;+getCount()+&quot; copies of class
 Counter&quot;);
    }
    protected void finalize() throws Throwable{
        super.finalize();
        count--;
    }

}
</PRE>


<P>The next class to be defined is the SonOfCounter class (see listing 3.24). As the
name implies, it is a child of the Counter class. The class only implements the constructor
and the printStatus() method. Note that the constructor calls super() as is required.
</P>

<P>Listing 3.24The Class Counter
</P>

<PRE>
class SonOfCounter extends Counter{
    SonOfCounter(){
        super();
    }
    public static void printStatus(){
        System.out.println(&quot;There are &quot;+getCount()+&quot; copies of class
 SonOfCounter&quot;);
    }
}
</PRE>

<P>The next class to be defined is SecondSonOfCounter. This class takes measures to
count instances only of this class. You do this by creating an instance of count and
incrementing and decrementing it, similar to the original Count class. In the constructor, you do not
call super(), but its call is implied and made by default as described in the Java
language specification.
</P>

<P>Listing 3.25The Class SecondSonOfCounter
</P>

<PRE>
class SecondSonOfCounter extends Counter{
    private static int count = 0;
</PRE>


<A NAME="PAGENUM-77"><P>Page 77</P></A>


<PRE>
    SecondSonOfCounter(){
      count++;
    }
    public static void printStatus(){
        System.out.println(&quot;There are &quot;+getCount()+&quot; copies of class
 SecondSonOfCounter&quot;);
    }
    public static int getCount(){
        return (count);
    }
    protected void finalize()throws Throwable{
        super.finalize();
        count--;
    }
}
</PRE>

<P>Listing 3.26a is the main class for this test. It first prints the counter status of each of
the three counting classes. The results are that all of the counters are zero because not
all instances have been created.
</P>

<P>Listing 3.26aClass StaticCounter: Imports, Class Definition, Static
Variables, and the main() Method
</P>

<PRE>
/** StaticCounter.java
    This demonstrates usage and problems with
    static methods and fields. It also
    show inheritance problems with statics.
*/

import java.awt.*;
import java.io.IOException;

public class StaticCounter {

    public static void main(String args[]) {
        new StaticCounter();
    }
StaticCounter(){
        System.out.println(&quot;Demonstration of class counter&quot;);
</PRE>

<P>The class diagram shown in figure 3.12 shows the layout of the StaticCounter
example. The StaticCounter class contains instances of the Counter, SonOfCounter,
and SecondSonOfCounter classes (see listing 3.26b). As you can see, SonOfCounter
and
</P>


<A NAME="PAGENUM-78"><P>Page 78</P></A>


<P>SecondSonOfCounter are child classes of Counter. SonOfCounter is used in the
obvious way, but works incorrectly. SecondSonOfCounter has been properly written.
</P>

<P>Listing 3.26bThe Class StaticCounter: Constructor Continues
</P>

<PRE>
System.out.println(&quot;Object count at start&quot;);
Counter.printStatus();
SonOfCounter.printStatus();
SecondSonOfCounter.printStatus();
System.out.println(&quot;&quot;);
</PRE>

<P>Next an instance of Counter and SonOfCounter are created and the current state of
the counters is printed. The problems because of inheritance can be seen at this point
because both the Counter and SonOfCounter objects believe that there are two instances
counted, despite the fact that only one each was created. The SecondSonOfCounter,
however, because it reimplemented the counting mechinism, was able to correctly print a
zero because no instances have been created for it yet (see listing 3.26c).
</P>

<P>Listing 3.26cThe Class StaticCounter: Constructor Continues
</P>

<PRE>
Counter a = new Counter();
SonOfCounter b = new SonOfCounter();
System.out.println(&quot;Object count after new Counter() &amp; new
 SonOfCounter()&quot;);
Counter.printStatus();
SonOfCounter.printStatus();
SecondSonOfCounter.printStatus();
System.out.println(&quot;&quot;);
</PRE>

<P>Next an instance of SecondSonOfCounter is created (see listing 3.26d). At this point
the problems of statics and inheritance become worse. The value of
SecondSonOfCounter does show the correct count of its instances; however, Counter and SonOfCounter
now show three instances! The reason for this is that the static field in the Counter class is
still being incremented by its constructor when a new instance of SecondSonOfCounter
is created.
</P>

<P>Listing 3.26dClass StaticCounter: Constructor Continues
</P>

<PRE>
SecondSonOfCounter c = new SecondSonOfCounter();
System.out.println(&quot;Object count after new SecondSonOfCounter()&quot;);
</PRE>


<A NAME="PAGENUM-79"><P>Page 79</P></A>


<PRE>
Counter.printStatus();
SonOfCounter.printStatus();
SecondSonOfCounter.printStatus();
System.out.println(&quot;&quot;);
</PRE>

<P>To complete this example, the remaining code derefrences the instance of Counter
and finalizes the reference to the SonOfCounter (see listing 3.26e). The information about
the respective counts shows that there was only one decrement of the base class. The
reason for this is that simply setting a reference to null does not mean that the finalize() method
is called. The finalize() method will be called, but only when garbage is collected. It is
good practice that whenever statics are used, always to call the finalize() method
explicitly before the object is deleted or goes out of reference. This ensures that the count will be
set to the correct value.
</P>

<P>Listing 3.26eClass StaticCounter: Constructor Continues
</P>

<PRE>
        a=null;
        try{
            b.finalize();
        }catch(Throwable x){
        }
        System.out.println(&quot;Object count after SonOfCounter a
                 &Acirc;dereferenced &amp; b finalized&quot;);
        Counter.printStatus();
        SonOfCounter.printStatus();
        SecondSonOfCounter.printStatus();
        System.out.println(&quot;&quot;);
        System.out.println(&quot;(press Enter to exit)&quot;);
        try {
            System.in.read();
        } catch (IOException e) {
            return;
        }
    }

}
</PRE>

<P>The only way out of these problems is not to get into a situation where classes with
statics must keep track of separate class type instances. One way to do this is to place the
static
</P>

<A NAME="PAGENUM-80"><P>Page 80</P></A>


<P><a href="images\ch03fg13.jpg"><img src="images\tn_ch03fg13.jpg"></a><BR>
Figure 3.13 The Password dialog box.
</P>

<P>counter mechanism only in the child class. This totally eliminates the problem.
</P>

<H4>
final
</H4>

<P>Final has the equivalent functionality of a C++ constant. Any function or variable
declared final cannot be changed. Finals can be used to prevent accidental modifications to
constant data, and they prevent classes from being inherited and methods from becoming
overloaded. Private method and static method fields are also final without having to specify
the final keyword. In addition, if a class is declared as final, all method fields declared
within a class are also final.
</P>

<P><B>
Final Methods and Classes Increase Security
</B></P>

<P>There are several reasons for stopping a class or method from being overridden.
The first benefit is security. The example in listing 3.27 uses the final modifier on
the PasswordDialog class to protect the methods and data from being overridden. This
is important if you do not want another class to break into your application by simply
over-riding your methods or classes. The resultant Password dialog box is shown in figure 3.13.
</P>

<P>This is a final class, and nothing may be inherited from it. This protects all the
methods from being overloaded. PasswordStatus interface is used to inform a client of the status
of the password comparison.
</P>

<P>Listing 3.27Class PasswordDialog
</P>

<PRE>
/** PasswordDialog.java
    PasswordDialog
import java.awt.*;
import PasswordStatus;
public final class PasswordDialog extends Frame{

    // Observer of the result of a password test.
    private PasswordStatus statusObserver;
</PRE>


<P><CENTER>
<a href="0072-0075.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0081-0086.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



