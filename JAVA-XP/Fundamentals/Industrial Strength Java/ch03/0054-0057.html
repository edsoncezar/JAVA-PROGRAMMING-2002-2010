<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Planning Your Application:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0050-0053.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0058-0061.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-54"><P>Page 54</P></A>


<P>The Java Interface model, in contrast to inheritance, is more like a learned behavior.
By implementing specific interfaces, a class can interact via the interface methods and
its specifically programmed (learned) behavior.
</P>

<P>Interfaces are also decoupling. In other words, if a pig implemented the interface
Flyer, the users of the Flyer interface would never realize that they were making a pig fly.
The class only expects that when the Flyer.fly() method is called, it flies, just not very far
in the case of our pig.
</P>

<H4><A NAME="ch03_ 22">
More Multiple Inheritance: Simple Observer
</A></H4>

<P>This next example uses an interface called DataChanged. It is an Observer
interface. Observers are used to notify interested classes of data changes in one class
without physically knowing about that class's specific implementation. The observer model
is often used to integrate a class with a GUI representation of its state.
</P>

<P>The DataChanged interface is implemented by the NameLabel class. The Name class
uses an object of the NameLabel class as a cast to DataChanged. This method of sharing
of information allows the Name class to treat the NameLabel class as a DataChanged
class. What has been accomplished is that the Name class does not require access to
any methods of the NameLabel class! This is sometimes called decoupling.
Decoupling classes reduces interdependencies between classes, making them less susceptible to
design changes. For instance, if either NameLabel or Name changes anything about the way
that their classes are designed, as long as the DataChanged Interface is implemented, the
two classes will not change their behavior with respect to the DataChanged behavior.
</P>

<P>In figure 3.11, you can see the decoupling of the Name and NameLabel classes.
Both
</P>

<a href="images\ch03fg11.jpg"><img src="images\tn_ch03fg11.jpg"></a><BR>
Figure 3.11 A Booch diagram for a simple observer example.
</P>

<A NAME="PAGENUM-55"><P>Page 55</P></A>


<P>classes use the DataChanged interface. The NameLabel class implements it,
whereas DataChanged interface is a member of the Name class. The code that makes this all
work is in the SimpleObserver class, which connects the NameLabel to Name by setting
the DataChanged member of Name with the NameLabel object cast as a DataChanged
type. These classes are defined in listing 3.4.
</P>

<P>A simple example of these classes's use is also described so that the relationships can
be understood. Listing 3.4 is the DataChanged interface. It defines an abstract
method dataChanged(), which takes a string as an argument. This function will be called by
the originator of data and be a part of the observer's implementation.
</P>

<P>Listing 3.4Name Class: Imports, Class Definition, and Constructors
</P>

<PRE>
interface DataChanged{
    void dataChanged(String newData);
}
</PRE>

<P>Listing 3.5a is the beginning of the Name class. This class extends the
java.awt.TextField class. In this section of the class listing, one of the constructors for the TextField
is implemented so that an object can be created. There is also a field defined as
&quot;observer,&quot; which is a DataChanged interface type.
</P>

<P>Listing 3.5aName Class: Imports, Class Definition, and Constructors
</P>

<PRE>
/** Name.java
    * Name widget that informs a DataChanged observer
    of the current contents after each key press.
*/
import DataChanged;
import java.awt.*;
class Name extends TextField{
    DataChanged observer;
public Name(int columns){
           super(columns);
}
</PRE>


<A NAME="PAGENUM-56"><P>Page 56</P></A>


<P>Listing 3.5b defines a method that will set the DataChanged observer. After this
method is called, setting the interested observer the next time a character is typed causes the
observer to be called with the current contents of this text field.
</P>

<P>Listing 3.5bName Class: The setObserver() Method
</P>

<PRE>
void setObserver(DataChanged observer){
            this.observer = observer;
    }
</PRE>

<P>Listing 3.5c shows the handleEvent() method, which is waiting for a key release event.
If one occurs and the observer is not null, then the observer is called with the
current contents of the string. Because this is the end of listing 3.5, notice that there has been
no mention of what the observer is. All this class is associated with is the
DataChanged interface, which is treated as an object. Any class that implemented the
DataChanged interface could have been passed in the setObserver() method.
</P>

<P>Listing 3.5cName Class: The handleEvent() Method
</P>

<PRE>
    public boolean handleEvent(Event event) {
           if (event.id == Event.KEY_RELEASE &amp;&amp;
               event.target == this &amp;&amp;
               observer != null) {
                  observer.dataChanged(getText());
        }
           return super.handleEvent(event);
    }

}
</PRE>

<P>The NameLabel class in listings 3.6a and 3.6b is the observer in this example. The
class definition in 3.6a shows that the class extends the java.awt.Label class so that it
can represent the observed data as a label on a window. The class also implements
the DataChanged interface.
</P>

<P>Listing 3.6aNameLabel Class: Imports, Class Definition, and Constructors
</P>

<PRE>
import DataChanged;
import java.awt.*;
class NameLabel extends Label implements DataChanged{
     public NameLabel(String contents){
         super(contents);
     }
 }
</PRE>


<A NAME="PAGENUM-57"><P>Page 57</P></A>


<P>The final method in this class is the implementation of the
DataChanged.dataChanged() method. The method sets the current displayed contents to the value of the string
parameter newData. Again, decoupling is evident because the class does not have any
reference to the data source. The class only has a method that can be used by any data source.
</P>

<P>Listing 3.6bNameLabel Class: The dataChanged() Method
</P>

<PRE>
    /** Called by class Name when its contents are updated */
    public void dataChanged(String newData){
        setText(newData);
    }
}
</PRE>

<P>The next class is an extension of the Frame class for use as the main window of
an application. It is the thrust of this example and has both the Name and NameLabel
classes. The final connection of the observer to the data source takes place after
an instance of Name class is created. The setObserver() method is called, with the
instance of NameLabel cast as DataChanged. This finally couples the observer to the
observed.
</P>

<P>Listing 3.7aSimpleObserver Class: Imports, Class Definition, and Constructors
</P>

<PRE>
import Name;
import NameLabel;
import DataChanged;
import java.awt.*;

public class SimpleObserver extends Frame {

    public SimpleObserver() {

       super(&quot;SimpleObserver window&quot;);

       setLayout(null);
       addNotify();
           resize(insets().left + insets().right + 348, insets().top +
            &Acirc;insets().bottom + 164);
           label2=new Label(&quot;Simple Observer Demonstration&quot;,
            &Acirc;Label.CENTER);
           add(label2);
           label2.reshape(insets().left + 44,insets().top + 10,250,16);

</PRE>

<P><CENTER>
<a href="0050-0053.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0058-0061.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



