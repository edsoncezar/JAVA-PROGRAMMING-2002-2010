<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Planning Your Application:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0062-0066.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0072-0075.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-67"><P>Page 67</P></A>


<PRE>
            System.in.read();
        } catch (IOException e) {
            return;
        }
    }
</PRE>

<P>Listing 3.15c defines the helper function getObjectOfClass() used for loading classes.
</P>

<P> Listing 3.15cThe Class ClassLoad
</P>

<PRE>
public Object getObjectOfClass(String className)
        throws IOException
    {
        Object anObject;
        try{
            Class aClass = Class.forName(className);
            anObject = aClass.newInstance();
        } catch(Exception ex){
            throw new IOException(ex.toString());
        }

        return anObject;
    }
</PRE>

<P>Listing 3.15d defines the objectAnalyze() method that demonstrates available
class information.
</P>

<P>Listing 3.15dThe Class ClassLoad
</P>

<PRE>
    // Prints information about an object
    void objectAnalyze(Object target){
        System.out.println(&quot;Name: &quot;+target.getClass().getName());
        System.out.println(&quot;Super Class:&quot;+target.getClass().
                 &Acirc;getSuperclass());
        System.out.println(&quot;isInterface():&quot;+target.getClass().
                 &Acirc;isInterface());
        //Get any implemented interfaces
        Class interfaces[] = target.getClass().getInterfaces();
        //Print interface names if they exist
        if (interfaces.length != 0){
            for ( int  i=0 ; i &lt; interfaces.length ;  i++  ){
                System.out.println(&quot;ImplementsInterface:&quot;+interfaces[i].
                       &Acirc;getName());
</PRE>

<A NAME="PAGENUM-68"><P>Page 68</P></A>


<PRE>
            }
        }
        System.out.println(&quot;Objet.hashCode():&quot;+target.hashCode());
        System.out.println(&quot;Objet.toString():&quot;+target.toString());
    }

}
</PRE>

<P>Listing 3.16 defines the PlugInterface interface.
</P>

<P>Listing 3.16PlugInterface Interface
</P>

<PRE>
interface PlugInterface{
    void plug();
}
</PRE>

<P>Listing 3.17 defines the SocketInterface interface.
</P>

<P>Listing 3.17SocketInterface Interface
</P>

<PRE>
interface SocketInterface{
    void socket();
}
</PRE>

<P>Listing 3.18 defines the test class, Foo, that extends a base class and implements
interfaces.
</P>

<P>Listing 3.18Class Foo
</P>

<PRE>
class Foo extends Bar implements PlugInterface, SocketInterface{
    Foo(){// Contructor with no arguments
        super();
    }
    public String toString(){
        return(&quot;this is an object of class Foo saying hello!&quot;);
    }
    // Interface implementations.
    public void plug(){}
    public void socket(){}
}
</PRE>


<A NAME="PAGENUM-69"><P>Page 69</P></A>


<P>Listing 3.19 defines the base class, Bar.
</P>

<P>Listing 3.19Class Bar
</P>

<PRE>
class Bar{
    Bar(){}// Contructor with no arguments
    public String toString(){
        return(&quot;this is an object of class Bar saying hello!&quot;);
    }
}
</PRE>

<H3>
Access Modifiers
</H3>

<P>There is a lot of power in the different ways that classes can be defined. If you are
moving from another language to Java, you may not initially realize the reasoning behind many
of these language features. They may seem limiting to some programmers, but they
are intended to create robust and easily maintainable programs. Many of the language's
features prevent mistakes that may be made by teams of programmers and users of code
libraries. Whether you use these access modifiers or not, they are still worth learning because
Sun's libraries and others use these constructs. Table
3.2 summarizes them.
</P>

<TABLE>

<TR><TD>
Access Modifier
</TD><TD>
Type
</TD><TD>
Description
</TD></TR><TR><TD>
&quot;none&quot;
</TD><TD>
Access Modifier
</TD><TD>
Package classes
have access to member
</TD></TR><TR><TD>
public
</TD><TD>
Access Modifier
</TD><TD>
All classes have access
</TD></TR><TR><TD>
Private
</TD><TD>
Access Modifier
</TD><TD>
Only the class has access
</TD></TR><TR><TD>
protected
</TD><TD>
Access Modifier
</TD><TD>
Package, class, and
child classes have access
</TD></TR><TR><TD>
private protected
</TD><TD>
Access Modifier
</TD><TD>
Class and child
classes have access
</TD></TR><TR><TD>
abstract
</TD><TD>
Declaration
</TD><TD>
Defines class or
methods as abstract
</TD></TR><TR><TD>
static
</TD><TD>
Declaration
</TD><TD>
Defines methods or
fields as the only instance in a class
</TD></TR><TR><TD>
final
</TD><TD>
Declaration
</TD><TD>
Defines class, method,
or field as the final definition 
</TD></TR></TABLE>

<A NAME="PAGENUM-70"><P>Page 70</P></A>


<TABLE>

<TR><TD>
</TD><TD>
</TD><TD>
in a class tree
</TD></TR><TR><TD>
volatile
</TD><TD>
Declaration
</TD><TD>
Marks a field for
special handling
</TD></TR><TR><TD>
transient
</TD><TD>
Declaration
</TD><TD>
Marks a field as
non-serializable
</TD></TR></TABLE>

<H4>
&quot;none&quot; (Also Called Package)
</H4>

<P>The default method modifier is &quot;package.&quot; Classes in the same package can access
any method or field that is not explicitly restricted to private. This default is similar to
&quot;friend&quot; in C++. None is the default because it makes it easy to write collections of
interdependent classes without resorting to adding access modifiers, except to make some classes
and members public. This is simpler than the C++ default, which is private.
</P>

<P>It is important to remember that any class that is not in a package becomes part of
the default package. Unless you explicitly declare a method private, it will be visible to
all other package-less classes.
</P>

<P>If a future application is grouped into packages, it is best to do it from the very
beginning. This ensures that all your code tests these functions for visibility from the start of
the development process.
</P>

<H4><A NAME="ch03_ 26">
public
</A></H4>

<P>The public modifier causes a class method or field to be visible to any other class in
an application regardless of package membership. Only use public for methods that
are meant to be called by classes outside of packages.
</P>

<H4><A NAME="ch03_ 27">
private
</A></H4>

<P>This is the most restrictive modifier. It absolutely bars access to methods and fields in
a class. This prevents client or child classes from inappropriately accessing a class's
internal data and methods.
</P>

<P>It is good practice to make all data and methods private until it is an absolute certainty
that another class will require it.
</P>

<H4><A NAME="ch03_ 28">
protected
</A></H4>


<A NAME="PAGENUM-71"><P>Page 71</P></A>


<P>Protected members are accessible by child classes and by classes in the same
package. The types of methods that have this modifier should be those that are utilities used by
the public interface. For example, a package that implements a text editor would have
its classes for manipulating the class as public, but the classes that do the actual drawing
of the text on a panel would be protected. These protected classes could be inherited from
the user to add new implementations such as adding languages like French or Chinese.
</P>

<H4><A NAME="ch03_ 29">
private protected
</A></H4>

<P>Private protected methods and fields are accessible by child classes. Fields and
methods that are only used within the class and necessary for child classes should be
declared private protected.
</P>

<P>In the chess piece example, the base class Piece contains a method called
addMove(), which is used by all child classes to perform some of the actions required in the
abstract method generateMoves(). There is no reason for addMove() to be accessed by any
other class in the chess package or the rest of the program. This protection ensures that
another class will not use it out of context of its intended function. Marking the method in this
way also documents the fact that it is used by creators of child classes. Your knowing this
helps programmers design to the intent specified for children of the class.
</P>

<H4><A NAME="ch03_ 30">
abstract
</A></H4>

<P>An abstract method is a method definition without a body. The class cannot be
initialized. The class must be subclassed with all abstract methods overloaded with
non-abstract functions. Methods in interfaces are defaulted to abstract.
</P>

<P>The abstract method was used earlier in the chapter in the chess piece example.
Listing 3.20 shows some code from that example. Notice that the class is labeled as abstract,
as well as the generateMoves() method. If any method is marked as abstract, the class
must also be marked as abstract. This helps document the class.
</P>

<P>Listing 3.20Class Piece Showing the Abstract() Method
</P>

<PRE>
public abstract class Piece{
    // Abstract function specific to each piece
    public abstract Vector generateMoves(Board board);
       &#133;
}
</PRE>

<P><CENTER>
<a href="0062-0066.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0072-0075.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



