<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Interfacing C/C++ and Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0610-0613.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0619-0622.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-614"><P>Page 614</P></A>



<P>Listing 14.11 Continued
</P>
<PRE>
struct HTestObject;
extern struct HTestObject *NativeTest_nativeObject(struct HNativeTest
&Acirc;*,struct HTestObject *);
extern HArrayOfObject *NativeTest_nativeObjectArray(struct HNativeTest
&Acirc;*,HArrayOfObject *);
extern void NativeTest_callJava(struct HNativeTest *);
extern void NativeTest_doExceptions(struct HNativeTest *,long);
extern void NativeTest_testException2(struct HNativeTest *);
#ifdef __cplusplus
}
#endif
#endif
</PRE>

<H4><A NAME="ch14_ 16">
Stub Files Generated by javah
</A></H4>

<P>The following code shows the C stubs file generated for the NativeTest class. A stub
file contains all of the Java-to-C translation. Java creates the names of methods based on
the class name, the method name, and the return value of the C function that is
returned. Because this file is generated by javah, it is important that this file not be used as
a repository of implementations for the stubs. The drawback to keeping the
implementations and stubs separate is that cut and paste operations are required after changes to the
Java code.
</P>

<P>The code in listing 14.12 shows the C stub file generated by javah for the TestObject
class. Stubs are methods that are in a format that can be understood by Java. The stub
method calls a C function that is closer to a human readable format. Note that this file
contains nothing important because TestObject.Java does not have any native methods for which
to create stubs. This file is not necessary for creating the loadable library, but is included
here for completeness.
</P>

<P>Listing 14.12 The Stub File for the TestObject Class
</P>
<PRE>
/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;StubPreamble.h&gt;
/* Stubs for class TestObject */
</PRE>

<P>Listing 14.13 contains a typical stub. The particular stub is for
NativeTest.nativeInt() method and was extracted from listing 14.14 which contains the complete stub file for
the NativeTest class.
</P>

<A NAME="PAGENUM-615"><P>Page 615</P></A>



<P>Listing 14.13 Stub for the NativeTest,nativeInt() Method
</P>
<PRE>
/* SYMBOL: &quot;NativeTest/nativeInt(I)I&quot;, Java_NativeTest_nativeInt_stub */
__declspec(dllexport) stack_item
&Acirc;*Java_NativeTest_nativeInt_stub(stack_item *_P_,struct execenv *_EE_) {
       extern long NativeTest_nativeInt(void *,long);
      _P_[0].i = NativeTest_nativeInt(P_[0].p,((P_[1].i)));
       return _P_ + 1;
}
</PRE>

<P>The function that is defined in this stub was written in NativeTest class as int
nativeInt(int anInt);. There obviously is a lot involved in going from Java to C and back again.
Each stub contains six lines, defined as follows:
</P>

<UL>
<LI>     The first line describes how Java stores the signature of the method. The
signature is a string that can be parsed by Java.
<LI>     The second line is the stub function called by Java. All stubs pass because the
first argument, P, is a pointer to the current program stack. The second parameter is
a pointer to the execution environment execution environment.
<LI>     The third line is a function prototype of the implementation for this method.
<LI>     The fourth line is the C function to be called. The stack pointer P is used as
an array to select arguments from the stack.
<LI>     The fifth line also uses P as a place to return the C function results back
onto Java's program stack.
<LI>     The sixth line is the curly bracket that closes the stub function.
</UL>

<P>Listing 14.14 The Complete Stub File for the NativeTest Class
</P>
<PRE>
/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;StubPreamble.h&gt;
/* Stubs for class NativeTest */
/* SYMBOL: &quot;NativeTest/nativeInt(I)I&quot;, Java_NativeTest_nativeInt_stub */
  declspec(dllexport) stack_item
&Acirc;*Java_NativeTest_nativeInt_stub(stack_item *_P_,struct execenv *_EE_) {
       extern long NativeTest_nativeInt(void *,long);
       _P_[0].i = NativeTest_nativeInt(_P_[0].p,((_P_[1].i)));
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/nativeChar(C)C&quot;, Java_NativeTest_nativeChar_stub */
  declspec(dllexport) stack_item
</PRE>
<PRE>
                                                                             continues
</PRE>

<A NAME="PAGENUM-616"><P>Page 616</P></A>



<P>Listing 14.14 Continued
</P>
<PRE>
 &Acirc;*Java_NativeTest_nativeChar_stub(stack_item *_P_,struct execenv *_EE_)
 {
       extern long NativeTest_nativeChar(void *,long);
       _P_[0].i = NativeTest_nativeChar(_P_[0].p,((_P_[1].i)));
       return _P_ + 1;
  }
  /* SYMBOL: &quot;NativeTest/nativeShort(S)S&quot;,Java_NativeTest_nativeShort_stub */
  declspec(dllexport) stack_item *Java_NativeTest_nativeShort_stub
    &Acirc;(stack_item *_P_,struct execenv *_EE_){
       extern long NativeTest_nativeShort(void *,long);
       _P_[0].i = NativeTest_nativeShort(_P_[0].p,((_P_[1].i)));
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/nativeFloat(F)F&quot;,
&Acirc;Java_NativeTest_nativeFloat_stub */
  declspec(dllexport) stack_item
&Acirc;*Java_NativeTest_nativeFloat_stub(stack_item *_P_,struct execenv *_EE_){
       extern float NativeTest_nativeFloat(void *,float);
       _P_[0].f = NativeTest_nativeFloat(_P_[0].p,((_P_[1].f)));
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/nativeDouble(D)D&quot;,
&Acirc;Java_NativeTest_nativeDouble_stub */
  declspec(dllexport) stack_item
&Acirc;*Java_NativeTest_nativeDouble_stub(stack_item *_P_,struct execenv *_EE_){
       Java8 _tval;
       Java8 _t1;
       extern double NativeTest_nativeDouble(void *,double);
       SET_DOUBLE(_tval, _P_,
&Acirc;NativeTest_nativeDouble(_P_[0].p,GET_DOUBLE(_t1, _P_+1)));
       return _P_ + 2;
}
/* SYMBOL: &quot;NativeTest/nativeBoolean(Z)Z&quot;,
&Acirc;Java_NativeTest_nativeBoolean_stub */
  declspec(dllexport) stack_item
&Acirc;*Java_NativeTest_nativeBoolean_stub(stack_item *_P_,struct execenv
&Acirc;*_EE_) {
       extern long NativeTest_nativeBoolean(void *,long);
       _P_[0].i = (NativeTest_nativeBoolean(_P_[0].p,((_P_[1].i))) ?
&Acirc;TRUE : FALSE);
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/nativeIntArray([I)[I&quot;,
&Acirc;Java_NativeTest_nativeIntArray_stub */
</PRE>

<A NAME="PAGENUM-617"><P>Page 617</P></A>


<PRE>
  declspec(dllexport) stack_item
 *Java_NativeTest_nativeIntArray_stub(stack_item *_P_,struct execenv
 &Acirc;*_EE_) {
       extern void* NativeTest_nativeIntArray(void *,void *);
       _P_[0].p = NativeTest_nativeIntArray(_P_[0].p,((_P_[1].p)));
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/nativeCharArray([C)[C&quot;,
&Acirc;Java_NativeTest_nativeCharArray_stub */
  declspec(dllexport) stack_item
&Acirc;*Java_NativeTest_nativeCharArray_stub(stack_item *_P_,struct execenv
&Acirc;*_EE_) {
       extern void* NativeTest_nativeCharArray(void *,void *);
       _P_[0].p = NativeTest_nativeCharArray(_P_[0].p,((_P_[1].p)));
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/nativeShortArray([S)[S&quot;,
&Acirc;Java_NativeTest_nativeShortArray_stub */
  declspec(dllexport) stack_item
&Acirc;*Java_NativeTest_nativeShortArray_stub(stack_item *_P_,struct execenv
&Acirc;*_EE_) {
       extern void* NativeTest_nativeShortArray(void *,void *);
       _P_[0].p = NativeTest_nativeShortArray(_P_[0].p,((_P_[1].p)));
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/nativeFloatArray([F)[F&quot;,
 &Acirc;Java_NativeTest_nativeFloatArray_stub */
  declspec(dllexport) stack_item
&Acirc;*Java_NativeTest_nativeFloatArray_stub(stack_item *_P_,struct execenv
&Acirc;*_EE_) {
       extern void* NativeTest_nativeFloatArray(void *,void *);
       _P_[0].p = NativeTest_nativeFloatArray(_P_[0].p,((_P_[1].p)));
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/nativeDoubleArray([D)[D&quot;,
 &Acirc;Java_NativeTest_nativeDoubleArray_stub */
  declspec(dllexport) stack_item
&Acirc;*Java_NativeTest_nativeDoubleArray_stub(stack_item *_P_,struct execenv
&Acirc;*_EE_) {
       extern void* NativeTest_nativeDoubleArray(void *,void *);
       _P_[0].p = NativeTest_nativeDoubleArray(_P_[0].p,((_P_[1].p)));
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/nativeBooleanArray([Z)[Z&quot;,
 &Acirc;Java_NativeTest_nativeBooleanArray_stub */
  declspec(dllexport) stack_item
</PRE>
<PRE>
                                                                                continues
</PRE>

<A NAME="PAGENUM-618"><P>Page 618</P></A>



<P>Listing 14.14 Continued
</P>
<PRE>
 &Acirc;*Java_NativeTest_nativeBooleanArray_stub(stack_item *_P_,struct execenv
 &Acirc;*_EE_) {
       extern void* NativeTest_nativeBooleanArray(void *,void *);
       _P_[0].p = NativeTest_nativeBooleanArray(_P_[0].p,((_P_[1].p)));
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/nativeObject(LTestObject;)LTestObject;&quot;,
 &Acirc;Java_NativeTest_nativeObject_stub */
  declspec(dllexport) stack_item
 &Acirc;*Java_NativeTest_nativeObject_stub(stack_item *_P_,struct execenv
 &Acirc;*_EE_) {
       extern void* NativeTest_nativeObject(void *,void *);
       _P_[0].p = NativeTest_nativeObject(_P_[0].p,((_P_[1].p)));
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/nativeObjectArray([LTestObject;)[LTestObject;&quot;,
 &Acirc;Java_NativeTest_nativeObjectArray_stub */
  declspec(dllexport) stack_item
 &Acirc;*Java_NativeTest_nativeObjectArray_stub(stack_item *_P_,struct execenv
 &Acirc;*_EE_) {
       extern void* NativeTest_nativeObjectArray(void *,void *);
       _P_[0].p = NativeTest_nativeObjectArray(_P_[0].p,((_P_[1].p)));
       return _P_ + 1;
}
/* SYMBOL: &quot;NativeTest/callJava()V&quot;, Java_NativeTest_callJava_stub */
  declspec(dllexport) stack_item
 &Acirc;*Java_NativeTest_callJava_stub(stack_item *_P_,struct execenv *_EE_) {
       extern void NativeTest_callJava(void *);
       (void) NativeTest_callJava(_P_[0].p);
       return _P_;
}
/* SYMBOL: &quot;NativeTest/doExceptions(I)V&quot;,
 &Acirc;Java_NativeTest_doExceptions_stub */
  declspec(dllexport) stack_item
 &Acirc;*Java_NativeTest_doExceptions_stub(stack_item *_P_,struct execenv
  &Acirc;*_EE_) {
       extern void NativeTest_doExceptions(void *,long);
       (void) NativeTest_doExceptions(_P_[0].p,((_P_[1].i)));
       return _P_;
}
/* SYMBOL: &quot;NativeTest/testException2()V&quot;,
 &Acirc;Java_NativeTest_testException2_stub */
  declspec(dllexport) stack_item
</PRE>

<P><CENTER>
<a href="0610-0613.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0619-0622.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



