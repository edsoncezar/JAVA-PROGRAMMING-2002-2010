<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Interfacing C/C++ and Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0627-0629.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0634-0638.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-630"><P>Page 630</P></A>


<P>technique is okay with only a single value, but it is not possible if the native code
causes multiple changes. Also, a return value is not always possible. The variable, for
example, might be a private field and should not be visible to any other object.
</P>

<B>
Method Signatures and Passing Data to Java Methods
</B>

<P>Before learning the ways to call Java functions, you need to become familiar with
the signature parameter that all Java functions have in common. The signature parameter
is used by the Java VM to locate a specific method. Java cannot look up a method just by
its name. It must also know the types of parameters and the return value. Armed with
this information, Java can properly locate and call the method.
</P>

<P>The method signature for constructors and methods that take no data is simply
&quot;().&quot; Alternatively, the same dynamic or static method signature could be expressed as
&quot;()V&quot; where the V translates as the void type.
</P>

<B>
Designating Primitive Types
</B>

<P>Signatures of constructors that take arguments are built by inserting a special
translation of the primitive and object types. Table 14.2 lists the primitive types and their
equivalent signature types. Primitive signatures are single letters that are used to distinguish the
type to be used in arguments or as return types.
</P>

<P>Table 14.2<BR>
Primitive Type 
Signatures
</P>
<TABLE>

<TR><TD>
Java Type
</TD><TD>
Signature Type
</TD></TR><TR><TD>
Boolean
</TD><TD>
Z
</TD></TR><TR><TD>
byte
</TD><TD>
B
</TD></TR><TR><TD>
char
</TD><TD>
C
</TD></TR><TR><TD>
short
</TD><TD>
S
</TD></TR><TR><TD>
int
</TD><TD>
I
</TD></TR><TR><TD>
long
</TD><TD>
J
</TD></TR><TR><TD>
float
</TD><TD>
F
</TD></TR><TR><TD>
double
</TD><TD>
D
</TD></TR></TABLE>

<P>These single characters are placed inside the parentheses to signify parameters, and
are placed after the parentheses to specify the type the method returns. Do not use spaces
or commas because they are not allowed; spaces cause interpretation of the signature to
fail. For the Java method shown in listing 14.19, the equivalent signature that is required
to access it is &quot;(ZBSIJFDC)I.&quot;
</P>


<A NAME="PAGENUM-631"><P>Page 631</P></A>



<P>Listing 14.19 Method Specification Matching the &quot;(ZBSIJFDC)I&quot; Method
Signature
</P>

<PRE>
int foo(boolean tBoolean,byte tByte,short tShort, int tInt,long
&Acirc;tLong,float tFloat,
&Acirc;double tDouble,char tChar,String tString);
</PRE>
<P>
<B>
Designating Arrays of Primitive Types
</B>
</P>

<P>When an array is passed into or returned from a method, the class signature is
different. For arrays, a bracket ([) character is fixed to the type character. The signature,
&quot;([Z[B[S[I-     [J[F[D[C)V,&quot; is used to designate the method in listing 14.20. Arrays need to be
passed into native methods whenever the Java program uses them and needs to pass the data
to native C code. Alternativly, a C program may create arrays that are returned.
</P>

<P>Listing 14.20 Method Specification Matching the &quot;([Z[B[S[I[J[F[D[C)V&quot;
Method Signature
</P>

<PRE>
void testArrays(boolean tBooleans[],byte tBytes[],short tShorts[], int
&Acirc;tInts[],long tLongs[],
&Acirc;float tFloats[],double tDoubles[],char tChars[]);
</PRE>

<P>For multidimensional arrays, simply add a [ for each extra dimension. For instance,
an array defined as having two dimensions, such as &quot;int point[][];&quot;, would require [[I
to designate a two-dimensional integer array.
</P>

<B>
Designating Objects
</B>

<P>Objects signatures are similar to class signatures except that the L is prefixed and the
&quot;;&quot; character is appended to the end of the class signature. For instance, the String class
would be formatted as &quot;Ljava/lang/String;&quot;. A user-defined class, TestObject, would be
defined as &quot;LTestObject;&quot;. These signature definitions are placed into the signature string just
like primitives, but without spaces or commas.
</P>

<P>Class signatures are used any time a Java method is to be called from native C code.
This use also is true for constructors that need method signatures to locate the correct
version of a constructor that matches the parameters listed in the signature.
</P>

<P>The following code shows an example of a Java method that returns an object and
mixes primitive types, a primitive array, and object types. The equivalent signature for
this method is &quot;(I[JLTestObject;Ljava/lang/String;)Ljava/util/Vector.&quot;
</P>

<A NAME="PAGENUM-632"><P>Page 632</P></A>


<P>Listing 14.21 Matching the &quot;(I[JLTestObject;Ljava/lang/String;)Ljava/util/
Vector&quot; Method Signature
</P>

<PRE>
Vector foo(int anInt,long longArray[],TestObject obj[], String str);
</PRE>
<P>
<B>
Accessing Java Classes and Objects
</B>
</P>

<P>Four types of functions are used to access the Java
environment. These enable class look-up, object instantiation, and execution
of static or dynamic functions. Accessing Java from C is
important because native methods are parts of classes and require access
to methods just like all other methods have access. Also,
native methods need to be able to create objects because a native
method may be called to build objects that will be used later. A
native method in an image processing system may, for example, need
to call other methods to get setting information and may create
objects that represent images that it processes.
</P>

<P>Table 14.3 lists the functions that can be used to access Java
classes and methods. They are described in detail in the following sections.
</P>

<P>Table 14.3
<BR>
Java to C Access Functions
</P>

<TABLE>
<TR><TD>
Access Function
</TD><TD>
Purpose
</TD></TR>

<TR><TD>
FindClass()
</TD><TD>
Used to load a class for access or to
create objects.
</TD></TR>

<TR><TD>
Execute_java_static_method()
</TD><TD>
Used to access a class static method.
</TD></TR>

<TR><TD>
execute_java_constructor()
</TD><TD>
Used to create new Java objects.
</TD></TR>

<TR><TD>
Execute_java_dynamic_method()
</TD><TD>
Used to execute methods of an
object.
</TD></TR></TABLE>
<BR><BR>


<P><B>
FindClass() Method
</B></P>

<P>FindClass is the C equivalent of the loadClass() method in the ClassLoader class.
The definition and implementation of this method are quite simple.
</P>

<P>Listing 14.22 FindClass Function Definition
</P>

<PRE>
ClassClass *FindClass(ExeEnv *ee, char *class_name, bool_t resolve);<BR>
</PRE>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
If you are ever unsure about how to format a signature, create
a native function that is equivalent to the Java function, and then
run javah with the -stubs option. The C file that is created will
have the proper formatting of the signature for
the method in a comment block just above the stub call.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>


<A NAME="PAGENUM-633"><P>Page 633</P></A>


<P>The ee parameter is the execution environment; class_name is the C string signature of <BR>
the requested class. Class signatures are created by using the same package and
class name that is normally used with all &quot;.&quot; characters substituted with the
&quot;/&quot; character. For instance, java.lang.Vector would become java/lang/Vector.
</P>

<P>The code of listing 14.23 loads a class named TestObject.
</P>

<P>Listing 14.23 Example of FindClass: Creating a Class Reference to the
TestObject Class
</P>
<PRE>
ClassClass * testClass;
testClass = FindClass(EE(),&quot;TestObject&quot;,TRUE);
</PRE>

<P>Find class is used to access information about a Java class. The return value is used in <BR>
the Execute_java_static_method() to resolve the class that the static method
executed. FindClass also is used in the execute_java_constructor() method to access the
constructor method for the class.
</P>
<B>
execute_java_static_method()
</B>

<P>After a class has been found, any static function may be called by using
the execute_java_static_method() function. Here is the definition of this function:
</P>

<P>Listing 14.24 The execute_java_static_method() Function Definition
</P>
<PRE>
long execute_java_static_method(  ExeEnv *ee
                  , ClassClass *classHandle
                  , char *methodName
                  , char *signature
                  ,&#133;);
</PRE>

<P>Here, the classHandle field contains the handle to a Java class, and methodName is
the name of a static function within the referenced class. If execute_java_static_method()
does not locate the method name, then the function returns 0, otherwise it returns 1.
Listing 14.25 looks up a class and calls its static method.
</P>

<P><CENTER>
<a href="0627-0629.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0634-0638.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



