<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Interfacing C/C++ and Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0593-0596.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0600-0604.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-597"><P>Page 597</P></A>


<P>The first step of optimization is to prove that the current version is slow. Sometimes
this may only require a simple comparison of a Java implementation to a native
application that does a similar task. Comparing Java to native applications is only valid when
running the Java application with a good JIT or as a compiled Java application. Unless the code
is very similar between Java and native applications, it may be a hard comparison to
make. Compare only function to function. Sometimes the order of execution is changed
when converting between C or C++ to Java. For instance, reading a file may be done at
the beginning of an application and then processing is performed, whereas the Java
version may read a file while processing each item from a file. In the Java application,
the processing appears to take longer because file I/O is included.
</P>

<P>Speed problems may be caused by poor design and not Java. Try to isolate
specific functions for speed comparison. Avoid believing that Java is taking too long unless
you have a valid benchmark for the same task written in native code. It is very easy to
mistakenly believe that a task that takes several minutes might be slow because of Java. In fact,
a task may take several minutes when written in any language.
</P>

<P>The most important rule of optimization is to worry about it only after the first version
has been written. The wisdom in this statement is like the wisdom of not counting
your chickens before they hatch. Some functions may not work as intended or be used as
often as expected. Like eggs that may not produce chickens,
functions may not execute as many times as expected, if they run at all. The design effort optimizing functions should
be proportional to the number of times that a function or code segment runs. For instance,
a function that runs hundreds of times is a better candidate for optimization than a
function that runs once.
</P>

<P>A lot of work can be done during design to increase speed, but the increase may not
be worth the time invested. Optimization is a subjective quantity until it can be compared to
a definitive benchmark. Do not waste time optimizing a function that has never been run
to see how fast or slow the initially designed version is.
</P>

<P>When choosing which functions to optimize with native functions, be aware of the
<SUP>90</SUP>/<SUB>10</SUB> rule. This rule states that 90 percent of execution time is spent in only 10 percent (or
less) of the code. Benchmark the code until you find the 10 percent that requires the
most optimization. When replacing Java with C, benchmarking is important because it is
safer to keep as much of the code written in Java as possible.
</P>

<A NAME="PAGENUM-598"><P>Page 598</P></A>


<H3><A NAME="ch14_ 8">
Easy Native Access: Using <BR>Runtime.exec()
</A></H3>

<P>When mixing Java with the native environment, first consider having native
applications controlled by Java. This solution does not require any direct Java to C linkage or
Java instrumented native libraries. All that is needed is a
native executable that performs the required functions. The native executable can communicate to the Java application
in various ways. Java and native applications can use the native executable's standard I/O
or read and write files that are also manipulated by the Java application.
</P>

<P>System programs have the capability to perform various native tasks, some of which
are inaccessible to Java, such as starting database servers or launching
editors to view files. Java can control these applications through standard I/O by accessing the Standard
In, Standard Out, and Standard Error I/O streams. If you can encapsulate all the native
actions into an executable, you would have an easy method to access native
tasks. This also is a simple way of launching other programs, such as Netscape, or retrieving the results
of DOS commands, such as dir and attrib. Programs that accept standard I/O and std out
can be used to process data within Java applications. For instance, Unix utilities such as
troff (a text formatting utility) can be fed information through Standard In, whereas the
results can be piped to a printer or read back into Java for further processing.
</P>

<P>The exec() method in the Runtime class launches the native executables. This method
is similar to the exec() or fork() functions found in many C libraries. The return value
of exec() is a Process object. The Process object is used to access standard I/O of
the application and to monitor completion status.
</P>

<H4><A NAME="ch14_ 9">
Accessing the Studio Streams
</A></H4>

<P>The Runtime class can be used to start Netscape or text editors. This is a simple method <BR>
of displaying and printing a Java application's results.
</P>

<P>Two functions in the Runtime class can be used to start native applications. The
first, shown in listing 14.1, accepts a String that contains the command to be run and
its options.
</P>

<P>Listing 14.1 The exec() Method
</P>

<PRE>
Process exec(commandArray) throws Ioexception;
</PRE>

<A NAME="PAGENUM-599"><P>Page 599</P></A>



<P>The command is simple and can be used as it is in listing 14.2 to get a DOS directory <BR>
of text files:
</P>

<P>Listing 14.2 Executing a Directory Command with exec
</P>
<PRE>
try{
      Process dosProcess = Runtime.getRuntime().exec(&quot;dir *.txt&quot;);
}catch(IOException ex){
      System.err.println(&quot;Command failed with IO Exception.&quot;);
}
</PRE>

<P>The second version of exec() accepts an array of String variables. In this form,
the command is in the zero index of the array, whereas the arguments are placed separately
in the remaining array indexes. This version is slightly faster than the first because it does
not need to parse the command string.
</P>

<P>Listing 14.3 The exec() Method that Accepts a Command Array
</P>

<PRE>
Process exec(commandArray) throws Ioexception;
</PRE>

<P>Here is the same DOS directory example using the command array version of exec().
</P>

<P>Listing 14.4 Using a Command Array Version of exec() to Execute a DOS
Directory Command
</P>
<PRE>
String dosCommand[] = new String[2];
dosCommand[0] = &quot;dir&quot;;
dosCommand[1] = &quot;*.txt&quot;;
try{
      Process dosDirProcess = Runtime.getRuntime().exec(dosCommand);
}catch(IOException ex){
      System.err.println(&quot;Command failed with IO Exception.&quot;);
}
</PRE>

<H4><A NAME="ch14_ 10">
Waiting for Programs to Complete
</A></H4>

<P>In this example, the Windows notepad application is started. The application waits
until the user closes the notepad application and pops up a dialog box to acknowledge the fact.
</P>

<P><CENTER>
<a href="0593-0596.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0600-0604.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



