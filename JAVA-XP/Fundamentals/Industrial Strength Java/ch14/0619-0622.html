<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Interfacing C/C++ and Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0614-0618.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0623-0626.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-619"><P>Page 619</P></A>


<PRE>
&Acirc;*Java_NativeTest_testException2_stub(stack_item *_P_,struct execenv
&Acirc;*_EE_) {
       extern void NativeTest_testException2(void *);
       (void) NativeTest_testException2(_P_[0].p);
       return _P_;
}
</PRE>

<H3><A NAME="ch14_ 17">
The C Implementation of Java <BR>
Native Methods
</A></H3>

<P>The next step to integrating C/C++ to Java is the creation of
C functions that are called by the stub functions. The functions are identical to the functions defined in the C header
file produced by javah. Each C function defines as its first parameter a pointer to the
object that contains the Java method. This pointer is used to access the data contained in
the object. The object pointer is used in the same way as &quot;this.&quot; Because any object is
derived from the Object class, the actual data is not available by directly dereferencing the
pointer. A special C macro is used to access the contents of the structure representing the
class. The macro &quot;unhand&quot; is discussed in the section &quot;Accessing Object Data.&quot;
</P>

<P>This C file in listings 14.15a through 14.15f implements each of the native methods as
was described by the stubs file in listing 14.14.
</P>

<P>Listing 14.15a contains each of the simple functions that accept a single standard type
and increments and returns the value. As you can see, there is little differenece from the
usage of a normal C function. Only the second parameter is used. The object variable
nativeTest is not used in any of these functions.
</P>

<P>Listing 14.15a C Implementation of the nativeTest Class
</P>
<PRE>
# include &quot;NativeTest.h&quot;
// Native Atoms
long NativeTest_nativeInt(struct HNativeTest *nativeTest,long
&Acirc;nativeInt){
       return (++nativeInt);
}
unicode NativeTest_nativeChar(struct HNativeTest *nativeTest,unicode
&Acirc;nativeChar){
</PRE>
<PRE>
                                                                              continues
</PRE>

<A NAME="PAGENUM-620"><P>Page 620</P></A>



<P>Listing 14.15a Continued
</P>
<PRE>
       return(++nativeChar);
}
short NativeTest_nativeShort(struct HNativeTest *nativeTest,short
&Acirc;nativeShort){
       return(++nativeShort);
}
float NativeTest_nativeFloat(struct HNativeTest *nativeTest,float
&Acirc;nativeFloat){
       return(++nativeFloat);
}
double NativeTest_nativeDouble(struct HNativeTest *nativeTest,double
&Acirc;nativeDouble){
       return(++nativeDouble);
}
long NativeTest_nativeBoolean(struct HNativeTest *nativeTest,long
&Acirc;nativeBoolean){
       return(!nativeBoolean);
}
</PRE>

<P>Listing 14.15b is similar to 14.15c except arrays of standard types are passed into C
from Java. No processing is done on these arrays. The arrays are simply returned back to
the Java environment. Array usage is discused in more detail through listing 14.15.
</P>

<P>Listing 14.15b C Implementation of the nativeTest Class
</P>
<PRE>
// Native Arrays
HArrayOfInt* NativeTest_nativeIntArray(struct HNativeTest
&Acirc;*nativeTest,HArrayOfInt *nativeIntArray){
       return(nativeIntArray);
}
HArrayOfChar* NativeTest_nativeCharArray(struct HNativeTest
&Acirc;*nativeTest,HArrayOfChar *nativeCharArray){
       return(nativeCharArray);
}
HArrayOfShort* NativeTest_nativeShortArray(struct HNativeTest
&Acirc;*nativeTest,HArrayOfShort *nativeShortArray){
       return(nativeShortArray);
}
HArrayOfFloat* NativeTest_nativeFloatArray(struct HNativeTest
&Acirc;*nativeTest,HArrayOfFloat *nativeFloatArray){
       return(nativeFloatArray);
}
</PRE>

<A NAME="PAGENUM-621"><P>Page 621</P></A>


<PRE>
HArrayOfDouble* NativeTest_nativeDoubleArray(struct HNativeTest
&Acirc;*nativeTest,HArrayOfDouble *nativeDoubleArray){
       return(nativeDoubleArray);
}
HArrayOfInt* NativeTest_nativeBooleanArray(struct HNativeTest
&Acirc;*nativeTest,HArrayOfInt *nativeBooleanArray){
       return(nativeBooleanArray);
}
</PRE>

<P>The code in listing 14.15c show two functions. The first function,
nativeObject(), accepts as its second parameter an object of the TestObject class. The
object is returned back to the Java environment. The second C function,
nativeObjectArray(), takes an array of objects and returns them back to Java.
</P>

<P>Listing 14.15c C Implementation of the nativeTest Class
</P>
<PRE>
// Objects
struct HTestObject* NativeTest_nativeObject(struct HNativeTest
&Acirc;*nativeTest,struct HTestObject *anObject){
       return(anObject);
}
HArrayOfObject* NativeTest_nativeObjectArray(struct HNativeTest
&Acirc;*nativeTest,HArrayOfObject *anObjectArray){
       return(anObjectArray);
}
</PRE>

<P>The C function callJava(), described in listing 14.15d, does much more processing
than any of the functions described to this point. The function's purpose is to accomplish
the following (line numbers are included for clarity):
</P>

<UL>
<LI>     Define a pointer to a class (line 2).
<LI>     Define a pointer to an object of TestObject class (line 3).
<LI>     Declare array pointers of primitive types (lines 4 through 11).
<LI>     Declare a pointer to an array of String (line 12).
<LI>     Populate the class pointer testClass with a &quot;look up&quot; of the TestObject class
(line 15). The function FindClass() accomplishes this by passing in the current
context (obtained by calling EE()) and specifying the name of the class to be found.
Lines 16 through 21 validate whether the FindClass() was successful
<LI>     The statement in lines 23 through 36 calls to the constructor of the
TestObject class. Constructors are called with the execute_java_constructor() function.
</UL>

<A NAME="PAGENUM-622"><P>Page 622</P></A>



<UL>
<dl>          The execute_java_constructor() function has four required parameters. The first,
on line 24, is the current context derived by calling the
EE() function.</dl>
<dl>          The second required parameter is the name of the class from which this object is
to be derived.</dl>
<dl>          The third is the class pointer that was obtained on line 15.</dl>
<dl>          The fourth parameter in the execute_java_constructor() function is a text signature of the constructor. This signature is required by Java to look up the correct constructor for the object. Following the required arguments are the parameters that are to be passed to the constructor as defined by the signature defined by
the fourth parameter (line 27).</dl>
<LI>     Lines 37 through 39 are used to validate that an object of TestObject class
was created.
<LI>     Arrays are created next to be used in a function call (lines 42 through 50).
Arrays are allocated with the ArrayAlloc() function. The ArrayAlloc() takes a
constant that defines the type of primitive to be allocated, followed by the number of
entries to be allocated. In the example, five of each type are allocated.
<LI>     Next, arrays are filled with values. Arrays are accessed by dereferencing
the pointer and accessing the array index of the &quot;body&quot; member.
<LI>     Lines 76 through 87 call a member of the TestObject class with the arrays
you have created in this function. Like the execute_java_constructor() function,
the execute_java_dynamic_method() function has four required parameters.
</P>          The first on line 76 is the current context derived by calling the EE() function.
</P>          The second required parameter pointer to the object that has the method to
be called.
</P>          The third parameter is the name of the method to be executed.
</P>          The final required parameter in the execute_java_dynamic_method() function is
a text signature of the method. This signature is required by Java to look up
the correct method for the object. Following the required arguments are the
parameters to be passed to the constructor, as defined by the signature defined by the
fourth parameter (line 79).
</UL>

<P>Listing 14.15d C Implementation of nativeTest Class
</P>
<PRE>
1:void NativeTest_callJava(struct HNativeTest *nativeTest){
2:     ClassClass * testClass;
3:     struct HTestObject *testObject;
4:     ArrayOfInt *tBooleans;// Note: booleans are int!
</PRE>


<P><CENTER>
<a href="0614-0618.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0623-0626.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



