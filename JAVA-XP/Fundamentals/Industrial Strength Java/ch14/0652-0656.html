<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Interfacing C/C++ and Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0646-0651.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0657-0661.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-652"><P>Page 652</P></A>



<P>Listing 14.39g Continued
</P>
<PRE>
            // Look for \r echoed back from modem.
            // Replace it with a \n so display looks ok.
            int test = input.indexOf(`\r');
            if (test != -1){
                input = input.replace(`\r','\n');
            }
            inputWindow.appendText(input);
        }
    } //End of update()
</PRE>

<P>Listing 14.39h shows the final method, action(). The
action() method is the implementation of the Action interface, which is a specialized observer that accepts an index
that specifies that a token has been received from the serial port. This particular
implementation prints out status to the standard whenever common modem commands are received.
</P>

<P>Listing 14.39h Class NativeSerial: The action() Method
</P>
<PRE>
    // Implementation for Action Interface
    public void action(int ID){
        switch(ID){
            case 0: //OK
                System.out.println(&quot;Saw OK&quot;);
                break;
            case 1: //CONNECT
                System.out.println(&quot;Saw Connect&quot;);
                break;
            case 2: //NO CARRIER
                System.out.println(&quot;Saw CARRIER&quot;);
                break;
            case 3: //NO CARRIER
                System.out.println(&quot;Saw NO&quot;);
                break;
        }
    } //End of action()
    Label label1;
    Label label2;
    TextArea outputWindow;
    TextArea inputWindow;
    Button openPort;
    Button closePort;
    TextField portNumber;
    Label label3;
</PRE>



<A NAME="PAGENUM-653"><P>Page 653</P></A>


<PRE>
    private SerialDevice serial;
    private SerialPortMonitor monitor;
    private WaitForTokens toker;
}// End of class NativeSerial
</PRE>

<H4><A NAME="ch14_ 42">
SerialDevice Class
</A></H4>

<P>The SerialDevice class is the public interface to the SerialDevices package. It connects
the SerialPeer interface to the actual platform-specific native implementation.
</P>

<P>The full listing that starts with 14.40a is the main class of the SerialDevices package.
The class controls access to the serial port interface and the functions that are supported.
</P>

<P>Listing 14.40a Class SerialDevice: Class Constructor
</P>
<PRE>
package SerialDevices;
import SerialDevices.SerialPeer;
public class SerialDevice{
    private SerialPeer serialPeer;
    private long port;
    public SerialDevice(){
        //Determine the System type and get the correct peer
    }
</PRE>

<P>The most important method in this class is setSerialPeer(), which is used to set the
peer object to be used to access machine-specific functions.
</P>

<P>Listing 14.40b Class SerialDevice: setSerialPeer()
</P>
<PRE>
    public void setSerialPeer(SerialPeer peer){
        serialPeer = peer;
    }
</PRE>

<P>After the peer has been set, all of the functions in the SerialPeer interface can be
accessed. Nothing is done in listing 14.40c except call the peer method.
</P>

<P>Listing 14.40c Class SerialDevice: Serial Port Access Functions
</P>
<PRE>
    public boolean openSerialPort(int portID){
        port = serialPeer.openSerialPort(portID);
        return(port != 0);
</PRE>
<PRE>
                                                                                continues
</PRE>

<A NAME="PAGENUM-654"><P>Page 654</P></A>



<P>Listing 14.40c Continued
</P>
<PRE>
    }
public boolean closeSerialPort(){
        return(serialPeer.closeSerialPort(port));
    }
    public boolean setBaudRate(int baudRate){
        return(serialPeer.setBaudRate(port,baudRate));
    }
    public boolean setStopBits(int stopBits){
        return(serialPeer.setStopBits(port,stopBits));
    }
    public boolean setParity(int parity){
        return(serialPeer.setParity(port,parity));
    }
    public boolean setDataBits(int dataBits){
        return(serialPeer.setDataBits(port,dataBits));
    }
    boolean setWaitMask(long mask){
        return(serialPeer.setWaitMask(port,mask));
    }
    long commWait(){
        return(serialPeer.commWait(port));
    }
   /**
    * @param buffer Character buffer for results size must be &gt;=
        &Acirc;numberOfBytesToRead
    * @param numberOfBytesToRead Number of bytes to attempt reading.
    * @returns bytes read from port.
    */
    public int portIn(byte [] buffer, int numberOfBytesToRead){
        return(serialPeer.portIn(port,buffer,numberOfBytesToRead));
    }
   /**
    * @param buffer Character buffer to Send.
    * Size must be &gt;= numberOfBytesToRead
    * @param numberOfBytesToWrite Number of bytes to attempt sending.
    * @returns bytes written to port.
    */
    public int portOut(byte [] buffer, int numberOfBytesToWrite){
        return(serialPeer.portOut(port,buffer,numberOfBytesToWrite));
    }
</PRE>

<P>The last method in the SerialDevice class is write(). The
write() method is slightly different from the others because it converts a Java String to an array of bytes suitable
for output to
</P>
<A NAME="PAGENUM-655"><P>Page 655</P></A>


<P>the serial device. After the byte array has been created, the
portOut() is called to access the serial peer device.
</P>

<P>Listing 14.40d Class SerialDevice: The write() Method
</P>
<PRE>
   /**
    * @param buffer String to Send.
    * @returns bytes writen to port.
    */
    public int write(String buffer){
        int numberOfBytesToWrite = buffer.length();
        byte [] byteBuffer =  new byte[numberOfBytesToWrite];
        buffer.getBytes(0, numberOfBytesToWrite, byteBuffer, 0);
        System.out.println(new String(byteBuffer,0));
        return(serialPeer.portOut(port,byteBuffer,numberOfBytesToWrite));
    }
}
</PRE>

<H4><A NAME="ch14_ 43">
SerialPeer Interface
</A></H4>

<P>The SerialPeer interface is used by SerialDevice to abstract calls to
predetermined platform-specific implementations of the serial device. Note in the listing that it
contains constants that are used later in the C code to abstract the mask bits from the
platform-specific mask (see listing 14.41a).
</P>

<P>Listing 14.41a Interface SerialPeer: final Constants
</P>
<PRE>
package SerialDevices;
public interface SerialPeer{
    // Wait mask flags. Logical or these flags to build wait mask.
    final long BREAK   = 1;  // A break was detected on input.
    final long CTS     = 2;  // The CTS (clear-to-send) signal changed
                             //state.
    final long DSR     = 4;  // The DSR (data-set-ready) signal changed
                             //state.
    final long ERR     = 8;  // A line-status error occurred. Line-
                             //status
                             // errors are CE_FRAME, CE_OVERRUN, and
                             // CE_RXPARITY.
    final long RING    = 16; // A ring indicator was detected.
    final long RLSD    = 32; // The RLSD (receive-line-signal-detect)
                             //signal
</PRE>
<PRE>
                                                                              continues
</PRE>

<A NAME="PAGENUM-656"><P>Page 656</P></A>



<P>Listing 14.41a Continued
</P>
<PRE>
                             // changed state.
    final long RXCHAR  = 64; // A character was received and placed in
                             // the input buffer.
    final long RXFLAG  = 128;// The event character was received and
                             // placed in the input buffer.
                             // The event character is specified in the
                             // device's DCB structure, which is
                             //  applied to a serial port by using
                             // the SetCommState function.
    final long TXEMPTY = 256;// The last character in the output buffer
                             // was sent.
</PRE>

<P>The second half of the SerialPeer class has the definitions for serial device access.
When each of these methods is implemented by a client class such as the
Win32sSerialPeer class, another class can access the functions to control a serial port.
</P>

<P>Listing 14.41b Interface SerialPeer: Serial Port Methods
</P>
<PRE>
    public long openSerialPort(int portID);
    public boolean closeSerialPort(long port);
    public boolean setBaudRate(long port,int baudRate);
    public boolean setStopBits(long port,int stopBits);
    public boolean setParity(long port,int parity);
    public boolean setDataBits(long port,int dataBits);
    public boolean setWaitMask(long port,long mask);
    public long commWait(long port);
        public int portIn(long port,byte [] buffer, int
                 &Acirc;numberOfBytesToRead);
        public int portOut(long port,byte [] buffer,int
                &Acirc;numberOfBytesToWrite);
}
</PRE>

<H4><A NAME="ch14_ 44">
The Win32sSerialPeer Class
</A></H4>

<P>The Win32sSerialPeer class is the Win32s platform-specific implementation for
the SerialPeer class.
</P>

<P>An important aspect of this class is that SerialPeer is solely implemented by
native functions. Having all of the SerialPeer implementations as native may not be the case
for all platforms. For instance, portIn() and portOut() may need to perform special
operations
</P>

<P><CENTER>
<a href="0646-0651.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0657-0661.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



