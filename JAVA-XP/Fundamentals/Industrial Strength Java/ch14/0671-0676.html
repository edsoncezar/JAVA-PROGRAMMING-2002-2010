<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Interfacing C/C++ and Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0667-0670.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="..\ch15\0677-0680.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-671"><P>Page 671</P></A>



<H4><A NAME="ch14_ 51">
Reading Data from an Open Serial Port
</A></H4>

<P>The portIn() function reads data from an open serial port, as demonstrated in listing
14.52. It accepts two arguments: one is an array of bytes to use as an input buffer, and the other
is a count of the maximum number of bytes to read. The function returns the actual
number of bytes read from the port.
</P>

<P>Listing 14.52 The C Implementation of portIn()
</P>
<PRE>
long SerialDevices_Win32sSerialPeer_portIn(struct HWin32sSerialPeer
 *nativeSerial, int64_t aPort,HArrayOfByte *buffer,long bytesToRead){
 int bytesRead;
    BOOL result;
    COMSTAT    ComStat ;
    DWORD      dwErrorFlags;
    char *data;
    int length;
    data = unhand(buffer)-&gt;body;
    // only try to read number of bytes in queue.
    ClearCommError( aPort, &amp;dwErrorFlags, &amp;ComStat ) ;
    length = min( (DWORD)bytesToRead, ComStat.cbInQue ) ;
    if (length == 0)return(0);
    result     = ReadFile( aPort,       // handle of file to read.
                            data,       // address of buffer that
                                        // receives data. number
                            bytesToRead,// of bytes to read. address
                            &amp;bytesRead, // of number of bytes read.
                                        // address of structure for
                            NULL);      // data.
     return(bytesRead);
}
</PRE>

<H4><A NAME="ch14_ 52">
Writing Data to the Serial Port
</A></H4>

<P>The portOut() function writes data to an open serial port. It accepts an array of bytes
to write and a count of the number of bytes to write. The function returns the actual
number of bytes written to the port.
</P>

<A NAME="PAGENUM-672"><P>Page 672</P></A>


<P>
Listing 14.53 The C Implemetation for portOut()</P>
</P>
<PRE>
long SerialDevices_Win32sSerialPeer_portOut(struct HWin32sSerialPeer
 *nativeSerial, int64_t aPort,HArrayOfByte *buffer,long bytesToWrite){
    DWORD bytesWritten;
    BOOL result;
    char charBuffer[2];
    //int i;
    char *data;
    data = unhand(buffer)-&gt;body;
    result = WriteFile( aPort,        // handle to file to write to
                        data,         // pointer to data to write to
                                      // file number of bytes to
                        bytesToWrite, // write pointer to number
                        &amp;bytesWritten,// of bytes written pointer to
                                      // structure needed for
                        NULL);        // overlapped I/O

    return(bytesWritten);
}
</PRE>

<H4><A NAME="ch14_ 53">
Serial Port Defaults
</A></H4>

<P>The setDefaults() function is used to set initial parameters of a serial port device. It has  <BR>
no equivalent native Java method&#151;the closest is a utility function that initially defines <BR>
the serial port and is only callable from the C library.
</P>

<P>The defaults shown in listing 14.54 are used to put the serial device into a known state.
It is possible that a program that used the serial port could have left these settings in a
state that is impossible to use. By using default values as a starting point, further settings
will work as expected.
</P>

<P>Listing 14.54 The C Implementation for setDefaults()
</P>
<PRE>
void setDefaults(HANDLE aPort){
    DCB portState;
    portState.DCBlength = sizeof( DCB ) ;
    GetCommState(aPort,&amp;portState);
    portState.DCBlength=    28;
    portState.BaudRate=     14400;
    portState.fBinary=     1;
    portState.fParity=     1;
    portState.fOutxCtsFlow=  0;
</PRE>


<A NAME="PAGENUM-673"><P>Page 673</P></A>


<PRE>
    portState.fOutxDsrFlow=  1;
    portState.fDtrControl=   2;
    portState.fDsrSensitivity=    0;
    portState.fTXContinueOnXoff=  0;
    portState.fOutX=         0;
    portState.fInX=          0;
    portState.fErrorChar=    0;
    portState.fNull=         0;
    portState.fRtsControl=   1;
    portState.fAbortOnError= 0;
    //portState.fDummy2=     0;
    //portState.wReserved=   0;
    portState.XonLim=        100;
    portState.XoffLim=       100;
    portState.ByteSize=   8;  // `.'
    portState.Parity=     0;  // `\x00'
    portState.StopBits=   0;  //  `\x00'
    portState.XonChar=    17; // `.'
    portState.XoffChar=   19; // `.'
    portState.ErrorChar=   0; // `\x00'
    portState.EofChar=     0; // `\x00'
    portState.EvtChar=      0;// `\x00'
    //portState.wReserved1=  0;
    SetCommState(aPort,&amp;portState);


}
</PRE>

<H4><A NAME="ch14_ 54">
Changing Serial Port Settings
</A></H4>

<P>The functions in table 14.6 are used to set specific port options.
</P>

<P>Table 14.6<BR>
Serial Port Configuration Functions
</P>
<TABLE>

<TR><TD>
Function
</TD><TD>
Purpose
</TD></TR><TR><TD>
setBaudRate()
</TD><TD>
Set a specific baud speed.
</TD></TR><TR><TD>
setStopBits()
</TD><TD>
Sets the number of stop bits.
</TD></TR><TR><TD>
setParity()
</TD><TD>
Sets the parity checking style.
</TD></TR><TR><TD>
setDataBits()
</TD><TD>
Sets the width of the data word.
</TD></TR></TABLE>

<P>These four functions are the most popular settings that a programmer sets. They are
also the most common settings configurable for a wide range of computer hardware.
Listings 14.55 show the C implementations for these functions. The first function is
setBaudRate(), which sets the specific baud at which the serial device will communicate.
</P>

<A NAME="PAGENUM-674"><P>Page 674</P></A>


<P>Listing 14.5 The C Implementation of setBaudRate()
</P>

<PRE>
long SerialDevices_Win32sSerialPeer_setBaudRate(struct HWin32sSerialPeer
&Acirc;*nativeSerial, int64_t aPort,long baudRate){
    DCB portState;
    if(GetCommState(aPort,&amp;portState)){
        if(portState.BaudRate != (DWORD)baudRate){
            portState.BaudRate = (DWORD)baudRate;
            return(SetCommState(aPort,&amp;portState));
        }else{
            return(TRUE);
        }
    }else{
        return(FALSE);
    }
}
</PRE>

<P>The setStopBits()function sets the number of stop bits.
Stop bits are used to frame serial data and can be set to 1, 2, or 3, corresponding to 1, 1.5, and 2 stop bits, respectively.
</P>

<P>Listing 14.56 The C Implementation of setStopBits()
</P>
<PRE>
long SerialDevices_Win32sSerialPeer_setStopBits(struct HWin32sSerialPeer
&Acirc;*nativeSerial, int64_t aPort,long stopBits){
    DCB portState;
    if(GetCommState(aPort,&amp;portState)){
        if(portState.StopBits != (BYTE)stopBits){
            portState.StopBits = (BYTE)stopBits;
            return(SetCommState(aPort,&amp;portState));
        }else{
            return(TRUE);
        }
    }else{
        return(FALSE);
    }
}
</PRE>

<P>The function setParity() controls the parity checking style.
Parity checking is the process of validating that the data transferred is correct. The default parity is 0 (none). Other
parity values are 1 for odd parity and 2 for even parity.
</P>

<A NAME="PAGENUM-675"><P>Page 675</P></A>



<P>Listing 14.57 The C Implementation of setParity()
</P>
<PRE>
long SerialDevices_Win32sSerialPeer_setParity(struct HWin32sSerialPeer
&Acirc;*nativeSerial, int64_t aPort,long parity){
    DCB portState;
    if(GetCommState(aPort,&amp;portState)){
        if(portState.Parity != (BYTE)parity){
            portState.Parity = (BYTE)parity;
            return(SetCommState(aPort,&amp;portState));
        }else{
            return(TRUE);
        }
    }else{
        return(FALSE);
    }
}
</PRE>

<P>Listing 14.58 shows the C implementation for the
setDataBits() function. SetDataBits() controls the width of the data word. The size selected is usually 7 or 8 bits. The default
is 8 data bits. The data width can be set from 4 to 8 bits.
</P>

<P>Listing 14.58 The C Implementation of setDataBits()
</P>
<PRE>
long SerialDevices_Win32sSerialPeer_setDataBits(struct HWin32sSerialPeer
&Acirc;*nativeSerial, int64_t aPort,long dataBits){
    DCB portState;
    if(GetCommState(aPort,&amp;portState)){
        if(portState.ByteSize != (BYTE)dataBits){
            portState.ByteSize = (BYTE)dataBits;
            return(SetCommState(aPort,&amp;portState));
        }else{
            return(TRUE);
        }
    }else{
        return(FALSE);
    }
}
</PRE>

<A NAME="PAGENUM-676"><P>Page 676</P></A>



<H3><A NAME="ch14_ 55">
Summary
</A></H3>

<P>The native code interface is useful for accessing legacy code, system service
functions, and hardware. With the Runtime.getRuntime().exec() method and the Process class that
it returns, Java applications can run and control executable applications with
effortless programming. Also, another compiler is not required.
</P>

<P>This chapter covered the native interface environment and used it to access serial
ports. The peer method described can be used as a model for creating Java and C code that
is portable to other operating systems.
</P>

<P>Use native code wisely. Be careful to avoid corrupting the Java environment by
passing bad objects or string buffers to native functions. And retain as much Java code as possible.
</P>
<BR>
<P><CENTER>
<a href="0667-0670.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="..\ch15\0677-0680.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



