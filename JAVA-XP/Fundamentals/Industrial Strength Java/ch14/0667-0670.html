<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Interfacing C/C++ and Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0662-0666.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0671-0676.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-667"><P>Page 667</P></A>


<H4><A NAME="ch14_ 48">
Opening the Serial Port
</A></H4>

<P>The openSerialPort() function opens a specified serial port by number. The
function returns a handle to the port that is to be used by the Java application when accessing
the same serial port.
</P>

<P>Listing 14.48 The openSerialPort Method
</P>
<PRE>
int64_t SerialDevices_Win32sSerialPeer_openSerialPort(struct
&Acirc;HWin32sSerialPeer *nativeSerial,long port){
    char* portName;
    char test[255];
    int bytesWritten;
    HANDLE aPort;
    COMMTIMEOUTS  CommTimeOuts ;

    // convert port number to port name
    switch (port){
    case 1: portName = &quot;COM1&quot;;break;
    case 2: portName = &quot;COM2&quot;;break;
    case 3: portName = &quot;COM3&quot;;break;
    case 4: portName = &quot;COM4&quot;;break;
    case 5: portName = &quot;COM5&quot;;break;
    case 6: portName = &quot;COM6&quot;;break;
    case 7: portName = &quot;COM7&quot;;break;
    case 8: portName = &quot;COM8&quot;;break;
    default:portName = &quot;COM1&quot;;break;
    }
    aPort = CreateFile(portName,GENERIC_READ|GENERIC_WRITE,0,NULL
                        ,OPEN_EXISTING
                        ,FILE_ATTRIBUTE_NORMAL/* |
 &Acirc;FILE_FLAG_OVERLAPPED*/,0);
    if (aPort == INVALID_HANDLE_VALUE){
        return(0);
    }else{
        EscapeCommFunction(aPort, CLRDTR ) ;
        EscapeCommFunction(aPort, SETDTR ) ;

      // get any early notifications
      SetCommMask(aPort, EV_RXCHAR ) ;
      // setup device buffers
      SetupComm(aPort, 4096, 4096 ) ;
      // purge any information in the buffer
      PurgeComm(aPort, PURGE_TXABORT | PURGE_RXABORT |
</PRE>
<PRE>
                                                                          continues
</PRE>

<A NAME="PAGENUM-668"><P>Page 668</P></A>



<P>Listing 14.48 Continued
</P>
<PRE>

                                      PURGE_TXCLEAR | PURGE_RXCLEAR ) ;
      CommTimeOuts.ReadIntervalTimeout = 0xFFFFFFFF ;
      CommTimeOuts.ReadTotalTimeoutMultiplier = 0 ;
      CommTimeOuts.ReadTotalTimeoutConstant = 1000 ;
      CommTimeOuts.WriteTotalTimeoutMultiplier = 0 ;
      CommTimeOuts.WriteTotalTimeoutConstant = 1000 ;
      SetCommTimeouts(aPort, &amp;CommTimeOuts ) ;
      setDefaults(aPort);

        EscapeCommFunction(aPort, SETBREAK ) ;
        ClearCommBreak(aPort);
        return((int64_t)aPort);
    }
</PRE>

<H4><A NAME="ch14_ 49">
Isolating the C Wait Mask from the Java <BR>
Wait Mask
</A></H4>

<P>Wait masks are used by hardware devices to specify interest in specific events
generated by a device. For serial ports on the PC, for instance, the mask is usually set to
RXCHAR, which translates to telling the serial port to notify the program whenever a character
was received and placed in the serial port's input buffer.
</P>

<P>Another common mask is RING, which is used to notify a program that the modem
is being called. Masks are used to keep overhead low by enlisting hardware to wait
for events rather than having a program always checking to see whether an event has
occurred. A program normally will start another thread of execution that will wait for
the event while the main program continues in another thread.
</P>

<P>The wait mask of different types of hardware are different, unfortunately. To combat
this problem, the SerialDevice package uses a transposition table that maps
SerialDevice masks to the specific hardware mask.
</P>

<P>The constants in listing 14.49 are used to isolate the actual bit positions that are used
by the native system. By using these constants, a developer only needs to modify
the setWaitMask() and commWait() functions in this module for the signal constants
supported by a particular operating system and hardware configuration.
</P>

<A NAME="PAGENUM-669"><P>Page 669</P></A>



<P>Listing 14.46.49 Java Signal Mask Constants
</P>
<PRE>

    final long JAVA_BREAK   = 1;  // A break was detected on input.
    final long JAVA_CTS     = 2;  // The CTS (clear-to-send) signal
                                  // changed state.
    final long JAVA_DSR     = 4;  // The DSR (data-set-ready) signal
                                  //changed state. A line-status
    final long JAVA_ERR     = 8;  // error occurred.
                                  // Line-status errors are CE_FRAME,
                                  // CE_OVERRUN, and CE_RXPARITY.
    final long JAVA_RING    = 16; // A ring indicator was detected.
    final long JAVA_RLSD    = 32; // The RLSD (receive-line-signal-
                                  // detect) signal changed state.
    final long JAVA_RXCHAR  = 64; // A character was received and placed
                                  // in the input buffer.
    final long JAVA_RXFLAG  = 128;// The event character was received
                                  // and placed in the input buffer.
                                  // The event character is specified
                                  // in the device's DCB structure,
                                  // which is applied to a serial
                                  // port by using the SetCommState
                                  // function. The last character
    final long JAVA_TXEMPTY = 256;// in the output buffer was sent.
</PRE>

<P>The C implementation of the function setWaitMask() sets the wait mask (see
listing 14.50). The mask bits are converted from the Java mask to the Windows mask.
This function looks for a Java mask in the desired mask. If a match is found, the PC mask
is added to the serial port mask. When the mask is complete, the Windows
SetCommMask() function is called.
</P>

<P>Listing 14.50 The C Implementation of setWaitMask()
</P>
<PRE>
long SerialDevices_Win32sSerialPeer_setWaitMask(struct HWin32sSerialPeer
 *nativeSerial,
&Acirc;int64_t aPort,int64_t mask){
    //Convert Java flags to Microsoft flags
    long windowsMask = 0;
    if (mask &amp; JAVA_BREAK   == JAVA_BREAK)   windowsMask |= EV_BREAK;
    if (mask &amp; JAVA_CTS     == JAVA_CTS)     windowsMask |= EV_CTS;
    if (mask &amp; JAVA_DSR     == JAVA_DSR)     windowsMask |= EV_DSR;
    if (mask &amp; JAVA_ERR     == JAVA_ERR)     windowsMask |= EV_ERR;
    if (mask &amp; JAVA_RING    == JAVA_RING)    windowsMask |= EV_RING;
    if (mask &amp; JAVA_RLSD    == JAVA_RLSD)    windowsMask |= EV_RLSD;
</PRE>
<PRE>
                                                                          continues
</PRE>

<A NAME="PAGENUM-670"><P>Page 670</P></A>



<P>Listing 14.50 Continued
</P>
<PRE>
    if (mask &amp; JAVA_RXCHAR  == JAVA_RXCHAR)  windowsMask |= EV_RXCHAR;
    if (mask &amp; JAVA_RXFLAG  == JAVA_RXFLAG)  windowsMask |= EV_RXFLAG;
    if (mask &amp; JAVA_TXEMPTY == JAVA_TXEMPTY) windowsMask |= EV_TXEMPTY;

    return(SetCommMask(aPort,windowsMask));
}
</PRE>

<H4><A NAME="ch14_ 50">
Waiting for Serial Port Events
</A></H4>

<P>The function commWait() waits for an event specified by SetCommMask(). When the
wait returns, the resulting mask contains the events that caused the event. This function
then converts the PC event to the Java events and adds them to the total mask.
</P>

<P>It is important to note that the Windows WaitCommEvent() function blocks execution
until an event occurs or the wait times out. Any thread that calls the function also ceases
to execute. Java applications calling commWait() should call this function from a
secondary thread so that the program will continue to run while it waits on the serial port. Refer
to listing 14.51.
</P>

<P>Listing 14.51 The C Implementation of commWait()
</P>
<PRE>
int64_t SerialDevices_Win32sSerialPeer_commWait(struct HWin32sSerialPeer
 *nativeSerial,int64_t port){
    unsigned long mask;
    BOOL result = WaitCommEvent(port,&amp;mask,NULL);
    // Convert windows event to Java event
    long javaMask = 0;
    if (mask &amp; EV_BREAK)   javaMask |= JAVA_BREAK;
    if (mask &amp; EV_CTS)     javaMask |= JAVA_CTS;
    if (mask &amp; EV_DSR)     javaMask |= JAVA_DSR;
    if (mask &amp; EV_ERR)     javaMask |= JAVA_ERR;
    if (mask &amp; EV_RING)    javaMask |= JAVA_RING;
    if (mask &amp; EV_RLSD)    javaMask |= JAVA_RLSD;
    if (mask &amp; EV_RXCHAR)  javaMask |= JAVA_RXCHAR;
    if (mask &amp; EV_RXFLAG)  javaMask |= JAVA_RXFLAG;
    if (mask &amp; EV_TXEMPTY) javaMask |= JAVA_TXEMPTY;
    return (javaMask);
}
</PRE>

<P><CENTER>
<a href="0662-0666.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0671-0676.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



