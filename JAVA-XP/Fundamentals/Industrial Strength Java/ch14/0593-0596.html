<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Interfacing C/C++ and Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="..\ch13\0591-0592.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0597-0599.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-593"><P>Page 593</P></A>


<H3><A NAME="ch14_ 1">
Chapter 14
</A></H3>

<H2>

Interfacing C/C++ <BR>
and Java

</H2>

<P>Native methods are used to link C code to Java. C code is sometimes necessary
because cross-platform environments may offer features that are unavailable to standard
Java programs. C code is also necessary to integrate Java with legacy code. Java is designed
to access native machines with the native interface and library. This chapter covers the
basics of interfacing between C or C++ and the Java environment.
</P>

<P>Also covered in this chapter is an alternative way to link C and Java code, achieved
by using native processes and the exec() method. Examples provided in this chapter
show how a Java program can run and control system programs and utilities.
</P>

<P>This chapter also discusses how to make native code easy to port to another
environment. The method described is similar to the peer interfacing methods used by the Java AWT
to isolate platform specific code.
</P>

<H3><A NAME="ch14_ 2">
Native Code Necessities
</A></H3>

<P>Although Java is generally a very capable language, it is sometimes necessary to
access the native environment. Here is a quick reference list to help you identify the
most common reasons:
</P>

<A NAME="PAGENUM-594"><P>Page 594</P></A>



<UL>
<LI>     Hardware access and control
<LI>     Use of commercial software and system services
<LI>     Reuse of legacy software that has not or cannot be ported to Java
<LI>     Augmenting C programs with a Java GUI
<LI>     Using native code to perform time-critical tasks
</UL>

<P>All these are perfectly legitimate reasons for interfacing with the native environment.
They are not, however, reasons to abandon writing pure Java applications. The following
list provides some reasons why you should not use the
native methods:
</P>

<UL>
<LI>     Applications are not guaranteed portable to other Java VM environments.
<LI>     Native code cannot be used by applets.
<LI>     Native code must be maintained by programmers who understand the C or
C++ language.
<LI>     Native code is not secure.
<LI>     Native code is not pointer-safe.
<LI>     Proficiency in more than one programming language must be maintained.
<LI>     Versions of native code for multiple platforms are hard to maintain.
<LI>     Native access to system services and commercial libraries must be verified
every time a new release becomes available.
</UL>

<H4><A NAME="ch14_ 3">
Combating Java Limitations with Native Code
</A></H4>

<P>Because it is cross platform, Java is limited to what is generic to all machines.
Specific hardware and system services are not included so as many machines as possible can
run identical Java programs. Unfortunately cross-platform capability is a limitation for
many programs that require access to hardware, system services, or old code. Java runs
programs within the Java Virtual Machine.
</P>

<P>The Virtual Machine is a simulation of a computer's CPU and memory. The Java VM
does not have access to hardware or system services. The only way to gain access to
hardware and system services is to use the native method API. The native method API is used
to bridge the gap between Java and machine-specific
libraries. This limits machine-specific information to classes other than the Java VM. Because it only needs to implement
the native interface API, the Java VM is much more portable. The native method API also is
a gateway for developers to write software that uses legacy software or to access
machine-specific software or services.
</P>
<A NAME="PAGENUM-595"><P>Page 595</P></A>



<H4><A NAME="ch14_ 4">
Taking Advantage of System Services and <BR>
Commercial C Libraries
</A></H4>

<P>Thousands of commercial libraries have been written for the C language. Every
platform includes them; whether you use Windows 95, Macintosh, or Unix, a wealth of
standard libraries are available. If you already depend on such libraries, using the Java
native interface is required for applications that have no Java equivalent.
</P>

<H4><A NAME="ch14_ 5">
Legacy Software
</A></H4>

<P>Legacy software is any software that is currently in use and must be maintained.
Legacy software is characterized as business-specific code that has a long life span
(sometimes many years). Because of the advanced age of legacy software, it is rare that it is still
fully understood by the company's current programming staff. If you or your company
has invested in legacy software and you are migrating to a completely Java application, it
may be wise to reuse as much of this code as possible in early versions. A rewrite of all
legacy software to Java may not fit the schedule or budget. In some applications where the
code is moving from C or C++, Java may only be used for the user interface, whereas
native legacy code is used for all other processing.
</P>

<P>A legacy application for customer order entry, for example, may have been written for <BR>
OS/2 machines, but the company is moving to Windows 95 machines in the near
future. The company determines that the new software should be able to run on the old
OS/2 machines and new Windows 95 platforms that will slowly replace OS/2
hardware. Unfortunately, the new Windows 95 machines will begin to arrive in the next few
months. The original software initially took over two years to develop and has had small
changes made to it over the past year. Redesigning and rewriting the system is seen as
impossible. The only machine-specific code is associated with the user interface. By writing Java
code utilizing the AWT and integrating non platform-specific code via the native method
API, the project can be completed before the required deadline.
</P>

<P>It should be noted that such combinations of Java and legacy code are difficult to
maintain. The staff that supports the application will need to stay proficient in the
older technology, as well as Java. Any application migrated to be 100 percent Java will be
much easier to maintain. In addition, the security and safety features inherent in Java will
cover the entire program instead of just part of it. Conversion to 100 percent Java will
eliminate many of the memory problems in C and C++. Another benefit, especially if you
are moving from C++, is the simplification of programs. Java has far fewer language
features than C++.
</P>

<A NAME="PAGENUM-596"><P>Page 596</P></A>


<P> A simpler language such as Java can reduce the cost of legacy code
maintenance because programmers will be able to understand the code more quickly and be
able to make changes sooner.
</P>

<H4><A NAME="ch14_ 6">
Enhancing C and C++ Code with a Java GUI
</A></H4>

<P>Existing C and C++ applications can take advantage of the Java environment by
calling Java methods. This can be accomplished by first creating a Java application that calls
the main routine of a C/C++ application. The C/C++ program could then instantiate
Java objects and call their public functions.
</P>

<H4><A NAME="ch14_ 7">
Accessing C and C++ for Speed Reasons
</A></H4>

<P>Java becomes more efficient and faster as new techniques for optimization mature.
Now there are improved Java VMs, JIT compilers, and compilers that create 100
percent-native executables. There may still be times when all these improvements are still not as fast
as native executables developed in machine language or produced by C
compilers. Due to the inherent safety and portability of Java, like array bounds checking, Java may
cause some tasks to execute more slowly than the same code compiled in C or C++.
Speed degradation comes in many forms. The following list demonstrates a few forms that
can cause slow execution.
</P>

<UL>
<LI>     Standard Java VM implementations are interpreted.
Interpretation means that twice the processing power is required. Java VM instructions must be read and
converted to instructions for the local CPU.
<LI>     The Java
Just In Time compiler (JIT) may not be as efficient as a native
program compiled with optimization.
<LI>     The computer platform may have more than one CPU. Java
VM and JIT may be written to work with only one CPU.
<LI>     Garbage
collection may occur too often or at critical times where speed is
paramount.
<LI>     Standard Java
API packages may not be efficiently written.
<LI>     Java API packages may not access environment-specific libraries that are
optimally efficient. They may be either 100 percent Java or only minimally access the
local environment.
<LI>     Java validates every array access to validate that the array is accessed within
its bounds. Through optimization, compilers and JIT compilers reduce the number
of checks, but optimizations do not eliminate all checks.
</UL>

<P><CENTER>
<a href="..\ch13\0591-0592.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0597-0599.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



