<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Interfacing C/C++ and Java:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0619-0622.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0627-0629.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-623"><P>Page 623</P></A>




<PRE>

5:     ArrayOfByte *tBytes;

6:     ArrayOfShort *tShorts;

7:     ArrayOfInt  *tInts;

8:     ArrayOfLong *tLongs;

9:     ArrayOfFloat *tFloats;

10:     ArrayOfDouble *tDoubles;

11:     ArrayOfChar *tChars;

12:     ArrayOfObject *tStrings;

13:     int i;

14:     printf(&quot;Locate the TestObject class,\n&quot;);

15:    testClass = FindClass(EE(),&quot;TestObject&quot;,TRUE);

16:    if (testClass != 0){

17:          printf(&quot;Call TestObject static method.\n&quot;);

18:    execute_java_static_method(EE(),testClass,&quot;testStatic&quot;,&quot;()V&quot;);

19:     }else{

20:          printf(&quot;failed to find TestObject class.\n&quot;);

21:     }

22:     printf(&quot;Create a test object\n&quot;);

23:     testObject = (struct HTestObject *)

24:                    execute_java_constructor(EE(),

25:                                             &quot;TestObject&quot;,

26:                                             testClass,

27:                                             &quot;(ZBSIJFDCLjava/lang/
                                                &Acirc;String;)&quot;,

28:                                             TRUE,

29:                                             1,

30:                                             (char)'A',

31:                                             1L,

32:                                             (byte)1,

33:                                             (float)1.0,

34:                                             (short)1,

35:                                             (double)1.0,

36:     makeJavaString(&quot;One&quot;,strlen(&quot;One&quot;)));

37:     if (testObject == 0){

38:          printf(&quot;failed to create TestObject object.\n&quot;);

39:     }

40:

41:     printf(&quot;Create test arrays.\n&quot;);

42:     tBooleans = (ArrayOfInt*)ArrayAlloc(T_BOOLEAN,5);

43:     tBytes = (ArrayOfByte*)ArrayAlloc(T_BYTE,5);

44:     tShorts = (ArrayOfShort*)ArrayAlloc(T_SHORT,5);

45:     tInts = (ArrayOfInt*)ArrayAlloc(T_INT,5);

46:     tLongs = (ArrayOfLong*)ArrayAlloc(T_LONG,5);

47:     tFloats = (ArrayOfFloat*)ArrayAlloc(T_FLOAT,5);

48:     tDoubles = (ArrayOfDouble*)ArrayAlloc(T_DOUBLE,5);

49:     tChars = (ArrayOfChar*)ArrayAlloc(T_CHAR,5);

</PRE>


<PRE>
continues
</PRE>




<A NAME="PAGENUM-624"><P>Page 624</P></A>







<P>Listing 14.15d Continued

</P>


<PRE>

50:    tStrings =(ArrayOfObject *)ArrayAlloc(T_CLASS,5);

51:     printf(&quot;Initialize arrays to 1.\n&quot;);

52:     for(i=0;i&lt;5;i++){

53:          printf(&quot;step =%d.\n&quot;,i);

54:          tBooleans-&gt;body[i] = (long)TRUE;

55:          printf(&quot;made bool\n&quot;);

56:          tBytes-&gt;body[i] = 1;

57:               printf(&quot;made bytes\n&quot;);

58:          tShorts-&gt;body[i] = 1;

59:          printf(&quot;made body\n&quot;);

60:          tInts-&gt;body[i] = 1;

61:          printf(&quot;made int\n&quot;);

62:          tLongs-&gt;body[i] = 1;

63:          printf(&quot;made long\n&quot;);

64:          tFloats-&gt;body[i] = (float)1.0;

65:          printf(&quot;made float\n&quot;);

66:          tDoubles-&gt;body[i] = 1.0;

67:          printf(&quot;made double\n&quot;);

68:          tChars-&gt;body[i] = `1';

69:          printf(&quot;making string\n&quot;);

70:          tStrings-&gt;body[i] =

                           &Acirc;(HObject*)makeJavaString(&quot;One&quot;,strlen(&quot;One&quot;)+1);

71:          if (tStrings-&gt;body[i] == 0){

72:               printf(&quot;ERROR making string\n&quot;);

73:          }

74:     }// end for

75:     printf(&quot;Pass all arrays to Java method.\n&quot;);

76:     execute_java_dynamic_method(EE(),

77:                                (struct Hjava_lang_Object

                                                                            &Acirc;*)testObject,

78:                                &quot;testArrays&quot;,

79:                                &quot;([Z[B[S[I[J[F[D[C[Ljava/lang/

                                                                            &Acirc;String;)V&quot;,

80:                                tBooleans,

81:                                tBytes,

82:                                tShorts,

83:                                tInts,

84:                                tLongs,

85:                                tFloats,

86:                                tDoubles,

87:                                tChars,

88:                                tStrings);

89:}// end of function callJava()

</PRE>




<A NAME="PAGENUM-625"><P>Page 625</P></A>







<P>The next method implemented as a C function is doExceptions(), shown in listing

14.15e. This function throws IOException or ArithmeticException, depending on the type

of exception that is requested via the type parameter. The function

SignalError accomplishes the mechanics of setting up the throw back to Java. Note that the throw does not

happen immediately. The throw will not occur until a function is exited. If there is any code

after the SignalError function, the code will be executed.

</P>



<P>Listing 14.15e C Implementation of the nativeTest Class

</P>


<PRE>

void NativeTest_doExceptions(struct HNativeTest *nativeTest,long type){

     switch (type){

     case 1:

          SignalError(EE(),&quot;java/io/IOException&quot;,&quot;test

                    &Acirc;error=IOException&quot;);

          break;

     case 2:

          SignalError(EE(),&quot;java/lang/ArithmeticException&quot;,&quot;test

                    &Acirc;error=ArithmeticException&quot;);

          break;

     }

     return;

}

</PRE>




<P>The function in listing 14.15f also throws an exception, except this function first

accesses the current object to set a field in the object. The purpose of such behavior is to show

that information about an exception can be returned back to the

object via the object field, which is required in cases where the standard exceptions are inadequate, and a

user-defined exception would be preferred. Because user-defined exceptions cannot be

created and thrown from native code using SignalError(), the additional information must

be passed via another method.

</P>



<P>Listing 14.15f C Implementation of the nativeTest Class

</P>


<PRE>

void NativeTest_testException2(struct HNativeTest *nativeTest){

     // Set a value to be used when an exception occures.

     unhand(nativeTest)-&gt;myErrorValue = 100;

     // Set up to throw the exception.

     SignalError(EE(),&quot;java/io/IOException&quot;,&quot;test

           &Acirc;error=ArithmeticException&quot;);

     // Return so that Java can throw the exception.

     return;

}

</PRE>




<A NAME="PAGENUM-626"><P>Page 626</P></A>







<H4><A NAME="ch14_ 18">

Compiling and Linking Native Libraries

</A></H4>



<P>The next thing you need to do to create a combined Java and native C code application

is to compile the C code into a loadable library. A

loadable library, such as data link libraries in Microsoft Windows and NT, is required because linking between Java and C can

take place only at runtime. Linking at runtime is the normal way Java links classes. All

classes are treated as loadable libraries that are loaded only as they are used. Behind the scenes

in the JVM, links to the classes, their fields, and methods are accomplished via the

same names and signatures that have been seen so far in the native C code calls into Java

to create objects and call methods. As was mentioned in the section &quot;Stub Files Generated

by javah,&quot; stubs are used so that javah can call a method marked as native. Native

method marking enables the Java VM to call the function loaded in the library after the library

has been loaded.

</P>



<P>Take special care to ensure that the Java code, stub files, header files, and C code are

kept synchronized with all interrelated changes. Incompatibility problems between

native libraries and Java code may often be attributed to compiling and linking different

versions of classes and functions. When a Java program hard crashes with a native library,

most likely, the problem was caused at compile- or link-time. The following paragraphs

cover many of the problems involved with these processes.

</P>



<B>

Compiling

</B>



<P>The compiling of native functions is identical to the process in

C. The only requirement is to include the header files generated

by javah into the implementation file.

</P>



<P>Be very careful to keep the stub and header files accurate. The

code may compile, but when a library is accessed by the Java

code, differences can cause hard crashes that may be difficult to trace.

If possible, use a make file that causes the generation of stub

and header files, every time Java classes are updated.

</P>



<B>

Linking Debug and Release Versions of Your Libraries

</B>



<P>In order to use the native C code, the code objects must be

linked into dynamically loadable libraries. On Windows 95, Warp, and the Macintosh, these

have the file extension .dll, and on some Unix platforms, these are called &quot;so&quot; libraries.

Please refer to your particular platform's documentation for specific instructions.

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

When compiling the code generated by Java, the search

path for include files must have JAVAHOME/ in-     clude in the path.

In the Windows 95 and NT versions, the in-     clude path also

re-     quires JAVAHOME/include/win32.

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>





<P><CENTER>

<a href="0619-0622.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0627-0629.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







