<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Java Beans:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0686-0690.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0696-0700.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-691"><P>Page 691</P></A>


<P>Recall that the DigitReceiver class extends Panel and draws within itself each digit that
is requested by the DigitSender class. Listings 15.6a through 15.6c contain the
DigitReceiver class.
</P>

<P>Listing 15.6a is the constructor for the class. Here, a default font and initial
display character are set. Because the class extends Panel after the constuctor executes, control
is passed to the paint() method.
</P>

<P>Listing 15.6aThe Constructor for the DigitReceiver Class Performs Setup
</P>

<PRE>
import java.awt.*;


//The DigitReceiver class implements DigitListener and will display any
//of the digits 0-5 when asked to.
public class DigitReceiver extends Panel implements DigitListener {
      private char currentChar;      //the current character to display


      //Constructor, sets the default size, and font. Also sets the
      //initial display character to ?
      public DigitReceiver() {
            Stefan(new Font(&quot;Helvetica&quot;, Font.BOLD, 24));
            currentChar = `?';
            resize(50, 50);
      }
</PRE>

<P>Every time a screen redraw is necessary, the paint() method is called. This method
takes the current value of currentChar and draws it on-screen using the drawString() method.
</P>

<P>Listing 15.6bThe paint() Method Draws the Value of currentChar On-Screen
</P>

<PRE>
      //the paint method get called every time the currentChar variable
      //changes value here that variable is drawn to the screen.
      public void paint(Graphics g) {
               g.drawString(String.valueOf(currentChar), 40, 25);
      }
</PRE>

<P>As instructed by its interface, listing 15.6c contains a series of
showXXX() methods. Each method alters the value of currentChar to match its constructor, and then it forces a
redraw by calling the repaint() method.
</P>


<A NAME="PAGENUM-692"><P>Page 692</P></A>


<P>Listing 15.6cThe showXXX() Methods Are Called by the Event Source
</P>

<PRE>
      //The following showXXX() methods are implemented as a requirement
      //of the interface each changes the value of the currentChar
      //variable and then causes the screen to be redrawn.

       public void showZero(DigitEvent e) {
            currentChar = `0';
            repaint();
      }


      public void showOne(DigitEvent e) {
            currentChar = `1';
            repaint();
      }


        public void showTwo(DigitEvent e){
            currentChar = `2';
            repaint();
      }


        public void showThree(DigitEvent e){
            currentChar = `3';
            repaint();
      }


        public void showFour(DigitEvent e){
            currentChar = `4';
            repaint();
      }


        public void showFive(DigitEvent e){
            currentChar = `5';
            repaint();
      }
}
</PRE>


<A NAME="PAGENUM-693"><P>Page 693</P></A>



<P><B>
Linking Beans
</B></P>

<P>So far, two interfaces and two classes have been developed. An event sender Bean and
an event listener Bean are combined with a utility class called DigitDriver.
</P>

<P>The class in listing 15.7 extends java.awt.Frame and places the DigitSender
and DigitReceiver Beans on screen. The driver class registers the DigitReceiver Bean as
a listener of DigitSender's events. In addition, the class supports a main() method, which
is called by the Java VM when the class is instantiated.
</P>

<P>Listing 15.7A Driver Class for the Digit Beans
</P>

<PRE>
import java.awt.*;


//Class DigitDriver is a driver which links together the
//sender and listener Beans.
public class DigitDriver extends Frame{
      DigitReceiver       theListener;    //the event listener
      DigitSender         theSender;      //the event source


      //Constructor, instantiates the objects, adds them
      //to the screen, and links them together.
      public DigitDriver() {
            theListener = new DigitReceiver();
            theSender = new DigitSender();
            theSender.addDigitListener(theListener);

            setLayout(new GridLayout(1, 2));

            add(theSender);
            add(theListener);

            pack();
            show();
      }


      public static void main(String args[]) {
            DigitDriver myDriver = new DigitDriver();
      }
}
</PRE>


<A NAME="PAGENUM-694"><P>Page 694</P></A>



<H3><A NAME="ch15_ 13">
Developing AWT Beans
</A></H3>

<P>Chapter 6 developed a GUI application framework. This framework is a traditional
class library based on the Java 1.0 event model. In this section you will convert that
framework into a series of Java Beans based on the Java 1.1 event model.
</P>

<P>In the framework in Chapter 6, basic GUI application functions are implemented by
the class FrameWork. This class creates a series of GUI components that facilitate
communication between the application and the user. When a GUI component is dismissed,
the owner is notified by a method invocation.
</P>

<P>When a new instance of the Decision class is created, for example, it displays in a
new window a user-defined string, along with two buttons (OK and Cancel). When one
of these buttons is clicked, the Decision object notifies the calling object by calling
its tellResponse() method. If these classes are Beans, the owner of the Dialog class
would register itself as a listener of Dialog's actions, and when either the OK or Cancel button
is clicked, the Dialog class sends an event to all registered listeners.
</P>

<P>To make the application framework Bean-based, make the following changes:
</P>

<UL>
<LI>     Modify each GUI component to act as a proper event source.
<LI>     Modify the FrameWork class to act as an event listener.
</UL>

<H4><A NAME="ch15_ 14">
Modifying GUI Components
</A></H4>

<P>While introducing Java 1.1 event sources during the beginning of this chapter, a series
of properties were defined that must be supported by any event source. As you modify
the Chapter 6 framework to make it a set of Java Beans, you must ensure that each of
the event source properties is present where needed. To refresh your memory, the
properties that all event sources need to support are
</P>

<UL>
<LI>     The event source must offer a unique event class that can propagate from the
event source to each listener.
<LI>     The event source must enable the registration and unregistration of listener objects.
<LI>     Facilities must be provided to track the pool of listener objects.
<LI>     Based on a specified input, the event source sends an event to all
registered listeners.
</UL>


<A NAME="PAGENUM-695"><P>Page 695</P></A>


<UL>
<LI>     The event source must be designed for multithreaded  environments.
</UL>

<P><B>
Notifying Listeners
</B></P>

<P>Event passing under the Java 1.0 event model is pretty cut and dry. There is one
event class, and the value of one of its ID variables indicates the event source. With Java
1.1 bringing a new event model, it also brings a series of event classes, all of which are
unique to their source. Because there are many different
event classes, it is not always obvious which of the event classes should be used when defining communication between
two Java Beans. In deciding on the event class to be used in the application framework,
there are basically three options:
</P>

<UL>
<LI>     The event object passed to DigitSender when a button is clicked is passed
directly to each listener.
<LI>     A unique event object is written for each GUI Bean.
<LI>     A unique event object is written for the framework and reused in each Bean.
</UL>

<P>There are obvious pros and cons to each of these choices. The first needs further
research to properly verify its viability. Recall in listing 15.3a that an event generated by the
user clicking the button is passed to the method processEvent() as an instance of the
class AWTEvent. The implementation of processEvent() in listing 15.3a creates a new
instance of an event called DigitEvent, and then processEvent() passes the DigitEvent instance
to each listener. It seems that creation of the extra event is not really needed, and that
it would simply be easier to pass along the AWTEvent object passed to processEvent().
</P>

<P>Although passing AWTEvent is simple, it has its disadvantages. This approach makes
it difficult for listeners to ensure that the event is coming from the proper location
because AWTEvent is used by almost all GUI components. Another disadvantage is that
interclass dependence (coupling) is decreased. For the most part, it is nice to have tightly
coupled classes because it helps preserve the integrity of your component. The rare situation
when low level coupling is desired is usually for a class that needs to respond to many
different inputs by using one method invocation.
</P>

<P>Finally, the primary disadvantage is that because a generic event class is used, it makes
it impossible for event listeners to verify the source of an
event.
</P>

<P>The second option uses a unique event object for each GUI Bean, which is nice because
it facilitates identification of the event source, resolving the question of whether the
event
</P>

<P><CENTER>
<a href="0686-0690.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0696-0700.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



