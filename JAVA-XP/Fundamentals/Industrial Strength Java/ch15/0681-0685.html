<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Java Beans:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0677-0680.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0686-0690.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-681"><P>Page 681</P></A>


<H4><A NAME="ch15_ 7">
Implementing Java 1.1 Event Services
</A></H4>

<P>Java 1.0 implements all events as instances of the class java.awt.Event and
differentiates them by a numeric ID. With Java 1.1, all events are instances of a childclass
of java.util.EventObject; each event is represented by a unique class. There is a
minor exception to this&#151;a few events that are similar are
represented by a single class and differentiated by a numeric ID. An example of this is java.util.MouseEvent which
represents mouse up, mouse down, mouse drag, and mouse move events.
</P>

<P>As indicated in figure 15.1, events propagate from a source object to a listener
object. Source objects have the following characteristics:
</P>

<UL>
<LI>     They broadcast events.
<LI>     They broadcast events to registered objects.
<LI>     Object properties are modified with getProperty() and setProperty() methods.
</UL>

<P>Listener objects have the following characteristics:
</P>

<UL>
<LI>     They implement a specific interface that defines which methods may be invoked
          by the source. This interface is a childclass of java.util.EventListener.
<LI>     They must register themselves as listeners of source objects.
</UL>

<P>It is good programming practice for Java Beans developers to assume that their Beans
will be used in a multithreaded environment. To ensure proper execution in
multithreaded environments, at least synchronize all methods.
</P>

<P>Figure 15.2 expands on the right half of figure 15.1 to demonstrate the
step-by-step process that occurs between an event source and an event listener. This process is
fully expanded with a complete example of a Java Bean in the section, &quot;Developing Your
First Java Bean.&quot;
</P>

<H4><A NAME="ch15_ 8">
The Importance of the Java 1.1 Event Model to <BR>Beans Developers
</A></H4>

<P>A message-passing medium is required for Java Beans to properly communicate with
each other. A medium based on hierarchy is obviously not suitable to Java Beans; therefore,
the Java 1.1 delegation-based event model was adopted.
</P>

<A NAME="PAGENUM-682"><P>Page 682</P></A>



<P><a href="images\ch15fg02.jpg"><img src="images\tn_ch15fg02.jpg"></a><BR>
Figure 15.2 The event source and listener communicate so no event
occurs without the listener knowing about it.
</P>

<H3><A NAME="ch15_ 9">
Java Beans Basics
</A></H3>

<P>This section explores the different forms that a Bean may take. Beans with a visual
state are compared to those without a visual state. Finally, this information is used to develop <BR>
an example Bean. The Java Bean developed in this section is rather basic, but
more advanced demonstrations appear later in the chapter.
</P>

<H4><A NAME="ch15_ 10">
Java Beans with a Visual Representation
</A></H4>

<P>Java Beans can be placed into two distinct categories:
</P>

<UL>
<LI>     Those with a visual representation
<LI>     Those without a visual representation
</UL>

<P>Java Beans with a visual representation are more common than those without one. When
a component has a visual representation, it can draw itself on the screen. Examples of
this would be a slider, grid, or button component.
</P>


<A NAME="PAGENUM-683"><P>Page 683</P></A>


<H4><A NAME="ch15_ 11">
Java Beans without a Visual Representation
</A></H4>

<P>Not all Java Beans require visual representations. Java Beans are ideal for
various processing and communicating tasks, which any application needs to support.
Examples of Beans that would not have a visual representation are those that sort objects, send
e-mail, or retrieve a file by using FTP.
</P>

<H4><A NAME="ch15_ 12">
Developing Your First Java Bean
</A></H4>

<P>In this section, you will develop two tightly coupled Beans. One is a button that,
when clicked, generates a pseudorandom number and tells the second Bean to display
that number.
</P>

<P><B>
The Event Source
</B></P>

<P>The event source in this application appears on-screen as a
standard button. When that button is clicked, an event is sent to the
listener, and then the listener displays the appropriate number. This
section focuses on the formation of the event source.
</P>

<P>All standard GUI widgets are already event sources. In the case
of java.awt.Button, a listener class simply has to register itself as
a listener of the Button class to enable the notification of a
button click. This application uses java.awt.Button. Button is
subclassed, and methods specifically designed to notify listeners are placed
in that subclass.
</P>

<BR>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
When referring to components, coupling describes the
dependency of one component on another. 
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P><a href="images\ch15fg03.jpg"><img src="images\tn_ch15fg03.jpg"></a><BR>
Figure 15.3 Propagation of the button click from the event source to
the event listener.
</P>


<A NAME="PAGENUM-684"><P>Page 684</P></A>


<P>Figure 15.3 illustrates the communication link between the source and listener.
</P>

<P>Your event source object (DigitReceiver) must do the following to facilitate this
communication:
</P>

<UL>
<LI>     Subclass java.awt.Button
<LI>     Support methods that enable event listeners to register and unregister
themselves as listeners
<LI>     Provide facilities to track each listener
<LI>     Implement logic to generate and analyze a random number, and call the
method associated with that number in each listener
</UL>

<P><B>
Subclassing java.awt.Button
</B></P>

<P>By subclassing java.awt.Button, events that are generated by user clicks first pass
through the subclass, DigitReceiver. This allows DigitReceiver to sense the button click and
then communicate properly with all its listeners.
</P>

<P>Do not confuse this setup with the Java 1.0 event model. The fact that the
subclass receives the event does not imply that an event hierarchy exists. The event is passed
to DigitReceiver, but DigitReceiver will not pass that event to any parent classes.
</P>

<P><B>
Enabling Listener Registration and Tracking
</B></P>

<P>Because an event source needs to track an infinite number of listeners, some
growable data structure needs to be used to track those listeners. The class java.util.Vector is such
a class, and it is used in your event source to track and reference listeners. Listing
15.1 contains a code that is used to add and remove listener objects from the Vector
object maintained by the event source.
</P>

<P>Listing 15.1Methods for Maintaining the Pool of Reference Objects
</P>

<PRE>
// Register an Event Listener.
public synchronized void addDigitListener(DigitListener dl) {
      listeners.addElement(dl);
}

// Remove an Event Listener.
public synchronized void removeDigitListener(DigitListener dl) {
      listeners.removeElement(dl);
}
</PRE>


<A NAME="PAGENUM-685"><P>Page 685</P></A>



<P>In the addDigitListener() and removeDigitListener() methods, &quot;listeners&quot; is an instance
of the java.util.Vector class. It is extremely important that these methods employ the
&quot;synchronized&quot; modifier. In a multithreaded environment, it permits only one object at a
time to use the method marked &quot;synchronized.&quot;
</P>

<P>Notice the data type of the parameters accepted by the methods in listing
15.1. DigitListener is an interface implemented by all listener objects. This interface
identifies the methods that are called by the event source.
</P>

<P>Listing 15.2 contains the DigitListener interface. Any class that implements
DigitListener is responsible for ensuring that each method (when called) properly displays the
number referenced in its signature. To keep this example simple, only numbers greater than
or equal to zero and less than or equal to five are considered.
</P>

<P>Listing 15.2The DigitListener Interface Defines the Methods Required of a
Listener Object
</P>

<PRE>
//interface which defines the methods required of a listener object
public interface DigitListener extends java.awt.event.ActionListener {

      //each method will draw to the screen some form
      //of the digit referenced in its signature.

         public void showOne(DigitEvent e);
        public void showTwo(DigitEvent e);
        public void showThree(DigitEvent e);
        public void showFour(DigitEvent e);
        public void showFive(DigitEvent e);
      public void showZero(DigitEvent e);

}
</PRE>

<P><B>
Notifying Listener Objects
</B></P>

<P>When a button click occurs, the event source first generates a new random number,
and then it notifies each registered listener object of that new number. This registration
is accomplished by calling the method in the listener object that is associated with the
new random number.
</P>

<P>The implementation details of the methods involved with notification follow.
</P>


<P><CENTER>
<a href="0677-0680.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0686-0690.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



