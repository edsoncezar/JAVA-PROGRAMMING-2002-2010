<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Java Beans:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0701-0705.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="..\ch16\0709-0711.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-706"><P>Page 706</P></A>


<P>It is important to note at this point that Java VMs supporting the Java 1.1 specification
will be fully backward compatible. However, although this may be
the case, mixing of event models in one application should never be done.
</P>

<H3><A NAME="ch15_ 17">
Java 1.1 as It Affects Java
</A></H3>

<P>This chapter now discusses some other features of Java Beans, especially how they
relate to the new features in Java 1.1. Finally, there is a discussion on the differences
between Java Beans and class libraries. In addition to the delegation-based event model,
this section offers information on the following features new to Java 1.1:
</P>

<UL>
<LI>     Serialization
<LI>     JAR files
<LI>     Introspection
</UL>

<H4><A NAME="ch15_ 18">
Serialization
</A></H4>

<P>Serialization in Java provides object persistence, which usually involves writing
an object's state to a file or database. The real beauty of serialization is
deserialization&#151;reconstructing objects from their serialized form.
</P>

<P>Serialization is managed by a set of new classes in the java.io package; most notable is
the ObjectOutput class. When serialized to a file, a Java Bean is given the .ser
extension. Through the use of a class loader, Java code can reconstruct an object from its
serialized form. The code in listing 15.13 serializes a Decision object to a file.
</P>

<P>Listing 15.13Serializing a Decision Object
</P>

<PRE>
//Serialize an instance of the Decision class developed above.
FileOutputStream         fop = new FileOutputStream(&quot;decision.ser&quot;);
ObjectOutput             oo      = new ObjectOutput(fop);
oo.writeObject(myDecision);
oo.flush()
</PRE>

<P>Listing 15.14 provides code to deserialize the object serialized in listing 15.13.
</P>

<P>Listing 15.14Deserializing the Object Serialized in Listing 15.13.
</P>

<A NAME="PAGENUM-707"><P>Page 707</P></A>


<PRE>
ClassLoader    cl =
Class.forName(&quot;industrial.Decision&quot;).getClassLoader();
Decision     myDecision = Beans.instantiate(cl, &quot;/home_u/ulcassad/
&Acirc;decision.ser&quot;);
</PRE>

<H4><A NAME="ch15_ 19">
JAR Files
</A></H4>

<P>Java ARchive (JAR) files are the standard deliverable form of a Java Bean. A JAR file is
a mechanism that stores any number of the following in a single file:
</P>

<UL>
<LI>     .class files
<LI>     Image files
<LI>     Sound files
<LI>     Serialized object files (.ser extension)
<LI>     Other JAR files
<LI>     Any other resources used by an application
</UL>

<P>The JAR format handles the large number of files associated with a Java application
by placing these files in a manageable format.
</P>

<P>Given any JAR file, it is possible to both determine the names of Java Beans in that
file and possibly to instantiate any of these Beans.
</P>

<H4><A NAME="ch15_ 20">
Introspection
</A></H4>

<P>Introspection is a process that enables users of a Java Bean to determine the
public methods of a class. Here &quot;user&quot; is defined as either another object at run-time or as
a builder application. By providing a standard mechanism that supports introspection, a
user may easily manipulate an unknown Java Bean.
</P>

<P>This standard mechanism, introspection, is managed in two ways:
</P>

<UL>
<LI>     Through analysis of common design patterns
<LI>     Through explicit specification
</UL>

<P>A design pattern is a standard mechanism used when writing code. The most obvious
of these are the getXXX() and setXXX() methods, which are used to manipulate
class properties. Through analysis of design patterns, users performing introspection
can 
</P>

<A NAME="PAGENUM-708"><P>Page 708</P></A>


<P>develop a clear representation of the Java Bean.
</P>

<P>When analysis of design patterns does not give a clear enough picture of a Java Bean,
a developer can use explicit specification functionality by writing a class that
implements the BeanInfo interface. This interface (defined in listing 15.15) enables a
Java Bean to specify information about the data and data manipulation supported by the Java Bean.
All methods in listing 15.15 defined by the interface are abstract. This means that
their implementation in a given class is optional.
</P>

<P>Listing 15.15The BeanInfo Interface Allows a Java Bean to Explicitly Specify
Its Properties
</P>

<PRE>
public interface java.Beans.BeanInfo {
      public abstract BeanInfo[] getAdditionalBeanInfo();
      public abstract int getDefaultEventIndex();
      public abstract int getDefaultPropertyIndex();
      public abstract EventSetDescriptor() getEventSetDescriptors();
      public abstract MethodDescriptor() getMethodDescriptors();
      public abstract PropertyDescriptor[] getPropertyDescriptors();
}
</PRE>

<H3><A NAME="ch15_ 21">
Summary
</A></H3>

<P>Components are changing the face of computing. Within a few years, all development
and deployment of applications will be based around different component
frameworks. Ultimately, components from totally different developers will be capable of
working together in perfect harmony.
</P>

<P>This chapter covered significant ground, and by now you should be an expert on
Java Beans development. Learning the details of Java Beans development will make you
much more marketable. Before you move on to other material, sit down and convert some
of your old class libraries into Java Beans. After you have done this, write some Java
Beans from scratch.
</P>

<P><CENTER>
<a href="0701-0705.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="..\ch16\0709-0711.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



