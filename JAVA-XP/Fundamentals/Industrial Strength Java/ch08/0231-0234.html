<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Advanced Data Structures:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="..\ch07\0229-0230.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0235-0239.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-231"><P>Page 231</P></A>

<H3><A NAME="ch08_ 1">
Chapter 8
</A></H3>

<H2>

Advanced Data <BR>
Structures

</H2>

<P>Chapter 7, &quot;Beginning Data Structures: Taking Advantage of java.util,&quot; began by
introducing the concept that development of data structures was not only possible in
Java, but also much easier (and more enjoyable) than in languages such as C++ or Pascal.
The discussion started with a basic overview of the fact that pointers are really not
necessary; however this concept was not discussed in much depth. Instead of discussing the
manner in which it is possible to implement data structures from scratch, the focus was on
the java.util package, which contains many pre-built data structures. Chapter 8 moves
from the discussion on working within the confines of what is provided by the Java API
and into a discussion of what it takes to develop data structures completely from scratch.
</P>

<P>As with all chapters, the focus is on design; everything is thoroughly planned before
one line of code is written. As you finish this chapter, you will be pleasantly surprised with
the code you will have developed. Code is re-used heavily from data structure to data
structure, and all code is logically written and easy to understand.
</P>

<A NAME="PAGENUM-232"><P>Page 232</P></A>



<H3><A NAME="ch08_ 2">
Building Stacks and <BR>Queues
</A></H3>

<P>In Chapter 7, stacks and queues were implemented with the aid
of the classes in the java.util package. Because the Stack class
already existed in the java.util package, it was possible to implement a
stack in a few lines of code. This section also covers stacks and
queues, however, this time around we will look at the form of each
data structure. In looking at the form of each data structure it will
become plainly obvious that the two data structures are almost identical
in form.
</P>

<P>As was stated in Chapter 7, stacks and queues are two of the
most basic data structures on the block.
</P>

<P>As you will remember from the discussion in Chapter 7, stacks
and queues are nothing more than a bunch of nodes all linked
together. Each node has a link to the next (the linking is one-way), and
you must access the nodes sequentially. Of course, the main benefit
is that using dynamic data structures does not limit the amount
of information you can store.
</P>

<P>Stating that stacks and queues are just a bunch of nodes
linked together hints that their design will be pretty much the same. This
is quite true; the only real difference between the two data structures
is the manner in which you add and subtract nodes. A queue is a
First-In-First-Out (FIFO) data structure, and a stack is
a Last-In-First-Out (LIFO) data structure.
</P>

<P>In looking at the process by which stacks and queues will
be implemented, coverage will first cover similarities and then
differences.
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The use of the word &quot;basic&quot; can be taken in two ways.
First, although stacks and queues are very basic in design, they are
the basic building blocks of any application. After all, computing
is all about controlling information, and data structures enable
you to control information in a manageable way. Stacks and
queues existing as basic data structures become a point upon
which larger data structures can be based.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Although the capability to store a dynamically sized data set
is rather exciting, you must not forget the overhead involved
in memory allocation. The decision to use statically sized
data structures (such as arrays) over dynamically sized data
struc-     tures is one that you will want to make during the
design stage. For a deeper discussion on this topic, please
refer back to the section on the Vector class in Chapter 7.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-233"><P>Page 233</P></A>



<H3><A NAME="ch08_ 3">
Working on the Similarities <BR>
Between Stacks and Queues
</A></H3>

<P>Because stacks and queues are just a combination of nodes that are enabled to link to
one other node at the most, you will need some sort of node class that will be managed by
the stack and queue to build both of these data structures. To further illustrate this point,
look at figure 8.1, which illustrates the basic form of a stack and a queue. Note that both
the stack and queue in the figure are composed on identical building blocks (or nodes).
What is unique about each figure is the manner in which nodes are added and subtracted.<BR>
</P>


<P><a href="images\ch08fg01.jpg"><img src="images\tn_ch08fg01.jpg"></a><BR>
Figure 8.1
Although they are different, stacks and queues are built
of the same basic building blocks. Numbers indicate
the order of insertion.
</P>

<P>To begin the venture into stacks and queues, you will look at coding the
Node class. The Node class is the &quot;basic building block&quot; common to the form of stacks and queues.
The requirements of a stack and queue have been covered in the current section. Working
on the premise that the Node class will encapsulate all features common to stacks and
queues, a union of both feature sets will produce the features needed of the Node class.
These features are
</P>


<A NAME="PAGENUM-234"><P>Page 234</P></A>



<UL>
<LI>          The capability to either link to, at most, one other Node object
<LI>          The capability to &quot;hold&quot; an object as its value
<LI>          The capability to return this object to anyone who requests it
<LI>          The capability to return the next node in line
<LI>          The capability to return the value of the next node in line
<LI>          The capability to change the next node in line
<LI>          The capability to change the value of the next node in line
<LI>          The capability to sense if the next node in line does or does not exist
</UL>

<H4><A NAME="ch08_ 4">
Managing the Existence of Zero Nodes
</A></H4>

<P>Having a firm grasp of what is needed, you can now begin
working on how to implement it. First of all, you need to understand
that someone may ask for a node that does not exist. What happens,
for example, when a node has only one node in the queue, and you
ask that node for the next node in line? An error of this magnitude
could cause some rather large problems, and the Node class will
need some bullet-proof protection to keep this error from happening.
This level of protection is implemented by taking advantage of one
of Java's most elegant features&#151;exceptions.
</P>

<P>An exception is a class that is instantiated and &quot;thrown&quot;
when something out-of-the-ordinary, or &quot;exceptional,&quot; occurs.
Exceptions are not meant to be used to catch general errors because it is more expensive to throw
an exception than it is to check for the existence of an error condition. You will use
exceptions in an application when a class has the potential to be manipulated in a manner that
is not always expected and will cause undesirable (or unpredictable) output.
</P>

<P>Listing 8.1 defines the exception used in the Node class. It will be thrown whenever a
user tries to either access a nonexistent node or the value of a nonexistent node. The
String passed in will be a small description of the executing method.
</P>

<P>Listing 8.1 NoSuchNodeException Will be Thrown If and Only If a User
Attempts to Access a Non-Existent Node
</P>

<PRE>
package industrial;
</PRE>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
C++ developers must be pleasantly surprised to see that
the node does not have to dispose of itself after you are done with
it. Ahh the joys of garbage collection.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<P><CENTER>
<a href="..\ch07\0229-0230.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0235-0239.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



