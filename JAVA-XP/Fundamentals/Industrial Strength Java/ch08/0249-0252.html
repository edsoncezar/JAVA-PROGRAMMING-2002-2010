<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Advanced Data Structures:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0244-0248.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0253-0257.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-249"><P>Page 249</P></A>


<PRE>
            //pop the remaining integers are print to the screen
            while(!myStack.isEmpty()) {
                  try{
                        System.out.println(&quot;pop: &quot;+
                             &Acirc;(Integer)myStack.pop());
                  }
                  catch(NoSuchNodeException nsne) {
                &Acirc;System.out.println(&quot;err: &quot;+nsne); }
            }
      }
      public static void main(String args[]) {
            Driver myDriver = new Driver();
      }
}
</PRE>

<P>The following shows the output generated by the application in listing 8.4.
</P>

<PRE>
push
pull
lift
tuck
wiggle
wuck

push: 0
push: 1
push: 2
push: 3
push: 4
push: 5
push: 6
push: 7
push: 8
push: 9
push: 10
delete 42
delete 333
err: industrial.NoSuchNodeException: Exception thrown due to: delete can
&Acirc;not happen, node DNE
delete 10
find 10: err: industrial.NoSuchNodeException: Exception thrown due to:
&Acirc;find can not happen, node DNE
find 5: 5
pop: 9
pop: 8
</PRE>

<A NAME="PAGENUM-250"><P>Page 250</P></A>



<PRE>
pop: 7
pop: 6
pop: 5
pop: 4
pop: 3
pop: 2
pop: 1
pop: 0
</PRE>



<H3><A NAME="ch08_ 11">
Using the Node Class to Form 
a Queue
</A></H3>

<P>Well congratulations, you just built your first data structure in
Java! If, however, you think that you are close to finishing, you are
very much mistaken. Our exploration into data structures has just begun!
</P>

<P>The most logical data structure to begin developing after you
have developed the Stack class is a queue. As was stated previously,
the only manner in which a queue differs from a stack is in the way
it manipulates its nodes. A stack allows LIFO access to nodes,
whereas a queue allows FIFO access to nodes.
</P>

<P>Transitioning the Stack code over to the code that the Queue
class needs is not difficult; however, it does require you to look at
the problem in a slightly different manner because a Stack only has
to keep a reference to one side of the chain of nodes. You pushed
and popped from the same end of the stack; your head reference
was always to the most recently added node. Because the Queue
class will need FIFO access to its nodes, you need to track both the
first node that was added to the queue (the head) and the last node
that was added (the tail). You will always remove from the
location marked by the head and add to the queue from the position
marked by the tail.
</P>

<P>As with the Stack class, the possibility that a reference to a
non-existent object will be generated is still an ever-present danger.
In these cases, an exception will need to be
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Not only is our exploration into data structures
just beginning, so is your life-long exploration into the subject. I
have been involved with computing for a number of years
now, and I still do not feel that I have a mastery of the subject.
This topic is growing day-by-day, and if you are serious about
com-     puter science, you should plan on study-     ing data structures
all of your life.
<BR>
<BR>
Plus proving your knowledge of data structures is one
of the best ways to score a date!
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-251"><P>Page 251</P></A>

<P>thrown.
</P>
<H4><A NAME="ch08_ 12">
Designing the Queue Class
</A></H4>

<P>The design process for your Queue class is significantly aided because it implements a
set of features similar to those features supported by the Stack class. In fact, the
implementation of this class does not even require an object diagram; you will reference the
one generated for the Stack class. Although you will not need an object diagram, you will
need to learn how the methods will be implemented.<BR>
</P>



<P>Each method in the Queue class is implemented in a manner very different than
the manner in which it was implemented in the Stack class. This occurs because the
empty condition is signaled in a totally different fashion, and you will need to access the nodes
in a completely different order. So take a quick glimpse back to figure 8.3 and buckle
down for a dive into the inner workings of a FIFO data structure!
</P>

<P>The diagram in figure 8.7 shows three possible stages that a queue can be in while
items are being added and removed. These stages are
</P>

<OL>
<LI>          The first stage indicates a queue that contains five nodes, also indicated are
the head and tail nodes.
<LI>     In the second stage, you remove one node by moving the head reference down one.
<LI>     In the third stage, you add a node by tacking a new node on the bottom
and moving the tail reference down one.
</OL>

<P>In all cases, the numbers on the nodes indicate the order in which they were inserted
(from the beginning).
</P>

<P>The insertion and deletion of nodes diagrammed in figure 8.6 are implemented with
push() and pop() methods. The other methods needing support in your class are
find(), isEmpty(), peek(), and delete(). As with the Stack class, inclusion of the delete() method goes
against the FIFO access rules, but is provided as a convenience to users. Also identical to
the methodology that was used to build the Stack class is a strong adherence to
exceptions. Your Queue class will take advantage of exceptions at every opportunity.
</P>

<P>Although little time has been spent discussing the manner in which you are going
to implement the methods in the Queue class, you are almost ready to begin coding.
This may come as a surprise to you readers who are familiar with this book's strong
commitment to
</P>


<A NAME="PAGENUM-252"><P>Page 252</P></A>


<a href="images\ch08fg07.jpg"><img src="images\tn_ch08fg07.jpg"></a><BR>
Figure 8.7
Insertion and removal from a queue is
facilitated by the proper management of the head and tail nodes.
</P>


<P>design. It is, however, the strong commitment to design that enables you to
take the design developed for the Stack class and use it when writing the Queue class.
</P>

<P>To take advantage of the design used in the Stack class you have to accept that like
the Stack class, the Queue class is charged with manipulating a series of nodes kept in a
linear order. Thus although similar methods names are used, each method will be
implemented in a manner different from the manner in which the Stack class implemented its methods.
</P>

<P>Now that a clear understanding of what the Queue class needs to do has been developed,
it is time to figure out how the Queue class is going to operate. In listings 8.6a through
8.6d is the full code for the Queue class.
</P>



<P>In listing 8.6a is the constructor that the Queue class will use. It creates a new
node containing a quantity passed in as a parameter. Additionally the head and tail nodes are
set
</P>


<P><CENTER>
<a href="0244-0248.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0253-0257.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



