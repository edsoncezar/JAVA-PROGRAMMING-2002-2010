<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Advanced Data Structures:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0240-0243.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0249-0252.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-244"><P>Page 244</P></A>









<P>Listing 8.3a Continued

</P>




<PRE>



 public class Stack {

       //a reference to a head node will allow us to always know where to

       //base all insertions and deletions from.

       private Node head = null;



       //when creating a new Stack our head node will reference a Node with

       //the value in question and will have a null reference to other

               //Nodes.

       public Stack(Object quantity) {

             head = new Node(null, quantity);

       }

</PRE>










<P>In listing 8.3b are the push(), pop(), and peek() methods. The push() method attaches

a new node onto the stack, the pop() method removes it from the stack, and the

peek() method returns the top node's quantity.

</P>



<P>Listing 8.3b The push() and pop() Methods of the Stack Class

</P>




<PRE>

       //when adding a new Node onto the stack we will create a new node

        //and pass the current head reference as the next Node in line. We

       //will then move the head reference up so that it now references

           //the top Node.

       public void push(Object quantity) {

            Node myNode = new Node(head, quantity);

            head = myNode;

         }



       //the pop method will return the top Node and then move the head

       //reference down in line.

       public Object pop() throws NoSuchNodeException {

             Node temp = head;

             //first test if the head is null. this indicates that the

             //stack is empty

             if(head == null) {

                   throw new NoSuchNodeException(&quot;head is null&quot;, this);

             }



             //if we are this far we have been able to confirm that the

</PRE>




<A NAME="PAGENUM-245"><P>Page 245</P></A>








<PRE>

              //head reference is not null. However we still do not know

              //if there is more than one Node in the stack. If

               //there is then head will reference that node, otherwise an

             //exception will be thrown and head will be set to null.

            try{      head = head.getNextNode(); }

            catch(NoSuchNodeException nsne) { head = null; }



            return temp.getMyQuantity();

        }

       //the peek method will return the value of the head node. if head

            //is null then an exception will be thrown.

       public Object peek() throws NoSuchNodeException {

             if(head == null) {

                   throw new NoSuchNodeException(&quot;head is null&quot;, this);

             }



             return head.getMyQuantity();

       }





</PRE>




<P>In listing 8.3c are the isEmpty() and delete() methods. The isEmpty() method is a

utility method that enables you to test whether the stack is empty. The delete() method removes

a node from the stack.

</P>



<P>Listing 8.3c Testing for an Empty Stack without Throwing an Exception

</P>




<PRE>

       //this method allows us to test for an empty stack without throwing

          //an exception. if the head reference is to null then we know

         //that the stack contains no Nodes.

             public boolean isEmpty() {

             if(head == null){

                   return true;

             }

             return false;

       }





       //the delete method will either delete the Node which is passed

           //in, or will throw an exception if that Node does not exist.

       public void delete(Object deleteMe) throws NoSuchNodeException {

             Node dummyNode0 = head; //this will trail the current node

</PRE>


<PRE>
continues
</PRE>






<A NAME="PAGENUM-246"><P>Page 246</P></A>





<P>Listing 8.3c Continued

</P>






<PRE>

             Node dummyNode1 = head; //this will be used to track the

             //location of the current node

             Node dummyNode2 = null; //this will be used to used to

             //reference the node after the current node



            //test to see if our list is only one Node long

             try{       dummyNode2 = head.getNextNode(); }

             catch(     NoSuchNodeException nsne) { dummyNode2 = null; }

             //test to see if the node which needs to be deleted is the

                 //first Node

             if(deleteMe.equals(head.getMyQuantity())) {

                   head = head.getNextNode();

                   return;

             }



             //loop until either dummyNode1 references the node which

                 //needs to be deleted or the node after dummyNode1 is a

                 //null node.

           while(!deleteMe.equals(dummyNode1.getMyQuantity()) &amp;&amp;

           &Acirc;!dummyNode1.isNextNull()) {

                  dummyNode0 = dummyNode1;

                  dummyNode1 = dummyNode2;



                  //we test to see if the node which follows dummyNode2

                 //is null due to the fact that if it is then a

                //call to getNextNode would throw an exception.

                  if(dummyNode2.isNextNull()) {



                        //the next node is null, we therefore set

                              //dummyNode2 equal to null instead of

                        //the next node in line.

                        dummyNode2 = null;



                        //test to see if dummyNode1 references the node

                       //which we want to delete if not, we throw an

                      //exception.

                        if(!deleteMe.equals(dummyNode1.getMyQuantity()))

 {

                              throw new NoSuchNodeException(&quot;delete can

                          &Acirc;not happen, node DNE&quot;, this);

                        }

                  }



                  //the node which follows dummyNode2 is not null then a





</PRE>




<A NAME="PAGENUM-247"><P>Page 247</P></A>




<PRE>



                 //call to getNextNode is safe

                  else {

                        dummyNode2 = dummyNode2.getNextNode();

                  }

            }

            //&quot;loop around&quot; the node which we want to delete.

            dummyNode0.setNextNode(dummyNode2);

        }



</PRE>












<P>The find() method in listing 8.3d functions in a fashion similar to the delete()

method. Unlike the delete() method, however, nodes are located, not removed from the stack.

</P>



<P>Listing 8.3d The find() Method Returns the Number of Nodes

</P>




<PRE>

       //find will return the number of nodes (starting with 1, NOT

                //zero) which the node in question is from the beginning

          //of the stack. If the node does not exist anywhere in the

           //stack then and exception will be thrown.

       public int find(Object findMe) throws NoSuchNodeException {

             int counter = 1;

             Node dummyNode = head;

             while(!findMe.equals(dummyNode.getMyQuantity())) {

                   counter++;

                   if(!dummyNode.isNextNull()) {

                         dummyNode = dummyNode.getNextNode();

                   }

                   else {

                         throw new NoSuchNodeException(&quot;find can not

                     &Acirc;happen, node DNE&quot;, this);

                   }

             }

             return counter;

       }

 }

</PRE>




<P>Before moving on to the development of a queue by using the same Node class used

to develop the Stack class, proof is offered that this project actually works. Listing 8.4 is

a driver that creates a new Stack, adds a series of Integer objects, deletes a few, searches

for a few, and then prints the remaining Integers. Note that the delete() and find()

methods will prove that they function in all cases by throwing the necessary exception when

they are passed a node that does not exist in the Stack.

</P>






<PRE>
continues
</PRE>




<A NAME="PAGENUM-248"><P>Page 248</P></A>





<P>Listing 8.4Continued

</P>



<P>Listing 8.4 A Driver that Demonstrates that All Methods in the Stack Class

Function Properly

</P>








<PRE>

import industrial.*;

public class Driver {

      private Stack myStack;



      public Driver() {

            //create a new Stack

            myStack = new Stack(new Integer(42));

            //add the integers 0..10

            for(int i=0; i&lt;=10; i++) {

                  System.out.println(&quot;push: &quot;+ i);

                  myStack.push(new Integer(i));

            }



            //delete 42

            try{ System.out.println(&quot;delete 42&quot;); myStack.delete(new

               &Acirc;Integer(42)); }

            catch(     NoSuchNodeException nsne) {

              &Acirc;System.out.println(&quot;err:&quot;+nsne); }

             //try to delete 333

            try{ System.out.println(&quot;delete 333&quot;); myStack.delete(new

               &Acirc;Integer(333)); }

            catch(     NoSuchNodeException nsne) {

               &Acirc;System.out.println(&quot;err:&quot;+nsne); }

             //delete 10

            &Acirc;try{ System.out.println(&quot;delete 10&quot;); myStack.delete(new

              &Acirc;Integer(10)); }

            catch(     NoSuchNodeException nsne) {

               &Acirc;System.out.println(&quot;err:&quot;+nsne); }

            //try to find 10

            try{ System.out.print(&quot;find 10: &quot;);

                    System.out.println(myStack.find(new Integer(10)));

                  }

            catch(     NoSuchNodeException nsne) {

               &Acirc;System.out.println(&quot;err:&quot;+nsne); }

             //find  5

            try{ System.out.print(&quot;find 5: &quot;);

                    System.out.println(myStack.find(new Integer(5)));

                  }

            catch(     NoSuchNodeException nsne) {

               &Acirc;System.out.println(&quot;err:&quot;+nsne); }

</PRE>






<P><CENTER>

<a href="0240-0243.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0249-0252.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







