<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Advanced Data Structures:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0266-0269.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0275-0276.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-270"><P>Page 270</P></A>





<P><a href="images\ch08fg11.jpg"><img src="images\tn_ch08fg11.jpg"></a><BR>

Figure 8.11

The sample execution of the ModalOK class.

</P>








<PRE>

       public static void createModalOK(String dialogString) {

             if(createdFrame == null)

                   createdFrame = new Frame(&quot;Dialog&quot;);



             //actually create the dialog

             ModalOK theModalOK = new ModalOK(createdFrame, dialogString);

             createdFrame.resize(theModalOK.size().width,

             &Acirc;theModalOK.size().height);



             //display the dialog

             theModalOK.show();

       }

}

</PRE>




<P>Figure 8.11 shows the what the ModalOK class looks like after it is instantiated.

</P>



<B>

The Finishing Touches

</B>



<P>The application is nearing completion; all that is needed is a user interface.

</P>



<P>The interface being designed offers a split frame where information is collected in the

left half and is displayed in the right.

</P>



<P>Before you build that screen, concentrate on the options you need to present to the

user. Obviously, the user needs some way to enter data for a new node. There needs to

be support for creating a new tree and clearing the display screen.

</P>



<P>Additionally, the user needs to be able to view the nodes and their attributes. He should

be able to view the nodes via three standard traversals: preorder, inorder, and postorder,

as follows:

</P>



<UL>

<LI>          A preorder traversal visits all nodes starting at the root, displaying its left

children and then its right children.

<LI>          An  inorder traversal displays all nodes in order.

<LI>          A postorder traversal displays the left-most children first, then the

right-most children, and finally the root of the tree.

</UL>





<A NAME="PAGENUM-271"><P>Page 271</P></A>





<P>The last feature you will add is the capability to find the rank of any node. The rank

is defined by the order in which the node would occur during an inorder traversal.

</P>



<P>The ability to insert a new node is managed by keeping a reference to the root of the

tree. Whenever you have a new node to insert, you must tell the root about it and let the

root manage the insertion. If the root cannot attach it as a left or right child, it instructs one

of its children to deal with the node.

</P>



<P>The traversals are designed to be recursive in nature and to operate by drilling down

the tree until a null value is hit, indicating that a specific branch has come to an end. In

all cases, the traversals build an output string as each node is visited. After the traversal

is finished, a string containing the node's attributes is displayed.

</P>



<P>Finding the rank of a node also is recursive but is a bit trickier than the traversals.

The process is based on the relation between a node's rank and the number of children

that node has. You basically search through the tree looking for the node, incrementing

a counter every time a new node is visited.

</P>









<P>The code for the application is shown in listings 8.11a through 8.11d.

</P>



<P>In listing 8.11a is a constructor for the BinaryTreeUI class, along with various

member variables. The constructor is charged with building the screen.

</P>



<P>Listing 8.11a A Constructor for the BinaryTreeUI Class

</P>




<PRE>

package industrial;

import java.awt.*;

//Binary tree program

//the driver for the tree, also implements the pre,in,post-order

//traversals and the rank method

public class BinaryTreeUI extends Frame {



      //mostly gui stuff

      private TextField input = new TextField(100);

      private TextArea result = new TextArea(15, 25);

      private Button clear = new Button(&quot;Clear&quot;);

      private Button add = new Button(&quot;Add&quot;);

      private Label note = new Label(&quot;Traversals&quot;);

      private Button preorder = new Button(&quot;Preorder&quot;);

      private Button inorder = new Button(&quot;Inorder&quot;);

      private Button postorder = new Button(&quot;Postorder&quot;);

      private String sOutput = new String();

      private BinaryTree theTree;

</PRE>


<PRE>
continues
</PRE>






<A NAME="PAGENUM-272"><P>Page 272</P></A>









<P>Listing 8.11a Continued

</P>




<PRE>

      private Button newTree = new Button(&quot;New Tree&quot;);

      private Panel leftPanel = new Panel();

      private Panel rightPanel = new Panel();

      private Button rank = new Button(&quot;Rank&quot;);

      private ModalOK theError;



      //constructor, again all gui stuff

      public BinaryTreeUI(String title) {

            super(title);

            leftPanel.setLayout(new GridLayout(6, 2, 10, 10));

            leftPanel.add(input);

            leftPanel.add(new Label(&quot;&quot;));

            leftPanel.add(clear);

            leftPanel.add(add);

            leftPanel.add(newTree);

            leftPanel.add(rank);

            leftPanel.add(note);

            leftPanel.add(new Label(&quot;&quot;));

            leftPanel.add(preorder);

            leftPanel.add(inorder);

            leftPanel.add(postorder) ;



            rightPanel.add(result);

            this.setLayout(new GridLayout(1, 2));

            this.add(leftPanel);

            this.add(rightPanel);

      }

</PRE>




<P>Listing 8.11b contains the rank() method. This method recursively searches through

the binary tree, starting at the node passed to it for the int passed in as a parameter. If the

node is not found, an error dialog box is created to tell the user that the number is not present

in the tree.

</P>



<P>Listing 8.11b The rank() Method

</P>




<PRE>

      //the rank method. implemetnations is pretty obvious, uses recursion

      private int rank(BinaryTree t, int searchInt) {

            int tempInt = t.getKey();

            if (tempInt == searchInt) {

                  if (t.getLeft() == null)

                              return 1;



</PRE>




<A NAME="PAGENUM-273"><P>Page 273</P></A>






<PRE>

                        else

                              return (t.getLeft().getNumDescendents() + 2);

            }

            else if (searchInt &lt; tempInt)

                  return (rank(t.getLeft(), searchInt));

            else if (searchInt &gt; tempInt) {

                  if (t.getLeft() == null)

                        return (1 + rank(t.getRight(), searchInt));

                  else

                        return (rank(t.getRight(), searchInt) +

                                                   &Acirc;t.getLeft().getNumDescendents() + 2);

            }

            if (t.getLeft() == null || t.getRight() == null)

                  return (1);

            else

                  { ModalOK.createModalOK(&quot;Number Not Present&quot;); return 0;

 }

      }

</PRE>




<P>Listing 8.11c contains the methods that will perform the inorder, preorder, and

postorder traversals. Each works by recursively referencing child nodes while building an

output string containing data about each node.

</P>



<P>Listing 8.11c The Methods that Perform the Inorder, Preorder, and Postorder

Traversals

</P>




<PRE>

      //inorder traversal, recursive

      private void inorder(BinaryTree t) {

            if (t != null) {

                  inorder(t.getLeft());

                  sOutput += (&quot;height: &quot; + t.getHeight() + &quot; Descendents: &quot;

                                       &Acirc;+ t.getNumDescendents() + &quot; key: &quot; + t.getKey() + &quot;\n&quot;);

                  inorder(t.getRight());

            }

      }



      //preorder traversal, recursive

      private void preorder(BinaryTree t) {

            if (t != null) {

                  sOutput += (&quot;height: &quot; + t.getHeight() + &quot; Descendents: &quot;

                                      &Acirc;+ t.getNumDescendents() + &quot; key: &quot; + t.getKey() + &quot;\n&quot;);

                  preorder(t.getLeft());

                  preorder(t.getRight());

            }



</PRE>


<PRE>
continues
</PRE>






<A NAME="PAGENUM-274"><P>Page 274</P></A>



<P>Listing 8.11c Continued

</P>




<PRE>

      }





      //postorder traversal, recursive

      private void postorder(BinaryTree t) {

            if (t != null) {

                  postorder(t.getLeft());

                  postorder(t.getRight());

                  sOutput += (&quot;height: &quot; + t.getHeight() + &quot; Descendents: &quot;

                                       &Acirc;+ t.getNumDescendents() + &quot; key: &quot; + t.getKey() + &quot;\n&quot;);

            }

      }

      //gui

      public Insets insets() {

            return new Insets (10, 10, 10, 10);

      }



      //gui

      private void clearInput() {

            input.setText(&quot;&quot;);

            result.setText(&quot;&quot;);

      }



      //creats a new tree. note this is not called for the first tree as

      //one is automatically created on launch

      private void doNew() {

            theTree = null;      //we can get away with simply making the

                                 //root null due to the fact that the

                                 //garbage collector will free up memory

                                 //allocated to the other nodes.

            firstTime = true;

      }



</PRE>




<P>Listing 8.11d contains the action() method, which waits for input from the user. After

the action() method is passed an event, the method examines the event and calls an

associated method. Additioanlly in this listing is the main() method that creates a new instance of

the BinaryTreeUI class.

</P>



<P>Listing 8.11d The action() Method

</P>



<P><CENTER>

<a href="0266-0269.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0275-0276.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







