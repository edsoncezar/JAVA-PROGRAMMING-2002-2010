<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Advanced Data Structures:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0231-0234.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0240-0243.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-235"><P>Page 235</P></A>



<PRE>
public class NoSuchNodeException extends Exception {
      public String theName;
      public Object theValue;

      public NoSuchNodeException(String name, Object value) {
            super(&quot;Exception thrown due to: &quot;+ name);
            theName = name;
            theValue = value;
      }
}
</PRE>

<H4><A NAME="ch08_ 5">
When to Use the NoSuchNodeException
</A></H4>

<P>Because you have determined that an exception is useless if it is not thrown whenever
an error occurs, you must carefully study the design of the Node class and note all
potential sources of problems. You then will note of all locations where a non-existant node
might be accessed, and ensure that your code throws an exception instead of attempting to
access the non-existant node.
</P>

<P>A few pages ago in the section &quot;Working on the Similarities,&quot; a list presented the
features that the Node class will offer. The process of identifying potential sources of error
begins at that list. Examine all features, and any that involve accessing a node that may or
may not exist, should be noted as needing the protection of exception handling.
</P>

<P>When dealing with a &quot;chain&quot; of nodes, a good chance that you could be at an &quot;end&quot;
node and ask that node for the next node in line. Because no nodes follow an end node,
any methods that look past the current node are flagged as potential problems.
</P>

<P>The list of required features for the Node class includes four that need access to a
node other than the current one. These requirements include:
</P>

<UL>
<LI>          Returning either the value contained in the current node or returning the
node itself.
<LI>          Altering the current node node (both the node itself and its value).
</UL>

<P>The rest of the requirements for the Node class entail management of the current
node. This work is considered safe because any attempts to access the methods of a
non-existent class would be caught at compile-time, and thus a run-time exception would never 
</P>



<A NAME="PAGENUM-236"><P>Page 236</P></A>


<P>have an opportunity to come into play.
</P>

<H4><A NAME="ch08_ 6">
Diagramming the Node Class
</A></H4>

<P>You are almost ready to write the code for the Node class. You must, however,
first diagram the methods that your Node class will need to implement to offer support for
the requirements detailed at the beginning of this section. When diagramming these
methods, note the methods that have potential to cause errors and be sure to build in checks
to ensure that exceptions are thrown when necessary.
</P>

<a href="images\ch08fg02.jpg"><img src="images\tn_ch08fg02.jpg"></a><BR>
Figure 8.2
Diagram for the Node class.
</P>

<P>The Node class is illustrated in figure 8.2; all methods that can throw an exception
are shaded.
</P>

<H4><A NAME="ch08_ 7">
Implementing the Node Class
</A></H4>

<P>Refer to listings 8.2a through 8.2d, which show the code for the Node class. Note that
the quantity field is defined as an Object. This definition gives the Node class the flexibility
to hold anything that the user desires. Remember that not only is this Node class used in
the Stack and Queue classes, but you must be able to implement it in any linear
linked-list data structure you use.
</P>

<P>Listing 8.2a contains setup code for the Node class. Two private variables are used to
track
</P>

<A NAME="PAGENUM-237"><P>Page 237</P></A>


<P>
the quantity held by the current node, and also the Node that is referred to by the
current node. These values are passed to the constructor, and therefore are setup at initialization.
</P>


<P>Listing 8.2a Setting up the Node Class
</P>

<PRE>
package industrial;

 public class Node {

       //the next Node in line. is private due to the fact that we
       //only want to allow access through public methods.
       private      Node            myNextNode;

       //the value of our current quantity. can only be accessed through
       //public methods.
       private       Object            myQuantity;

       //only constructor, accepts a quantity and also a link to the next
            //node in line.
       //if this node is to stand-alone, pass in null for the nextNode
            //value.
       public Node(Node nextNode, Object quantity) {
             myNextNode = nextNode;
             myQuantity = quantity;
       }
</PRE>

<P>Listing 8.2b contains the isNextNull() method. This method is rather important because
it enables you to check whether the current node links to another node. It is less expensive
to call this method before attempting to access a node that may or may not exist, than it is
to wait until an exception is thrown while attempting to access a non-existent node.
</P>

<P>Listing 8.2b The isNextNull() Method
</P>

<PRE>
       //allow to find out if there is a next node ... without throwing
       //an exception.
       public boolean isNextNull() {
             return (myNextNode == null);
       }

</PRE>


<A NAME="PAGENUM-238"><P>Page 238</P></A>


<P>In listing 8.2c are methods that return values of Node's private member data.
</P>


<P>Listing 8.2c Methods Used to Access Node's Private Member Data
</P>


<PRE>
       //return the current quantity which this node holds

        public Object getMyQuantity() {
            return myQuantity;
      }

      //return the next node in line
      //throws NoSuchNodeException if that node does not exist
      public Node getNextNode() throws NoSuchNodeException {
             if(myNextNode == null){
                   throw new NoSuchNodeException(&quot;get next node&quot;, this);
             }
             return myNextNode;
       }

      //return the next quantity in line
      //throws NoSuchNodeException if that node does not exist
      public Node getNextQuantity() throws NoSuchNodeException {
            if(myNextNode == null) {
                  throw new NoSuchNodeException(&quot;get next quantity&quot;,
 this);
            }
            return myNextNode.getNextQuantity();
      }

</PRE>

<P>In listing 8.2d are the methods that enable altering of Node's private member data.
</P>

<P>Listing 8.2d Methods Used to Alter Node's Private Member Data
</P>
<PRE>
      //set the value of the current node
      public void setMyQuantity(Object quantity) {
            myQuantity = quantity;
      }

      //set the value of the next node in line. note this can be used
      //to set the next node to null and effectively delete a link in the
             //chain.
      public void setNextNode(Node newNode) {
            myNextNode = newNode;
      }

</PRE>


<A NAME="PAGENUM-239"><P>Page 239</P></A>


<PRE>
      //set the value of the next quantity in line.
      //throws NoSuchNodeException if there is no next node
      //to &quot;house&quot; the quantity.
      public void setNextQuantity(Object quantity) throws
             &Acirc;NoSuchNodeException {
            if(myNextNode == null) {
                  throw new NoSuchNodeException(&quot;set next value&quot;, this);
            }
            myNextNode.setMyQuantity(quantity);
      }
}
</PRE>

<H3><A NAME="ch08_ 8">
Working on the Differences<BR>
Between Stacks and Queues
</A></H3>

<P>Although the Stack and Queue classes share the same Node class, they manage that
class in unique ways. This is necessary because keeping nodes in FIFO order is different
from keeping nodes in LIFO order. The chapter first discusses what it takes to develop a
stack and then what is required for building a queue.
</P>

<H4><A NAME="ch08_ 9">
Using the Node Class to Develop a Stack
</A></H4>

<P>Although you have not yet written one line of your Stack class, you are already on the
way because you have already developed the Node class. The Node class is a building
block that is manipulated by the Stack class to provide access in LIFO fashion.
</P>

<P>The a first step in developing the Stack class is to decide on the set of features that
the class needs to support. It is relatively obvious that addition and removal of nodes
is required; however, additional features add to the functionality of the class. The full
feature set that you will implement is as follows:
</P>

<UL>
<LI>          Addition of objects to the stack (called pushing)
<LI>          Removal of items from the stack (called popping)
<LI>          Searching for a given node
</UL>

<P><CENTER>
<a href="0231-0234.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0240-0243.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



