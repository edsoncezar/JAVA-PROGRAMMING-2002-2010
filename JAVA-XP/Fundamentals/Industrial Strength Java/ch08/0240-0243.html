<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Advanced Data Structures:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0235-0239.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0244-0248.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-240"><P>Page 240</P></A>





<UL>

<LI>          Deleting any given node

<LI>          Peeking at the value of the top node

</UL>





<P>It is possible that a user might ask the last node in a stack for

the next node in line, the code in the Stack class must look for

these situations and take cautions. In the Node class exception-handling

is used to ensure that a non-existent node is never accessed. It

was necessary to add this precaution into the Node class so that users

of that class are protected.

</P>



<P>Because the Stack class will become the user of the Node class

and will take on users of its own, this exception handling must

propagate through to the Stack class. Referring back to the feature list

covered earlier in this section, four features have the capability to attempt

to access a non-existent node. These features are

</P>



<UL>

<LI>          Popping of the stack, which has the potential to cause an error if a user attempts

to pop an empty stack

<LI>          Peeking a the top node's value, which has the potential to cause an error if a

user attempts to peek at an empty stack

<LI>          Removal of a node, which has the potential to cause an error if a user attempts

to remove a node which does not exist in the stack

<LI>          Searching for a node, which has the potential to cause an error if a user attempt

to

</UL>



<P><a href="images\ch08fg03.jpg"><img src="images\tn_ch08fg03.jpg"></a><BR>

Figure 8.3

Visualizing the Stack class.

</P>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

Although deletion of a node from the middle (or end) of a

stack violates the LIFO rule, it is an enhancement that many

stacks implement. Remember that rules were meant to be broken.

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>



<A NAME="PAGENUM-241"><P>Page 241</P></A>



<UL>

find a node which does not exist

</UL>



<P>Figure 8.3 diagrams the Stack class.

</P>



<B>

Exploring the push() Method

</B>



<P>The purpose of the push() method is to add another node into the stack. This method

does not need to know whether the stack is empty or, for example, whether it already has

42

</P>



<P><a href="images\ch08fg04.jpg"><img src="images\tn_ch08fg04.jpg"></a><BR>

Figure 8.4

Pushing a new node onto the stack.

</P>





<P>nodes in it.

</P>

<P>The push() method functions by looking at the current head node, and creating a new

node that links to that head node. The head Node will then be told that it should reference

the newly created node. This process is illustrated in figure 8.4.

</P>



<B>

Exploring the pop() Method

</B>



<P>Where the push() method is charged with adding nodes to the stack, the pop()

method removes them from the stack. A non-existent node has the potential to be

referenced (when 

</P>





<A NAME="PAGENUM-242"><P>Page 242</P></A>





<P><a href="images\ch08fg05.jpg"><img src="images\tn_ch08fg05.jpg"></a><BR>

Figure 8.5

Popping a node off the stack.

</P>





<P>the stack is empty), so that you will want to test for this case and throw an

exception if necessary.

</P>



<P>The method functions by setting a temporary node to reference the head, and then

setting the head node equal to the next node in the stack. The temporary node is the return

value of this function. The pop() method is illustrated in figure 8.5.

</P>









<B>

Exploring the peek() Method

</B>



<P>A less destructive version of the pop() method is the peek() method. This method

returns the value of the head node, however, it does not actually remove the node from the

stack. Of course, if the head node is null, you will want to throw an exception.

</P>



<B>

Exploring the isEmpty() Method

</B>



<P>The isEmpty() method is a utility method that users can access to determine whether

the stack is empty. This method tests the head node to see if it is null. You will not want

this method to throw an exception because it is in place so that users can test a stack

before calling a method that could potentially throw an exception.

</P>



<B>

Exploring the delete() Method

</B>



<P>The delete() method is one of the trickier methods the Stack

class implements. As was stated previously, this method's

inclusion violates LIFO access rules, but it is a rather helpful method.

</P>



<P>The method functions on the basic principle that if you set the

node before a node that needs to be deleted to reference the node after

the 

</P>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

Each and every programmer uses different terms to

refer to objects that are helpers, or extras, to the current

application. My first computer science teacher

used the term &quot;dummy&quot; to describe any

such object (and most of the class). Other common terms

are &quot;foo&quot; and &quot;bar.&quot;

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>



<A NAME="PAGENUM-243"><P>Page 243</P></A>





<P><a href="images\ch08fg06.jpg"><img src="images\tn_ch08fg06.jpg"></a><BR>

Figure 8.6

Deletion of a node

in the stack is accomplished by &quot;linking around&quot; 

a Node.

</P>





<P>node that needs to be deleted, then the node in the middle

becomes inaccessible and is considered deleted (not to mention fair game

for garbage collection).

</P>



<P>You will create three dummy nodes, which will traverse the stack

and then be used to re-create object references. Of course you will want

to throw an exception if the node that you want to delete does not

exist. Figure 8.6 illustrates how this deletion is actually accomplished.<BR>

</P>







<B>

Exploring the find() Method

</B>



<P>The final method supported in the Stack class is a find()

method. This method functions in a manner similar to the delete()

method. This time, however, you will not be deleting a node; instead you

will return the index (starting with 1) of the node which is passed in.

If the node is not in the stack, you will throw an exception.

</P>



<H4><A NAME="ch08_ 10">

Implementing the Stack Class

</A></H4>



<P>Having discussed how all methods will be developed, you are <BR>

ready to dive in and actually code them. Listings 8.3a through

8.3d contain the Stack class.

</P>



<P>Listing 8.3a contains the constructor for the class. The

constructor accepts as a parameter a quantity for the initial node to hold.

A new node is created with this quantity.

</P>



<P>Listing 8.3a The Constructor Creates a New Node with a Query-Specified

Quantity

</P>




<PRE>

package industrial;

</PRE>


<PRE>
continues
</PRE>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

In both the delete() and find() methods, the equals() method

is used to determine whether one object equals another

object. The equals() method enables objects to

tell the stack how they are alike. Remember that using == only

returns true if the two objects in question

reference the same object.

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>



<P><CENTER>

<a href="0235-0239.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0244-0248.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







