<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Advanced Data Structures:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0253-0257.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0262-0265.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-258"><P>Page 258</P></A>



<P>Listing 8.7 Continued
</P>


<PRE>

            //delete 10
            try{ System.out.println(&quot;delete 10&quot;); myQueue.delete(new
                         &Acirc;Integer(10)); }
            catch(     NoSuchNodeException nsne) { System.out.println(&quot;err:
            &Acirc;&quot;+nsne); }
            //delete 42
            try{ System.out.println(&quot;delete 42&quot;); myQueue.delete(new
                         &Acirc;Integer(42)); }
            catch(     NoSuchNodeException nsne) { System.out.println(&quot;err:
                         &Acirc;&quot;+nsne); }
            //display the remaining nodes
            while(!myQueue.isEmpty()) {
                  try{
                        System.out.println(&quot;pop: &quot;+
                                                    &Acirc;(Integer)myQueue.pop());
                  }
                  catch(NoSuchNodeException nsne) {
                                       &Acirc;System.out.println(&quot;err: &quot;+nsne); }
            }
      }

      public static void main(String args[]) {
            Driver myDriver = new Driver();
      }
}
</PRE>

<P>The following is the output generated by the sample application in listing 8.7.
</P>

<PRE>
push: 0
push: 1
push: 2
push: 3
push: 4
push: 5
push: 6
push: 7
push: 8
push: 9
push: 10
find 12: err: industrial.NoSuchNodeException: Exception thrown due to: find
&Acirc;can not happen, node DNE
</PRE>


<A NAME="PAGENUM-259"><P>Page 259</P></A>



<PRE>
find 10: 12
delete 12
err: industrial.NoSuchNodeException: Exception thrown due to: delete can
&Acirc;not happen, node DNE
delete 0
delete 6
delete 10
delete 42
pop: 1
pop: 2
pop: 3
pop: 4
pop: 5
pop: 7
pop: 8
pop: 9
</PRE>

<H3><A NAME="ch08_ 14">
Getting a Bit More Advanced
</A></H3>

<P>You have now developed two different data structures in Java: the stack and the
queue. These data structures were written from scratch and did not use the API for any
node-tracking functions. This is all very impressive; however, the coolest part of the
development was that by spending some time on the design of the Stack class, you were able
to spend time on the design of the Queue class. You were also able to design a Node
class, which was used without modification, in both the Stack and Queue classes.
</P>

<P>So where to go from here? You have already done more than many college undergrads
do in their first class on data structures! The next (and last) data structure this chapter
helps you build is a binary search tree.
</P>

<P>Because binary search trees are not the most advanced data structures around, you
will actually use the tree to develop a rather interesting application.
</P>

<P>The inclusion of the application in a chapter on data structures is a bit radical.
Traditionally, books on data structures focus on actual code and spend little time on what
can actually be done with what you build from chapter to chapter. A few books discuss
what can be done with a data structure, but, again, it is rare to see one used in an application.
</P>

<P>This &quot;lack of inclusion&quot; by other authors is not due to a lack of desire by writers,
but rather due to space constraints. Data structures are the foundation upon which
applications are built, and building an application that takes advantage of a variety of data
structures can be a large undertaking. The application that you will write in this chapter presents
a GUI interface to a binary search tree. The application displays a series of buttons
that enable a user to manipulate the tree, and reveals a display panel that shows the contents
of the tree.
</P>

<P>This project starts with a brief introduction to binary search trees and continues with
the procedures of designing the application. To help you to focus on the data structure
apart
</P>

<A NAME="PAGENUM-260"><P>Page 260</P></A>



<P>from the user interface (UI), the tree itself is covered first, and then you will link it to
the UI. The chapter ends the building of the application with a brief discussion of its
faults and challenges you to fix them.
</P>

<H4><A NAME="ch08_ 15">
What is a Binary Search Tree?
</A></H4>

<P>In the previous sections, you built data structures that used unary nodes; those with
the potential to link to at most one other node. A binary search tree is also composed of
nodes that store some data, however, these nodes have the capability to link to two other
nodes, hence the name &quot;binary.&quot; By placing the nodes in the tree in a logical manner, speed
to find one is increased, hence the name &quot;search.&quot;
</P>


<P>This &quot;logical manner&quot; translates to keeping the nodes in order during insertion.
This explanation is discussed in greater detail as the chapter progresses.
</P>

<P>As with anything related to computer science, a binary search tree's structure is
described by many terms. Figure 8.8 shows a simple binary search tree that contains a number
of unique nodes.
</P>

<P>The node that contains the number 42 is considered the
root of the tree. In addition to being the root, it is the parent node for the nodes that contain
10 and 43. Following along logically, 42 is the grandparent to the nodes that contain 6 and 3000. Although the
nodes that contains 10 and 43 are the children of 42 they are also parent to the nodes that
contain </P>

<P><a href="images\ch08fg08.jpg"><img src="images\tn_ch08fg08.jpg"></a><BR>
Figure 8.8
The general form for a binary search tree.
</P>



<A NAME="PAGENUM-261"><P>Page 261</P></A>





<P>6 and 3000 (respectively). This family-oriented naming convention follows down
throughout the entire tree.
</P>


<P>Even more noteworthy than the names applied to each node is the placement of each
node in the tree. Every left child of a node is of a lesser value, and every right child is of
a greater value. This means that insertion will take longer than in a standard linked list,
but searching will take much less time. If, for example, you insert 100,000 random nodes
into a linked list and then want to search for a node that happens to be last in the list,
you would be forced to do about 100,000 comparisons, which is expensive and can take a
long time; however, if you had placed those same 100,000 random nodes into a binary
search tree, you would only need to log(2) 100,000 (around 16.9) comparisons to find this
same node.
</P>





<B>
Planning the Application
</B>

<P>As was stated previously, this application will be introduced in two parts&#151;first the
data structure and then the UI. To implement a bare-bones tree, the Node class needs
only some basic features:
</P>

<UL>
<LI>          It must be capable of linking to two other nodes at the most.
<LI>          It must be capable to hold a value.
<LI>          It must be capable of offering some method for determining whether it is
greater than, less than, or equal to another node.
<LI>          It must be capable of knowing its height in the tree (root node is considered
height 0)
<LI>          It must &quot;know&quot; the number of children it has.
</UL>

<P>When developing the Stack and Queue classes, the only comparison that you had to do
on each node was testing for equality against another node. However, because each node
of the binary tree is not only compared for equality but also for greater-than or
less-than conditions, a problem arises. When only testing for equality, the equals() method
(in java.lang.Object) was used, and this allowed you to let a node have a value of any
object. However, java.lang.Object does not have greater-than or less-than method; all nodes
will therefore have to use specially created methods. To provide for easier reading, the
base type &quot;int&quot; is used for the value of each node.
</P>

<B>
Developing Node-by-Node
</B>

<P>Now it's time to design the first class in this project, which will be the Node class.
Note, however, that each node is actually its own &quot;mini&quot; binary search tree. Refer to figure
8.8
</P>



<P><CENTER>
<a href="0253-0257.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0262-0265.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



