<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Advanced Data Structures:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0249-0252.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0258-0261.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-253"><P>Page 253</P></A>





<P>up to refer to this new node.

</P>



<P>Listing 8.6a The Constructor for the Queue Class

</P>




<PRE>

package industrial;



 //class to implement a FIFO queue

 public class Queue {

       private Node head = null; //will reference the beginning of the

                                 //queue deletions will be based on this

       private Node tail = null; //point will reference the end of the

         //queue insertions will be based on this point

         //generic constructor, takes a object as its parameter and

         //creates a new node which contains this quantity.

         //both the head and tail references are set to look at this

         //node

       public Queue(Object quantity) {

             head = new Node(null, quantity);

             tail = head;

       }

</PRE>




<P>In listing 8.6b is the push() method. This method functions by first testing to see if

the queue is empty. If the queue is empty a new queue is created. Otherwise a new node

is attached to the end of the queue, and the tail reference is moved down one node.

</P>



<P>Listing 8.6b The push() Method Adds a New Node to the Queue

</P>




<PRE>

       //push will add a new node onto the queue. this is done by

       //tacking a new node onto the queue and moving the tail

       //reference down one. the special case where the queue is empty

       //or where it contains one node is take care of by the first

       //conditional.

         public void push(Object quantity) {

             //does our queue contain one node? or is it empty?

             if(tail == head || tail == null) {

                  tail = new Node(null, quantity);

                  head.setNextNode(tail);

            }

            //there is more than one node in out queue

            else {



</PRE>




<A NAME="PAGENUM-254"><P>Page 254</P></A>








<PRE>





                  Node myNode = new Node(tail, quantity);

                  tail.setNextNode(myNode);

                  tail = myNode;

            }

    }

</PRE>




<P>In listing 8.6c are the pop() and peek() methods. Both function by referring the top

node on the queue, however, the pop() method additionally will delete the top node on

the queue. In both methods, if the user attempts to call one on an empty queue, an

exception will be generated.

</P>





<P>Listing 8.6c The pop() Method Removes the Top Node from the Queue

</P>




<PRE>

       //pop will remove the top node from the queue by setting a

       //temp node equal to the node referenced by head, setting

       //the head node equal to the next node in line, and then

       //returning the temp node. if the queue is empty an

       //exception will be thrown.



       public Object pop() throws NoSuchNodeException {

             Node temp = null;



             if(head == tail) {

                   throw new NoSuchNodeException(&quot;queue empty&quot;, this);

             }

             else {

                    temp = head;

                   head = head.getNextNode();

             }

            return temp.getMyQuantity();

       }



       //peek will return the object held by the node referenced by

       //head. if the queue is empty, an exception

       //will be thrown

       public Object peek() throws NoSuchNodeException {

             if(head == tail) {

                   throw new NoSuchNodeException(&quot;queue empty&quot;, this);

             }

             return head.getMyQuantity();

       }



</PRE>




<P>Listing 8.6d begins by introducing the isEmpty() method, which returns true if the

head and tail nodes reference each other. Additionally, the

delete() and find() methods traverse the queue until either the node needed is found, or the end of queue is reached. If the

end

</P>



<A NAME="PAGENUM-255"><P>Page 255</P></A>





<P>is reached and the desired node has not been found, the exception will be thrown. If

the node is found, the delete() method will link around the found node, and the find()

method will return the index of the found node.

</P>



<P>Listing 8.6d The isEmpty() Method Enables a User to Test Whether the Queue

Contains Elements.

</P>






<PRE>

//The delete() and find() methods traverse the queue looking for a

//specific node, and they the perform a task similar to their name,

           public boolean isEmpty() {

              return (head == tail);

       }



       //delete will remove a node from the queue by &quot;linking around&quot;

       //that node. if the node does not exist

       //anywhere in the queue then an exception will be thrown

       public void delete(Object deleteMe) throws NoSuchNodeException {

             Node dummyNode0 = head;

             Node dummyNode1 = head;

             Node dummyNode2 = head.getNextNode();



             //are we attempting to delete the first node

             if(deleteMe.equals(head.getMyQuantity())) {

                   head = head.getNextNode();

                   return;

             }



            while(!deleteMe.equals(dummyNode1.getMyQuantity()) &amp;&amp;

            //(dummyNode2 != tail)) {

                  dummyNode0 = dummyNode1;

                  dummyNode1 = dummyNode2;

                  dummyNode2 = dummyNode2.getNextNode();

            }

            //does dummyNode1 reference the node which we want to delete

            if(deleteMe.equals(dummyNode1.getMyQuantity())) {

                  dummyNode0.setNextNode(dummyNode2);

            }

            //is the node which we want to delete the last node in the

            //chain

            else

             if(deleteMe.equals(dummyNode1.getNextNode()-

            .getMyQuantity())) { dummyNode1 = tail;



</PRE>


<PRE>
continues
</PRE>






<A NAME="PAGENUM-256"><P>Page 256</P></A>





<P>Listing 8.6d Continued

</P>




<PRE>



            }

            //if dummyNode1 does not reference the node which we want to

            //delete and the next node in the chain is not the node

            //which we want



          //to delete then our node does not exist and we should throw

          //an exception

            else {

                  throw new NoSuchNodeException(&quot;delete can not happen,

 node DNE&quot;, this);

            }

      }



       //find will search for a node in a manner similar to the manner

       //that delete searched for the node.



       //however here we will return an integer that indicates the index

       //(starting with 1) of that node in our queue. If the node does

       //not exist in the queue then an exception will be thrown.

       public int find(Object findMe) throws NoSuchNodeException {

             int counter = 1;

             Node dummyNode = head;

             while(!findMe.equals(dummyNode.getMyQuantity())) {

                   counter++;

                   if(dummyNode != tail) {

                          dummyNode = dummyNode.getNextNode();

                   }

                   else {

                        throw new NoSuchNodeException(&quot;find can not happen,

                        &Acirc;node DNE&quot;, this);

                   }

             }

             return counter;

       }

 }

</PRE>




<H4><A NAME="ch08_ 13">

Testing the Queue Class

</A></H4>



<P>By now you should have studied the class and should be ready to implement it in

your next big project. If for some reason you had trouble with the class, take a look at the

driver in listing 8.7 and the output generated by the driver given in listing 8.8. That driver is

the one used when testing the Queue class and proves that all methods work when an

</P>



<A NAME="PAGENUM-257"><P>Page 257</P></A>







<P>exception does or does not occur.

</P>





<P>Listing 8.7 A Driver Used for the Class in Listing 8.6

</P>




<PRE>

import industrial.*;

public class Driver {

      private Queue myQueue;

      public Driver() {

            //create a new queue

            myQueue = new Queue(new Integer(42));

            //push on a series of Integers

            for(int i=0; i&lt;=10; i++) {

                  System.out.println(&quot;push: &quot;+ i);

                  myQueue.push(new Integer(i));

            }



            //try to find 12

            try{       System.out.print(&quot;find 12: &quot;);

                        System.out.println(myQueue.find(new Integer(12)));

                  }

            catch(     NoSuchNodeException nsne)

                          &Acirc;{ System.out.println(&quot;err:&quot;+nsne); }

            //find 10

            try{       System.out.print(&quot;find 10: &quot;);

                        System.out.println(myQueue.find(new Integer(10)));

                  }

            catch(     NoSuchNodeException nsne)

                          &Acirc;{ System.out.println(&quot;err:&quot;+nsne); }



           //try to delete 12

            try{ System.out.println(&quot;delete 12&quot;); myQueue.delete(new

                          &Acirc;Integer(12)); }

            catch(     NoSuchNodeException nsne)

                          &Acirc;{ System.out.println(&quot;err:&quot;+nsne); }

            //delete 0

            try{ System.out.println(&quot;delete 0&quot;); myQueue.delete

                          &Acirc;(new Integer(0)); }

            catch(     NoSuchNodeException nsne){System.out.println(&quot;err:

                          &Acirc;&quot;+nsne); }

            //delete 6

            try{ System.out.println(&quot;delete 6&quot;); myQueue.delete

                          &Acirc;(new Integer(6)); }

            catch(     NoSuchNodeException nsne) { System.out.println(&quot;err:

                          &Acirc;&quot;+nsne); }

</PRE>


<PRE>
continues
</PRE>






<P><CENTER>

<a href="0249-0252.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0258-0261.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







