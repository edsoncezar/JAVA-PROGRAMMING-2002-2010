<HTML>
<HEAD>
<TITLE>M-Way Search Trees</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF">
 <img src="..\icons\cover75.gif" alt="Cover" align=right>
<b>Data Structures and Algorithms 
with Object-Oriented Design Patterns in Java</b><br>
<A NAME="tex2html5964" HREF="page330.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html5962" HREF="page298.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html5956" HREF="page328.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html5966" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html5967" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <BR><HR>
<H1><A NAME="SECTION0011600000000000000000"><I>M</I>-Way Search Trees</A></H1>
<P>
As defined in Section&nbsp;<A HREF="page300.html#secsrchtreemwaytree"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>,
an internal node of an <I>M</I>-way search tree contains <I>n</I> subtrees and <I>n</I>-1 keys,
where  <IMG WIDTH=75 HEIGHT=26 ALIGN=MIDDLE ALT="tex2html_wrap_inline63248" SRC="img1183.gif"  >, for some fixed value of  <IMG WIDTH=44 HEIGHT=26 ALIGN=MIDDLE ALT="tex2html_wrap_inline64160" SRC="img1306.gif"  >.
The preceding sections give implementations for the special case
in which the fixed value of <I>M</I>=2 is assumed (binary search trees).
In this section,
we consider the implementation of <I>M</I>-way search trees
for <em>arbitrary</em>, larger values of  <IMG WIDTH=48 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline64166" SRC="img1307.gif"  >.
<P>
Why are we interested in larger values of <I>M</I>?
Suppose we have a very large data set--so large that we cannot get it all into
the main memory of the computer at the same time.
In this situation we implement the search tree in secondary storage,
i.e., on disk.
The unique characteristics of disk-based storage
<em>vis-&#224;-vis</em> memory-based storage
make it necessary to use larger values of <I>M</I>
in order to implement search trees efficiently.
<P>
The typical disk access time is 1-10&nbsp;ms,
whereas the typical main memory access time is 10-100&nbsp;ns.
Thus, main memory accesses are between 10000 and 1000000 times
faster than typical disk accesses.
Therefore to maximize performance,
it is imperative that the total number of disk accesses be minimized.
<P>
In addition, disks are block-oriented devices.
Data are transfered between main memory and disk in large blocks.
The typical block sizes are between 512&nbsp;bytes and 4096&nbsp;bytes.
Consequently, it makes sense to organize the data structure to take advantage
of the ability to transfer entire blocks of data efficiently.
<P>
By choosing a suitably large value for <I>M</I>,
we can arrange that one node of an <I>M</I>-way search tree
occupies an entire disk block.
If every internal node in the <I>M</I>-way search tree has exactly <I>M</I> children,
we can use Theorem&nbsp;<A HREF="page257.html#theoremtreesii"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> to
determine the height of the tree:
<P><A NAME="eqnsrchtreemway">&#160;</A> <IMG WIDTH=500 HEIGHT=17 ALIGN=BOTTOM ALT="equation20241" SRC="img1308.gif"  ><P>
where <I>n</I> is the number of internal nodes in the search tree.
A node in an <I>M</I>-way search tree that has <I>M</I> children
contains exactly <I>M</I>-1 keys.
Therefore, altogether there are <I>K</I>=(<I>M</I>-1)<I>n</I> keys and
Equation&nbsp;<A HREF="page329.html#eqnsrchtreemway"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> becomes
 <IMG WIDTH=159 HEIGHT=26 ALIGN=MIDDLE ALT="tex2html_wrap_inline64190" SRC="img1309.gif"  >.
Ideally the search tree is well balanced
and the inequality becomes an equality.
<P>
For example, consider a search tree which contains  <IMG WIDTH=97 HEIGHT=12 ALIGN=BOTTOM ALT="tex2html_wrap_inline64192" SRC="img1310.gif"  > keys.
Suppose the size of a disk block is such that we can fit
a node of size <I>M</I>=128 in it.
Since each node contains at most 127 keys,
at least 16513 nodes are required.
In the best case, the height of the <I>M</I>-way search tree is only two
and at most three disk accesses are required to retrieve any key!
This is a significant improvement over a binary tree,
the height of which is at least 20.
<P>
<BR> <HR>
<UL> 
<LI> <A NAME="tex2html5968" HREF="page330.html#SECTION0011610000000000000000">Implementing <I>M</I>-Way Search Trees</A>
<LI> <A NAME="tex2html5969" HREF="page334.html#SECTION0011620000000000000000">Finding Items in an <I>M</I>-Way Search Tree</A>
<LI> <A NAME="tex2html5970" HREF="page337.html#SECTION0011630000000000000000">Inserting Items into an <I>M</I>-Way Search Tree</A>
<LI> <A NAME="tex2html5971" HREF="page338.html#SECTION0011640000000000000000">Removing Items from an <I>M</I>-Way Search Tree</A>
</UL>
<HR><A NAME="tex2html5964" HREF="page330.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html5962" HREF="page298.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html5956" HREF="page328.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html5966" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html5967" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <P><ADDRESS>
<img src="..\icons\bruno.gif" alt="Bruno" align=right>
<a href="..\copyright.html">Copyright &#169; 1998</a> by <a href="..\signature.html">Bruno R. Preiss, P.Eng.</a>  All rights reserved.

</ADDRESS>
</BODY>
</HTML>
