<HTML>
<HEAD>
<TITLE>Performance Data</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF">
 <img src="..\icons\cover75.gif" alt="Cover" align=right>
<b>Data Structures and Algorithms 
with Object-Oriented Design Patterns in Java</b><br>
<A NAME="tex2html8262" HREF="page517.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html8260" HREF="page478.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html8254" HREF="page515.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html8264" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html8265" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <BR><HR>
<H1><A NAME="SECTION0016900000000000000000">Performance Data</A></H1>
<P>
In order to better understand the actual performance
of the various sorting algorithms presented in this chapter,
it is necessary to conduct some experiments.
Only by conducting experiments is it possible to determine
the relative performance of algorithms
with the same asymptotic running time.
<P>
To measure the performance of a sorting algorithm,
we need to provide it with some data to sort.
To obtain the results presented here,
random sequences of integers were sorted.
That is, for each value of <I>n</I>,
the <tt>RandomNumberGenerator</tt> class defined in Section&nbsp;<A HREF="page465.html#secalgsrng"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>
was used to create a sequence of <I>n</I> integers.
In all cases (except for bucket sort)
the random numbers are uniformly distributed
in the interval  <IMG WIDTH=70 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline69463" SRC="img2156.gif"  >.
For the bucket sort the numbers are uniformly distributed in  <IMG WIDTH=71 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline69465" SRC="img2157.gif"  >.
<P>
Figures&nbsp;<A HREF="page516.html#figsorting1"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>, <A HREF="page516.html#figsorting2"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> and&nbsp;<A HREF="page516.html#figsorting3"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> show the actual running times
of the sorting algorithms presented in this chapter.
These running times were measured on a Sun SPARCstation&nbsp;5,
Model&nbsp;85, which has an 85&nbsp;MHz clock and 32MB RAM
under the Solaris&nbsp;2.5 operating system.
The programs were compiled using the Solaris Java Platform&nbsp;1.1
compiler (<tt>javac</tt>)
and run under the Java interpreter (<tt>java</tt>).
The times shown are user CPU times, measured in seconds.
<P>
Figure&nbsp;<A HREF="page516.html#figsorting1"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> shows the running times of the  <IMG WIDTH=39 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline58122" SRC="img258.gif"  > sorts
for sequences of length <I>n</I>,  <IMG WIDTH=101 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline69471" SRC="img2158.gif"  >.
Notice that the bubble sort has the worst performance
and that the binary insertion sort has the best performance.
Figure&nbsp;<A HREF="page516.html#figsorting1"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> clearly shows that, as predicted,
binary insertion is better than straight insertion.
Notice too that all of the  <IMG WIDTH=39 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline58122" SRC="img258.gif"  > sorts require more than 5 seconds
of execution time to sort an array of 2000 integers.
<P>
<P><A NAME="46661">&#160;</A><A NAME="figsorting1">&#160;</A> <IMG WIDTH=575 HEIGHT=417 ALIGN=BOTTOM ALT="figure45987" SRC="img2159.gif"  ><BR>
<STRONG>Figure:</STRONG> Actual running times of the  <IMG WIDTH=39 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline58122" SRC="img258.gif"  > sorts.<BR>
<P>
<P>
The performance of the  <IMG WIDTH=68 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline58846" SRC="img402.gif"  > sorts is shown in Figure&nbsp;<A HREF="page516.html#figsorting2"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>.
In this case, the length of the sequence varies between <I>n</I>=10
and  <IMG WIDTH=73 HEIGHT=12 ALIGN=BOTTOM ALT="tex2html_wrap_inline69585" SRC="img2160.gif"  >.
The graph clearly shows that the  <IMG WIDTH=68 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline58846" SRC="img402.gif"  > algorithms are significantly
faster that the  <IMG WIDTH=39 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline58122" SRC="img258.gif"  > ones.
All three algorithms sort 10000 integers in under 5 seconds.
Clearly, merge sort is the best of the three,
with quicksort not that far behind.
<P>
<P><A NAME="46852">&#160;</A><A NAME="figsorting2">&#160;</A> <IMG WIDTH=575 HEIGHT=400 ALIGN=BOTTOM ALT="figure46665" SRC="img2161.gif"  ><BR>
<STRONG>Figure:</STRONG> Actual running times of the  <IMG WIDTH=68 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline58846" SRC="img402.gif"  > sorts.<BR>
<P>
<P>
Figure&nbsp;<A HREF="page516.html#figsorting3"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> shows the actual running times for the bucket sort
and radix sort algorithms.
Both these algorithms were shown to be <I>O</I>(<I>n</I>) sorts.
The graph shows results for <I>n</I> between 10 and  <IMG WIDTH=49 HEIGHT=12 ALIGN=BOTTOM ALT="tex2html_wrap_inline69729" SRC="img2162.gif"  >.
The universe used to test bucket sort was  <IMG WIDTH=106 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline69731" SRC="img2163.gif"  >.
That is, a total of <I>m</I>=1024 counters (buckets) were used.
For the radix sort, 32-bit integers were sorted by using the radix <I>R</I>=256
and doing <I>p</I>=4 sorting passes.
<P>
<P><A NAME="47067">&#160;</A><A NAME="figsorting3">&#160;</A> <IMG WIDTH=575 HEIGHT=383 ALIGN=BOTTOM ALT="figure46856" SRC="img2164.gif"  ><BR>
<STRONG>Figure:</STRONG> Actual running times of the <I>O</I>(<I>n</I>) sorts.<BR>
<P>
<P>
Clearly, the bucket sort has the best running time.
For example, it sorts 100000 10-bit integers in about 3 seconds.
Radix sort performs extremely well too.
It sorts 100000 32-bit integers in about 7 seconds,
roughly a factor of two slower than the bucket sort.
<P>
<HR><A NAME="tex2html8262" HREF="page517.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html8260" HREF="page478.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html8254" HREF="page515.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html8264" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html8265" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <P><ADDRESS>
<img src="..\icons\bruno.gif" alt="Bruno" align=right>
<a href="..\copyright.html">Copyright &#169; 1998</a> by <a href="..\signature.html">Bruno R. Preiss, P.Eng.</a>  All rights reserved.

</ADDRESS>
</BODY>
</HTML>
