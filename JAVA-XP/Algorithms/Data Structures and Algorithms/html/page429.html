<HTML>
<HEAD>
<TITLE>Handles</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF">
 <img src="..\icons\cover75.gif" alt="Cover" align=right>
<b>Data Structures and Algorithms 
with Object-Oriented Design Patterns in Java</b><br>
<A NAME="tex2html7193" HREF="page430.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html7191" HREF="page428.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html7187" HREF="page428.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html7195" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html7196" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <BR><HR>
<H2><A NAME="SECTION0014510000000000000000">Handles</A></H2>
<P>
The Java virtual machine specification does not prescribe
how reference variables are implemented.
A common approach is for a reference variable to be implemented
as an index into an array of object <em>handles</em><A NAME=31150>&#160;</A>.
Every object instance has its own handle.
The handle for an object typically contains a reference to
a <tt>Class</tt> instance that describes the type of the object
and a pointer to the region in the heap where the object data resides.
<P>
The advantage of using handles is that when the position in the heap
of an object is changed,
only the handle for that object needs to be modified.
All other references to that object are unaffected
because such references actually refer to the handle.
The cost of using handles is that the handle must be dereferenced
every time an object is accessed.
<P>
The mark-and-compact algorithm uses the handles in two ways:
First, the <tt>marked</tt> flags which are set during the mark operation
are stored in the handles rather than in the objects themselves.
Second, compaction is greatly simplified because when an object is moved
only its handle needs to be updated--all other objects are unaffected.
<P>
Figure&nbsp;<A HREF="page429.html#fighandles"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> illustrates how object references
are implemented using handles.
Figure&nbsp;<A HREF="page429.html#fighandles"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>&nbsp;(a) shows a circular, singly-linked list
as it is usually drawn
and Figure&nbsp;<A HREF="page429.html#fighandles"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>&nbsp;(b) shows how the list
is represented when using handles.
Each reference variable actually contains an index into the array of handles.
For example, the <tt>head</tt> variable selects the handle at offset 2
and that handle points to linked list element <I>A</I>.
Similarly, the <tt>next</tt> field of list element <I>A</I> selects
the handle at offset 5 which refers to list element <I>B</I>.
Notice that when an object is moved, only its handle needs to be modified.
<P>
<P><A NAME="31604">&#160;</A><A NAME="fighandles">&#160;</A> <IMG WIDTH=575 HEIGHT=313 ALIGN=BOTTOM ALT="figure31158" SRC="img1710.gif"  ><BR>
<STRONG>Figure:</STRONG> Representing object references using handles.<BR>
<P>
<P>
The handle is a convenient place in which to record information
used by the garbage collection algorithm.
For example,
we add a <tt>boolean</tt> field to each handle, called <tt>marked</tt>.
The <tt>marked</tt> field is used to mark live objects as follows:
<PRE>void mark (Object p)
<P>
    if (!handle[p].marked)
<P>
        handle[p].marked = true;
        <em>for each</em> Object q <em>referenced by</em> p
            mark (q);
<P>
</PRE>
Notice that this version of the <tt>mark</tt> method
marks the object handles rather than the objects themselves.
<P>
Once all of the live objects in the heap have been identified,
the heap needs to be defragemented.
Perhaps the simplest way to defragment the heap
is to <em>slide</em><A NAME=31616>&#160;</A> the objects in the heap
all to one end, removing the unused memory locations separating them.
The following version of the <tt>compact</tt> method does just this:
<PRE>void compact ()
<P>
    long offset = 0;
    <em>for each</em> Object p <em>in the heap</em>
<P>
        if (handle[p].marked)
<P>
            handle[p].object = heap.move (p, offset);
            handle[p].marked = false;
            offset += sizeof (p);
<P>
</PRE>
This algorithm makes a single pass through the objects in the heap,
moving the live objects towards the lower heap addresses as it goes.
The <tt>compact</tt> method only modifies the object handles--object data remain unchanged.
This algorithm also illustrates an important characteristic of
the sliding compaction algorithm--the relative positions of the objects in the heap remains unchanged
after the compaction operation.
Also, when the compaction method has finished,
the <tt>marked</tt> fields have all been set back to <tt>false</tt>
in preparation for the next garbage collection operation.
<P>
<HR><A NAME="tex2html7193" HREF="page430.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html7191" HREF="page428.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html7187" HREF="page428.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html7195" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html7196" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <P><ADDRESS>
<img src="..\icons\bruno.gif" alt="Bruno" align=right>
<a href="..\copyright.html">Copyright &#169; 1998</a> by <a href="..\signature.html">Bruno R. Preiss, P.Eng.</a>  All rights reserved.

</ADDRESS>
</BODY>
</HTML>
