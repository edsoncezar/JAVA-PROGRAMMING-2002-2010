<HTML>
<HEAD>
<TITLE>Removing Items</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF">
 <img src="..\icons\cover75.gif" alt="Cover" align=right>
<b>Data Structures and Algorithms 
with Object-Oriented Design Patterns in Java</b><br>
<A NAME="tex2html4946" HREF="page248.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html4944" HREF="page243.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html4940" HREF="page246.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html4948" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html4949" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <BR><HR>
<H3><A NAME="SECTION009644000000000000000">Removing Items</A></H3>
<P>
Removing items from a scatter table using
open addressing has to be done with some care.
The na&#239;ve approach would be to locate the item to be removed
and then change the state of its location to <tt>empty</tt>.
However, that approach does not work!
Recall that the <tt>findMatch</tt> method which is used to locate an item
stops its search when it encounters an <tt>empty</tt> cell.
Therefore, if we change the state of a cell in the middle of a cluster
to <tt>empty</tt>,
all subsequent searches in that cluster will stop at the empty cell.
As a result, subsequent searches for an object may fail
even when the target is still in the table!
<P>
One way to deal with this is to make use of the third state, <tt>deleted</tt>.
Instead of marking a location <tt>empty</tt>,
we mark it <tt>deleted</tt> when an item is deleted.
Recall that that the <tt>findMatch</tt> method was written in such a
way that it continues past deleted cells in its search.
Also, the <tt>findUnoccupied</tt> method was written to stop its
search when it encounters either an <tt>empty</tt> or a <tt>deleted</tt> location.
Consequently, the positions marked <tt>deleted</tt> are available
for reuse when insertion is done.
<P>
Program&nbsp;<A HREF="page247.html#progOpenScatterTablee"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> gives the implementation of the <tt>withdraw</tt>.
The <tt>withdraw</tt> method takes a <tt>Comparable</tt> object
and removes that object from the scatter table.
It does so by first locating the specific object instance
using <tt>findInstance</tt> and then marking the location <tt>deleted</tt>.
The implementation of <tt>findInstance</tt> has been elided.
It is simply a trivial variation of the <tt>findMatch</tt> method.
<P>
<P><A NAME="13560">&#160;</A><A NAME="progOpenScatterTablee">&#160;</A> <IMG WIDTH=575 HEIGHT=371 ALIGN=BOTTOM ALT="program13324" SRC="img1014.gif"  ><BR>
<STRONG>Program:</STRONG> <tt>OpenScatterTable</tt> Class <tt>withdraw</tt> method.<BR>
<P>
<P>
The running time of the <tt>withdraw</tt> method is determined
by that of <tt>findInstance</tt>.
In the worst case <tt>findInstance</tt> has to examine every array position.
Therefore, the running time of <tt>withdraw</tt> is
 <IMG WIDTH=133 HEIGHT=26 ALIGN=MIDDLE ALT="tex2html_wrap_inline61830" SRC="img964.gif"  >.
<P>
There is a very serious problem with the technique of marking
locations as <tt>deleted</tt>.
After a large number of insertions and deletions have been done,
it is very likely that there are no cells left that are marked <tt>empty</tt>.
This is because, nowhere in any of the methods (except <tt>purge</tt>)
is a cell ever marked <tt>empty</tt>!
This has the very unfortunate consequence that an unsuccessful search,
i.e., a search for an object which is not in the scatter table,
is  <IMG WIDTH=39 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline62090" SRC="img1015.gif"  >.
Recall that <tt>findMatch</tt> examines at most <I>M</I> array locations
and only stops its search early when an <tt>empty</tt> location is encountered.
Since there are no more empty locations,
the search must examine all <I>M</I> locations.
<P>
If we are using the scatter table in an application in which
we know <em>a priori</em> that no items will be removed,
or perhaps only a very small number of items will be removed,
then the <tt>withdraw</tt> method given in Program&nbsp;<A HREF="page246.html#progOpenScatterTabled"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>
will suffice.
However, if the application is such that a significant number of
withdrawals will be made,
a better implementation is required.
<P>
Ideally, when removing an item the scatter table ends up
exactly as it would have appeared
had that item never been inserted in the first place.
Note that exactly the same constraint is met by the <tt>withdraw</tt>
method for the <tt>ChainedScatterTable</tt> class given
in Program&nbsp;<A HREF="page236.html#progChainedScatterTabled"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>.
It turns out that a variation of that algorithm can be
used to implement the <tt>withdraw</tt> method
for the <tt>OpenScatterTable</tt> class
as shown in Program&nbsp;<A HREF="page247.html#progOpenScatterTableV2a"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>.
<P>
<P><A NAME="13562">&#160;</A><A NAME="progOpenScatterTableV2a">&#160;</A> <IMG WIDTH=575 HEIGHT=657 ALIGN=BOTTOM ALT="program13352" SRC="img1016.gif"  ><BR>
<STRONG>Program:</STRONG> <tt>OpenScatterTableV2</tt> <tt>withdraw</tt> method.<BR>
<P>
<P>
The algorithm begins by checking that the scatter table is not empty.
Then it calls <tt>findInstance</tt> to determine
the position <tt>i</tt> of the item to be removed.
If the item to be removed is not in the scatter table
<tt>findInstance</tt> returns -1 and an exception is thrown.
Otherwise, <tt>findInstance</tt> falls between 0 and <I>M</I>-1,
which indicates that the item was found.
<P>
In the general case,
the item to be deleted falls in the middle of a cluster.
Deleting it would create a hole in the middle of the cluster.
What we need to do is to find another item further down in the cluster
which can be moved up to fill in the hole that would be created
when the item at position <tt>i</tt> is deleted.
The purpose of the loop on lines&nbsp;14-22
is to find the position <tt>j</tt> of an item which can be
moved safely into position <tt>i</tt>.
Note the implementation here implicitly assumes that
a linear probing sequence is used--the <tt>c</tt> method is not called explicitly.
An item at position <tt>j</tt> can be moved safely to position <tt>i</tt>
only if the hash value of the item at position <tt>j</tt>
is not cyclically contained in the interval between <tt>i</tt> and <tt>j</tt>.
<P>
If an item is found at some position <tt>j</tt> that can be moved safely,
then that item is moved to position <tt>i</tt> on lines&nbsp;25-26.
The effect of moving the item at position <tt>j</tt> to position <tt>i</tt>,
is to move the hole from position <tt>i</tt> to position <tt>j</tt> (line&nbsp;27).
Therefore, another iteration of the main loop (lines&nbsp;12-28) is needed
to fill in the relocated hole in the cluster.
<P>
If no item can be found to fill in the hole,
then it is safe to split the cluster in two.
Eventually, either because no item can be found to fill in the hole
or because the hole has moved to the end of the cluster,
there is nothing more to do other than to delete the hole.
Thus, on lines&nbsp;29-30 the entry at position <tt>i</tt> is set
to <tt>empty</tt> and the associated <tt>object</tt> is set to <tt>null</tt>.
Notice that the third state <tt>deleted</tt> is not required
in this implementation of <tt>withdraw</tt>.
<P>
If we use the <tt>withdraw</tt> implementation of Program&nbsp;<A HREF="page247.html#progOpenScatterTableV2a"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>,
the scatter table entries will only ever be in one
of two two states--<tt>occupied</tt> or <tt>empty</tt>.
Consequently, we can improve the bound on the worst-case for the search from
 <IMG WIDTH=211 HEIGHT=26 ALIGN=MIDDLE ALT="tex2html_wrap_inline62086" SRC="img1013.gif"  > to
 <IMG WIDTH=204 HEIGHT=26 ALIGN=MIDDLE ALT="tex2html_wrap_inline62104" SRC="img1017.gif"  >,
where <I>n</I> is the number of items in the scatter table.
<P>
Determining the running time of Program&nbsp;<A HREF="page247.html#progOpenScatterTableV2a"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>
is a little tricky.
Assuming the item to be deleted is actually in the table,
the running time to find the position of that item (line&nbsp;8) is
 <IMG WIDTH=126 HEIGHT=26 ALIGN=MIDDLE ALT="tex2html_wrap_inline61730" SRC="img937.gif"  >,
where  <IMG WIDTH=72 HEIGHT=9 ALIGN=BOTTOM ALT="tex2html_wrap_inline60196" SRC="img675.gif"  > is the number of item actually in the scatter table.
In the worst case,
the scatter table is comprised of a single cluster of <I>n</I> items,
and we are deleting the first item of the cluster.
In this case,
the main loop on lines&nbsp;12-28 makes a pass through the entire cluster,
in the worst case moving the hole to the end of the cluster one position
at at time.
Thus, the running time of the main loop is  <IMG WIDTH=173 HEIGHT=26 ALIGN=MIDDLE ALT="tex2html_wrap_inline62114" SRC="img1018.gif"  >.
The remaining lines require a constant amount of additional time.
Altogether, the running time for the <tt>withdraw</tt> method is
 <IMG WIDTH=135 HEIGHT=26 ALIGN=MIDDLE ALT="tex2html_wrap_inline62116" SRC="img1019.gif"  > in the worst case.
<P>
<HR><A NAME="tex2html4946" HREF="page248.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html4944" HREF="page243.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html4940" HREF="page246.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html4948" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html4949" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <P><ADDRESS>
<img src="..\icons\bruno.gif" alt="Bruno" align=right>
<a href="..\copyright.html">Copyright &#169; 1998</a> by <a href="..\signature.html">Bruno R. Preiss, P.Eng.</a>  All rights reserved.

</ADDRESS>
</BODY>
</HTML>
