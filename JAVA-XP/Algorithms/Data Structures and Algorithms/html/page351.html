<HTML>
<HEAD>
<TITLE>Basics</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF">
 <img src="..\icons\cover75.gif" alt="Cover" align=right>
<b>Data Structures and Algorithms 
with Object-Oriented Design Patterns in Java</b><br>
<A NAME="tex2html6237" HREF="page352.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html6235" HREF="page350.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html6229" HREF="page350.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html6239" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html6240" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <BR><HR>
<H1><A NAME="SECTION0012100000000000000000">Basics</A></H1>
<P>
A priority queue is a container which provides the following three operations:
<DL ><DT><STRONG><tt>enqueue</tt></STRONG>
<DD>
	used to put objects into the container;
    <DT><STRONG><tt>findMin</tt></STRONG>
<DD>
	returns the smallest object in the container; and
    <DT><STRONG><tt>dequeueMin</tt></STRONG>
<DD>
	removes the smallest object from the container.
<P>
 </DL>
A priority queue is used to store a finite set of keys
drawn from a totally ordered set of keys <I>K</I>.
As distinct from search trees,
duplicate keys <em>are</em> allowed in priority queues.
<P>
Program&nbsp;<A HREF="page351.html#progPriorityQueuea"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> defines the <tt>PriorityQueue</tt> interface.
The <tt>PriorityQueue</tt> interface extends the <tt>Container</tt> interface
defined in Program&nbsp;<A HREF="page118.html#progContainera"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>.
In addition to the inherited methods,
the <tt>PriorityQueue</tt> interface comprises
the three methods listed above.
<P>
<P><A NAME="23218">&#160;</A><A NAME="progPriorityQueuea">&#160;</A> <IMG WIDTH=575 HEIGHT=141 ALIGN=BOTTOM ALT="program23139" SRC="img1387.gif"  ><BR>
<STRONG>Program:</STRONG> <tt>PriorityQueue</tt> interface.<BR>
<P>
<P>
Program&nbsp;<A HREF="page351.html#progMergeablePriorityQueuea"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> defines the
<tt>MergeablePriorityQueue</tt> interface.
The <tt>MergeablePriorityQueue</tt> interface extends
the <tt>PriorityQueue</tt> interface defined in Program&nbsp;<A HREF="page351.html#progPriorityQueuea"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>.
A <em>mergeable priority queue</em><A NAME=23158>&#160;</A><A NAME=23159>&#160;</A>
is one which provides the ability to
merge efficiently two priority queues into one.
Of course it is always possible to merge two priority queues
by dequeuing the elements of one queue
and enqueueing them in the other.
However, the mergeable priority queue implementations we will consider
allow more efficient merging than this.
<P>
<P><A NAME="23223">&#160;</A><A NAME="progMergeablePriorityQueuea">&#160;</A> <IMG WIDTH=575 HEIGHT=103 ALIGN=BOTTOM ALT="program23160" SRC="img1388.gif"  ><BR>
<STRONG>Program:</STRONG> <tt>MergeablePriorityQueue</tt> interface.<BR>
<P>
<P>
It is possible to implement the required functionality
using data structures that we have already considered.
For example, a priority queue can be implemented simply as a list.
If an <em>unsorted list</em><A NAME=23170>&#160;</A> is used,
enqueueing can be accomplished in constant time.
However, finding the minimum and removing the minimum each require <I>O</I>(<I>n</I>) time
where <I>n</I> is the number of items in the queue.
On the other hand,
if a <em>sorted list</em><A NAME=23172>&#160;</A> is used,
finding the minimum and removing it is easy--both operations can be done in constant time.
However, enqueueing an item in a sorted list requires <I>O</I>(<I>n</I>) time.
<P>
Another possibility is to use a search tree.
For example, if an <em>AVL tree</em><A NAME=23174>&#160;</A> is used
to implement a priority queue,
then all three operations can be done in  <IMG WIDTH=55 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline58840" SRC="img400.gif"  > time.
However, search trees provide more functionality than we need.
Search trees support finding the largest item with <tt>findMax</tt>,
deletion of arbitrary objects with <tt>withdraw</tt>,
and the ability to visit in order all the contained objects
via <tt>depthFirstTraversal</tt>.
All these operations can be done as efficiently
as the priority queue operations.
Because search trees support more methods
than we really need for priority queues,
it is reasonable to suspect that there are more efficient ways
to implement priority queues.
And indeed there are!
<P>
A number of different priority queue implementations
are described in this chapter.
All the implementations have one thing in common--they are all based on a special kind of tree called a <em>min heap</em>
or simply a <em>heap</em>.
<P>
<BLOCKQUOTE> <b>Definition ((Min) Heap)</b><A NAME="defnheap">&#160;</A>
A <em>(Min) Heap</em><A NAME=23184>&#160;</A><A NAME=23185>&#160;</A> is a tree,
<P> <IMG WIDTH=353 HEIGHT=16 ALIGN=BOTTOM ALT="displaymath64990" SRC="img1389.gif"  ><P>
with the following properties:
<OL><LI> Every subtree of <I>T</I> is a heap; and,<LI> The root of <I>T</I> is less than or equal to
	the root of every subtree of <I>T</I>.
	That is,  <IMG WIDTH=48 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline65008" SRC="img1390.gif"  > for all <I>i</I>,  <IMG WIDTH=64 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline61558" SRC="img900.gif"  >,
	where  <IMG WIDTH=15 HEIGHT=23 ALIGN=MIDDLE ALT="tex2html_wrap_inline65014" SRC="img1391.gif"  > is the root of  <IMG WIDTH=13 HEIGHT=23 ALIGN=MIDDLE ALT="tex2html_wrap_inline62338" SRC="img1057.gif"  >.
</OL></BLOCKQUOTE>
According to Definition&nbsp;<A HREF="page351.html#defnheap"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>,
the key in each node of a heap is less than or equal
to the roots of all the subtrees of that node.
Therefore, by induction,
the key in each node is less than or equal to all the keys
contained in the subtrees of that node.
Note, however, that the definition says nothing about the relative
ordering of the keys in the subtrees of a given node.
For example, in a binary heap either the left or the right subtree
of a given node may have the larger key.
<P>
<HR><A NAME="tex2html6237" HREF="page352.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html6235" HREF="page350.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html6229" HREF="page350.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html6239" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html6240" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <P><ADDRESS>
<img src="..\icons\bruno.gif" alt="Bruno" align=right>
<a href="..\copyright.html">Copyright &#169; 1998</a> by <a href="..\signature.html">Bruno R. Preiss, P.Eng.</a>  All rights reserved.

</ADDRESS>
</BODY>
</HTML>
