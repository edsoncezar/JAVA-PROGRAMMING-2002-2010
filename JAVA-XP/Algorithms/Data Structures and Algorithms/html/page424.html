<HTML>
<HEAD>
<TITLE>Mark-and-Sweep Garbage Collection</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF">
 <img src="..\icons\cover75.gif" alt="Cover" align=right>
<b>Data Structures and Algorithms 
with Object-Oriented Design Patterns in Java</b><br>
<A NAME="tex2html7136" HREF="page425.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html7134" HREF="page414.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html7128" HREF="page423.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html7138" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html7139" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <BR><HR>
<H1><A NAME="SECTION0014300000000000000000">Mark-and-Sweep Garbage Collection</A></H1>
<P>
<A NAME="secgarbagemarksweep">&#160;</A>
<P>
This section presents
the <em>mark-and-sweep</em><A NAME=30401>&#160;</A><A NAME=30402>&#160;</A>
garbage collection algorithm.
The mark-and-sweep algorithm was the first garbage collection algorithm
to be developed that is able to reclaim cyclic data structures.<A NAME="tex2html800" HREF="footnode.html#30403"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\foot_motif.gif"></A>
Variations of the mark-and-sweep algorithm continue to be among the most
commonly used garbage collection techniques.
<P>
When using mark-and-sweep,
unreferenced objects are not reclaimed immediately.
Instead, garbage is allowed to accumulate until all available memory
has been exhausted.
When that happens,
the execution of the program is suspended temporarily
while the mark-and-sweep algorithm collects all the garbage.
Once all unreferenced objects have been reclaimed,
the normal execution of the program can resume.
<P>
The mark-and-sweep algorithm is called a <em>tracing</em> garbage collector
because is <em>traces out</em> the entire collection of objects
that are directly or indirectly accessible by the program.
The objects that a program can access directly
are those objects which are referenced by local variables
on the processor stack as well as by any static variables
that refer to objects.
In the context of garbage collection,
these variables are called the <em>roots</em><A NAME=30407>&#160;</A>.
An object is indirectly accessible
if it is referenced by a field in some other
(directly or indirectly) accessible object.
An accessible object is said to be <em>live</em><A NAME=30409>&#160;</A>.
Conversely, an object which is not <em>live</em> is garbage.
<P>
The mark-and-sweep algorithm consists of two phases:
In the first phase, it finds and marks all accessible objects.
The first phase is called the <em>mark</em> phase.
In the second phase, the garbage collection algorithm scans
through the heap and reclaims all the unmarked objects.
The second phase is called the <em>sweep</em> phase.
The algorithm can be expressed as follows:
<PRE><em>for each root variable</em> r
    mark (r);
sweep ();
</PRE>
<P>
In order to distinguish the live objects from garbage,
we record the state of an object in each object.
That is, we add a special <tt>boolean</tt> field to each object
called, say, <tt>marked</tt>.
By default, all objects are unmarked when they are created.
Thus, the <tt>marked</tt> field is initially <tt>false</tt>.
<P>
An object <tt>p</tt> and all the objects indirectly accessible
from <tt>p</tt> can be marked by using the following recursive
<tt>mark</tt> method:
<PRE>void mark (Object p)
<P>
    if (!p.marked)
<P>
        p.marked = true;
        <em>for each</em> Object q <em>referenced by</em> p
            mark (q);
<P>
</PRE>
Notice that this recursive <tt>mark</tt> algorithm
does nothing when it encounters an object that has already been marked.
Consequently, the algorithm is guaranteed to terminate.
And it terminates only when all accessible objects have been marked.
<P>
In its second phase, the mark-and-sweep algorithm
scans through all the objects in the heap,
in order to locate all the unmarked objects.
The storage allocated to the unmarked objects is reclaimed during the scan.
At the same time, the <tt>marked</tt> field on every live object is set back
to <tt>false</tt> in preparation for the next invocation of the
mark-and-sweep garbage collection algorithm:
<PRE>void sweep ()
<P>
    <em>for each</em> Object p <em>in the heap</em>
<P>
        if (p.marked)
            p.marked = false
        else
            heap.release (p);
<P>
</PRE>
<P>
Figure&nbsp;<A HREF="page424.html#figgarbage5"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> illustrates the operation of the mark-and-sweep
garbage collection algorithm.
Figure&nbsp;<A HREF="page424.html#figgarbage5"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>&nbsp;(a) shows the conditions before garbage collection begins.
In this example, there is a single root variable.
Figure&nbsp;<A HREF="page424.html#figgarbage5"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>&nbsp;(b) shows the effect of the <em>mark</em> phase
of the algorithm.
At this point, all live objects have been marked.
Finally, Figure&nbsp;<A HREF="page424.html#figgarbage5"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>&nbsp;(c) shows the objects left after the <em>sweep</em>
phase has been completed.
Only live objects remain in memory and the <tt>marked</tt> fields have
all been set to <tt>false</tt> again.
<P>
<P><A NAME="30678">&#160;</A><A NAME="figgarbage5">&#160;</A> <IMG WIDTH=575 HEIGHT=559 ALIGN=BOTTOM ALT="figure30442" SRC="img1708.gif"  ><BR>
<STRONG>Figure:</STRONG> Mark-and-sweep garbage collection.<BR>
<P>
<P>
Because the mark-and-sweep garbage collection algorithm
traces out the set of objects accessible from the roots,
it is able to correctly identify and collect garbage
even in the presence of reference cycles.
This is the main advantage of mark-and-sweep over the reference
counting technique presented in the preceding section.
A secondary benefit of the mark-and-sweep approach is that
the normal manipulations of reference variables incurs no overhead.
<P>
The main disadvantage of the mark-and-sweep approach is the fact
that that normal program execution is suspended while the
garbage collection algorithm runs.
In particular, this can be a problem in a program that interacts
with a human user or that must satisfy real-time execution constraints.
For example, an interactive application that uses mark-and-sweep
garbage collection becomes unresponsive periodically.
<P>
<BR> <HR>
<UL> 
<LI> <A NAME="tex2html7140" HREF="page425.html#SECTION0014310000000000000000">The Fragmentation Problem</A>
</UL>
<HR><A NAME="tex2html7136" HREF="page425.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html7134" HREF="page414.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html7128" HREF="page423.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html7138" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html7139" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <P><ADDRESS>
<img src="..\icons\bruno.gif" alt="Bruno" align=right>
<a href="..\copyright.html">Copyright &#169; 1998</a> by <a href="..\signature.html">Bruno R. Preiss, P.Eng.</a>  All rights reserved.

</ADDRESS>
</BODY>
</HTML>
