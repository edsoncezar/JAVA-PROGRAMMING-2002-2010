<HTML>
<HEAD>
<TITLE>The Copy Algorithm</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF">
 <img src="..\icons\cover75.gif" alt="Cover" align=right>
<b>Data Structures and Algorithms 
with Object-Oriented Design Patterns in Java</b><br>
<A NAME="tex2html7170" HREF="page428.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html7168" HREF="page426.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html7164" HREF="page426.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html7172" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html7173" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <BR><HR>
<H2><A NAME="SECTION0014410000000000000000">The Copy Algorithm</A></H2>
<P>
The stop-and-copy algorithm divides the heap into two regions--an active region and an inactive region.
For convenience, we can view each region as a separate heap
and we shall refer to them as <tt>activeHeap</tt> and <tt>inactiveHeap</tt>.
When the stop-and-copy algorithm is invoked,
it copies all live objects from the <tt>activeHeap</tt>
to the <tt>inactiveHeap</tt>.
It does so by invoking the <tt>copy</tt> method given below
starting at reach root:
<PRE><em>for each root variable</em> r
    r = copy (r, inactiveHeap);
swap (activeHeap, inactiveHeap);
</PRE>
<P>
The <tt>copy</tt> method is complicated by the fact that
it needs to update all object references contained in the objects
as it copies those objects.
In order to facilitate this,
we record in every object a reference to its copy.
That is, we add a special field to each object called <tt>forward</tt>
which is a reference to the copy of this object.
<P>
The recursive <tt>copy</tt> method given below copies a given object
and all the objects indirectly accessible from the given object
to the destination heap.
When the <tt>forward</tt> field of an object is <tt>null</tt>,
it indicates that the given object has not yet been copied.
In this case, the method creates a new instance of the object class
in the destination heap.
Then, the fields of the object are copied one-by-one.
If the field is a primitive type, the value of that field is copied.
However, if the field refers to another object,
the <tt>copy</tt> method calls itself recursively to copy that object.
<PRE>void Object copy (Object p, Heap destination)
<P>
    if (p == null)
        return null;
    if (p.forward == null)
<P>
        q = destination.newInstance (p.class);
        p.forward = q;
        <em>for each field</em> f <em>in</em> p
<P>
            if (f is a primitive type)
                q.f = p.f;
            else
                q.f = copy (p.f, destination);
<P>
        q.forward = null;
<P>
    return p.forward;
<P>
</PRE>
<P>
If the <tt>copy</tt> method is invoked for an object whose
<tt>forward</tt> field is non-<tt>null</tt>,
that object has already been copied
and the <tt>forward</tt> field refers to the copy of that object
in the destination heap.
In that case, the <tt>copy</tt> method simply returns a reference
to the previously copied object.
<P>
Figure&nbsp;<A HREF="page427.html#figgarbage6"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A> traces the execution of the stop-and-copy
garbage collection algorithm.
When the algorithm is invoked and before any objects have been copied,
the <tt>forward</tt> field of every object in the active region is <tt>null</tt>
as shown in Figure&nbsp;<A HREF="page427.html#figgarbage6"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>&nbsp;(a).
In Figure&nbsp;<A HREF="page427.html#figgarbage6"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>&nbsp;(b),
a copy of object <I>A</I>, called <I>A</I>',  has been created in the inactive region,
and the <tt>forward</tt> field of <I>A</I> refers to <I>A</I>'.
<P>
<P><A NAME="31129">&#160;</A><A NAME="figgarbage6">&#160;</A> <IMG WIDTH=575 HEIGHT=829 ALIGN=BOTTOM ALT="figure30723" SRC="img1709.gif"  ><BR>
<STRONG>Figure:</STRONG> Stop-and-copy garbage collection.<BR>
<P>
<P>
Since <I>A</I> refers to <I>B</I>,
the next object copied is object <I>B</I>.
As shown in Figure&nbsp;<A HREF="page427.html#figgarbage6"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>&nbsp;(c),
fragmentation is eliminated by allocating storage for <I>B</I>'
immediately next to <I>A</I>'.
Next, object <I>C</I> is copied.
Notice that <I>C</I> refers to <I>A</I>,
but <I>A</I> has already been copied.
Object <I>C</I>' obtains its reference to <I>A</I>'
from the <tt>forward</tt> field of <I>A</I> as shown in Figure&nbsp;<A HREF="page427.html#figgarbage6"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>&nbsp;(d).
<P>
After all the live objects have been copied from the active region
to the inactive region,
the regions exchange their roles.
As shown in Figure&nbsp;<A HREF="page427.html#figgarbage6"><IMG  ALIGN=BOTTOM ALT="gif" SRC="..\icons\cross_ref_motif.gif"></A>&nbsp;(e),
all the garbage has been collected and the heap is no longer fragmented.
<P>
<HR><A NAME="tex2html7170" HREF="page428.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="..\icons\next_motif.gif"></A> <A NAME="tex2html7168" HREF="page426.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="..\icons\up_motif.gif"></A> <A NAME="tex2html7164" HREF="page426.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="..\icons\previous_motif.gif"></A> <A NAME="tex2html7172" HREF="page9.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="..\icons\contents_motif.gif"></A> <A NAME="tex2html7173" HREF="page618.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="..\icons\index_motif.gif"></A> <P><ADDRESS>
<img src="..\icons\bruno.gif" alt="Bruno" align=right>
<a href="..\copyright.html">Copyright &#169; 1998</a> by <a href="..\signature.html">Bruno R. Preiss, P.Eng.</a>  All rights reserved.

</ADDRESS>
</BODY>
</HTML>
