<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
<META NAME="VPSiteProject" CONTENT="file:///D|/6i-2_migration-guide/migration_guide_vpp/6i-2_migration_guide.vpp">

	<META NAME="GENERATOR" Content="Visual Page 2.0 for Windows">
	<TITLE>Oracle Designer 6i Migration Guide Part 3</TITLE>
	<LINK REL="stylesheet" TYPE="text/css" HREF="feb2002.css">

	<STYLE TYPE="text/css">
	<!--
	.8GeneralText	 {
			line-height : 14.0pt            ;
			punctuation-wrap : simple            ;
			text-autospace : none            ;
			Font-Family : Garamond ;
			Font-Size : 10.500000pt
		}
	#ftn1	 {
			
		}
	-->
	</STYLE>

</HEAD>

<BODY>

<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="96%" summary>
	<TR>
		<TD ALIGN="LEFT" VALIGN="TOP">
			<P><B><SPAN CLASS="header">Oracle Designer 6i Migration Guide<BR>
			Part 3. Generating and migrating existing database designs to Oracle Designer 6i</SPAN></B>
		</TD>
		<TD ALIGN="RIGHT" VALIGN="BOTTOM">
			<DIV ALIGN="RIGHT">
				<DIV ALIGN="RIGHT">
					<DIV ALIGN="RIGHT">
						<DIV ALIGN="RIGHT">
							<DIV ALIGN="RIGHT">
								<DIV ALIGN="RIGHT">
									<DIV ALIGN="RIGHT">
										<DIV ALIGN="RIGHT">
											<DIV ALIGN="RIGHT">
												<DIV ALIGN="RIGHT">
													<DIV ALIGN="RIGHT">
														<DIV ALIGN="RIGHT">
															<DIV ALIGN="RIGHT">
																<DIV ALIGN="RIGHT">
																	<DIV ALIGN="RIGHT">
																		<DIV ALIGN="RIGHT">
																			<DIV ALIGN="RIGHT">
																				<DIV ALIGN="RIGHT">
																					<DIV ALIGN="RIGHT">
																						<DIV ALIGN="RIGHT">
																							<DIV ALIGN="RIGHT">
																								<DIV ALIGN="RIGHT">
																									<DIV ALIGN="RIGHT">
																										<DIV ALIGN="RIGHT">
																											<DIV ALIGN="RIGHT">
																												<DIV ALIGN="RIGHT">
																													<DIV ALIGN="RIGHT">
																														<DIV ALIGN="RIGHT">
																															<DIV ALIGN="RIGHT">
																																<DIV ALIGN="RIGHT">
																																	<DIV ALIGN="RIGHT">
																																		<DIV ALIGN="RIGHT">
																																			<DIV ALIGN="RIGHT">
																																				<DIV ALIGN="RIGHT">
																																					<DIV ALIGN="RIGHT">
																																						<DIV ALIGN="RIGHT">
																																							<DIV ALIGN="RIGHT">
																																								<DIV ALIGN="RIGHT">
																																									<DIV ALIGN="RIGHT">
																																										<DIV ALIGN="RIGHT">
																																											<DIV ALIGN="RIGHT">
																																												<DIV ALIGN="RIGHT">
																																													<DIV ALIGN="RIGHT">
																																														<DIV ALIGN="RIGHT">
																																															<DIV ALIGN="RIGHT">
																																																<DIV ALIGN="RIGHT">
																																																	<DIV ALIGN="RIGHT">
																																																	<P>
																																																	<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" summary>
																																																		<TR>
																																																			<TD ALIGN="CENTER" VALIGN="TOP">
																																																				<P ALIGN="CENTER"><A HREF="mg_toc_6i-2.htm"><IMG SRC="images/conticon.gif" WIDTH="30" HEIGHT="30" ALIGN="BOTTOM"
																																																				ALT="Contents icon" BORDER="0"></A>
																																																			</TD>
																																																		</TR>
																																																		<TR>
																																																			<TD>
																																																				<P ALIGN="CENTER"><A HREF="mg_toc_6i-2.htm"><SPAN CLASS="copyright">Contents</SPAN></A>
																																																			</TD>
																																																		</TR>
																																																	</TABLE>

</DIV>
																																																</DIV>
																																															</DIV>
																																														</DIV>
																																													</DIV>
																																												</DIV>
																																											</DIV>
																																										</DIV>
																																									</DIV>
																																								</DIV>
																																							</DIV>
																																						</DIV>
																																					</DIV>
																																				</DIV>
																																			</DIV>
																																		</DIV>
																																	</DIV>
																																</DIV>
																															</DIV>
																														</DIV>
																													</DIV>
																												</DIV>
																											</DIV>
																										</DIV>
																									</DIV>
																								</DIV>
																							</DIV>
																						</DIV>
																					</DIV>
																				</DIV>
																			</DIV>
																		</DIV>
																	</DIV>
																</DIV>
															</DIV>
														</DIV>
													</DIV>
												</DIV>
											</DIV>
										</DIV>
									</DIV>
								</DIV>
							</DIV>
						</DIV>
					</DIV>
				</DIV>
			</DIV>
		</TD>
	</TR>
</TABLE>

<HR ALIGN="CENTER">
</P>
<P><A HREF="mg_part2_6i-2.htm"><IMG SRC="images/larrow.gif" WIDTH="30" HEIGHT="30" ALIGN="BOTTOM" ALT="Prev" BORDER="0"></A><A
HREF="mg_part4_6i-2.htm"><IMG SRC="images/rarrow.gif" WIDTH="30" HEIGHT="30" ALIGN="BOTTOM" ALT="Next" BORDER="0"></A></P>
<H1><A NAME="Part%203%20Chapter%201%20Introduction"></A>Chapter 1 Introduction</H1>
<P>This part (Part 3) of the migration guide provides the information necessary for upgrading, to Oracle Designer
6i, the database definitions that you designed and generated using earlier releases of Oracle Designer.</P>
<P>The part discusses database migration from the following earlier Designer releases:</P>

<UL>
	<LI>1.3.2
	<LI>2.1.2
	<LI>6.0
</UL>

<P>This part assumes that you have already installed Oracle Designer 6<I>i</I> and migrated your repository.&nbsp;
(See instructions in <A HREF="mg_part2_6i-2.htm">Part 2</A> of this Migration Guide.)&nbsp; This part&nbsp; then
explains steps you have to take so that you can:</P>

<UL>
	<LI><SPAN STYLE="List-Style-Position : Outside      ; Padding-Bottom : 1.100000%      ; Margin-Left : 42px ; List-Style-Type : Lower-Alpha">generate
	your database design definitions from Oracle Designer 6i and achieve the same generated results you had from earlier
	releases, and</SPAN>
	<LI><SPAN STYLE="List-Style-Position : Outside      ; Padding-Bottom : 1.100000%      ; Margin-Left : 42px ; List-Style-Type : Lower-Alpha">take
	advantage of new features that have been added to Oracle Designer since your previous release.</SPAN>
</UL>

<P>Throughout the document, special mention is made of any migration issues known at the time of publication of
this document.</P>
<P>Note that this Part 3 fully replaces an earlier published database migration guide for Oracle Designer 2.1x/6.0
and Designer 6<I>i</I> (October 2000).</P>
<P>Part 3 of the migration guide starts with an introduction (Chapter 1) that gives an overview of the possible
migration scenarios for database objects:</P>

<UL>
	<LI>Scenario 1.&nbsp; Migrate, Regenerate All, No Redesign, and
	<LI>Scenario 2.&nbsp; Migrate, Regenerate All, With Redesign.
</UL>

<P>Subsequently, Chapter 2 &quot;Oracle Designer 6i new database features&quot; describes all changes/new features
since 1.3.2 with respect to database design that you need to know to execute your migration steps for either scenario
1 or scenario 2.&nbsp; The new features chapter is structured by specific Oracle Designer release:&nbsp; Migrating
from Designer 1.3.2, Migrating from Designer 2.1.x, etc.</P>

<P>Chapter 3 discusses general database migration issues, integration steps for database objects you always have
to consider despite your database scenario.</P>

<P>Chapter 4 &quot;Scenario 1.&nbsp; Migrate, Regenerate All, No Redesign&quot; describes the necessary&nbsp; regeneration
steps for scenario 1.</P>

<P>Chapter 5 &quot;Scenario 2.&nbsp; Migrate, Regenerate All, With Redesign&quot; describes in addition specific
redesign steps for database objects.</P>

<P>Note that Part 4 &quot;Forms Migration&quot; and Part 5 &quot;Web PL/SQL migration&quot; is organized with a
similar structure.</P>

<P>This part of the migration guide, for database objects, continues where the second part of the migration guide
has stopped. It is considered that you have completed all the steps from the second part: your Oracle Designer
6i repository contains freshly migrated structured objects (e.g. database objects) and files.&nbsp; Note that it
does not make any difference for this part if files and/or structured objects are checked-in (&quot;versioned&quot;)
or just stored.</P>

<P><A NAME="3-1"></A>The database objects in Oracle Designer 6i are compliant with Oracle8<I>i</I>, i.e. you are
able to store, version, generate and - partly - visualize all your database specifications in Oracle Designer 6i
into an Oracle8<I>i</I> database and at the same time make use of specific Oracle8<I>i</I> functionality. Note
that at the same time you are still able to generate Oracle7 and Oracle8 syntax.</P>

<P>There is a lot more new functionality introduced in the Oracle 8<I>i</I> database, specifically if you are coming
from Oracle 7.3 (Oracle Designer 1.3.2 was compliant with Oracle 7.3).<FONT COLOR="red"></FONT></P>

<P>For example Oracle 8.0 has introduced the following new features:</P>

<UL>
	<LI>Partitioned Tables
	<LI>Partitioned Indexes
	<LI>Oracle Object Types
	<LI>Object Tables
	<LI>Object Views
	<LI>Oracle Collection Types
	<LI>Nested Tables
	<LI>Deferrable constraints.
</UL>

<P>You could already define the above new database features in Oracle Designer 2.1.x /6.0.&nbsp;</P>
<P>Oracle 8<I>i</I> (aka release 8.1.6 or above) has introduced for example - on top of Oracle 8.0 - the following
(sub-set of) new features:</P>

<UL>
	<LI>Index-only Tables
	<LI>function-based indexes
	<LI>Java in the database
	<LI>advanced queuing
	<LI>compute statistics option for indexes
	<LI>deterministic clause for PL/SQL functions.
</UL>

<P>Note that advanced queuing was already available in Oracle 8 (Enterprise Edition).&nbsp; However, you could
not document queue definitions directly in Oracle Designer 2.1/6.0, let alone generate code to populate the queues.</P>
<P>All these new features are available somewhere in new database objects (e.g. object views) and/or in the properties
of existing database objects in the Oracle Repository, either on the primary level (e.g. Table properties) or on
the secondary level (column properties).&nbsp; You should be aware that these new features are not automatically
enabled by the migration wizards of Oracle Designer 6.0 and Oracle Designer 6i.&nbsp;</P>

<P>Therefore your migration activities for database objects to <A NAME="3-1a"></A>Oracle 8<I>i</I> may be ranked
in the following categories:</P>

<UL>
	<LI>Update the freshly migrated database objects by adding references and/or associations, change default values
	or set specific values.
	<LI>Add new relational and object database object definitions.
	<LI>Replace existing relational definitions by object definitions.
</UL>

<P>This part (Part 3) of the migration guide for database objects focuses specifically on the first category of
post-migration changes.&nbsp; If your category of changes is more like the second and/or third category then at
least the following sections from the Oracle 8i documentation provide valuable support:</P>

<UL>
	<LI>Oracle 8i Concepts, Part No.&nbsp; A76965-01
	<LI>Oracle 8i Application Developer's Guide - Object Relational Features, Part No.&nbsp; A76976-01
	<LI>Oracle 8i Data Warehouse Guide, Part No.&nbsp; A76994-01
	<LI>Oracle 8i Enterprise JavaBeans and CORBA Developer's guide, Part No.&nbsp; A81356-01
	<LI>Oracle 8i Java Developer's Guide, Part No.&nbsp; A81353-01. 
</UL>

<P>For more Oracle 9<I>i</I> new object-relational-xml features, see the overall PDF index document index.pdf in
the root directory of the Oracle 9<I>i</I> documentation.</P>

<P>Assuming that your database migration is likely of the first flavor or category (update the freshly migrated
database objects by adding references and/or associations, change default values or set specific values), the following
migration scenarios are possible in bringing your Designer generated applications forward into Oracle Designer
6i:</P>

<UL>
	<LI>Scenario 1.&nbsp; Migrate, Regenerate All, No Redesign
	<LI>Scenario 2.&nbsp; Migrate, Regenerate All, With Redesign
</UL>

<P>Note however that there are general database migration steps, steps you always have to apply despite your source
Designer version. These generic steps are discussed in Chapter 3 &quot;General database migration issues&quot;.</P>
<H2><A NAME="Scenario%201. %20Migrate,%20Regenerate"></A>Scenario 1.&nbsp; Migrate, Regenerate All, No Redesign</H2>
<P>In this scenario, you will regenerate all database definitions of your entire application from Oracle Designer
6i The goal of this scenario is to be able to generate your application out of Oracle Designer 6i and achieve the
same results you got when generating out of your previous Designer release.&nbsp; No attempt is made to redesign
your existing application to make use of new relational features available in Oracle Designer 6i.</P>
<P>This scenario has the following characteristics:</P>

<UL>
	<LI>Scenario 1 is fast and requires minimal changes in the database definitions within your application's Oracle
	Designer repository
	<LI>Scenario 1 does not take advantage of any new relational features in Oracle Designer 6i. It is merely a 'technical'
	upgrade.
</UL>

<P>This scenario is appropriate when:</P>

<UL>
	<LI>your application is already in production
	<LI>your application is stable, no major functional modifications are expected
	<LI>maintenance is limited to simple bug fixing
	<LI>your physical database definitions are 100% derived from - or 100% generated from - the Designer repository,
	or post-generation modifications are minor.
</UL>

<H2><A NAME="Scenario%202. %20Migrate,%20Regenerate"></A>Scenario 2.&nbsp; Migrate, Regenerate All, With Redesign</H2>
<P>In this scenario, you will regenerate all database definitions of your entire application from Oracle Designer
6i. As you regenerate each database definition, you will make use of new relational features as appropriate.</P>
<P>The goal of this scenario is to take advantage of the new features available in Oracle Designer 6i.&nbsp; As
with Scenario 1, you want to be able to generate your database definitions and get the same database structure
from your previous release of Designer.&nbsp; However, several new database features have been added to Designer
to improve performance (e.g. function based indexes) or functionality (e.g. multiple database implementations)</P>
<P>This scenario has the following characteristics:</P>

<UL>
	<LI>Scenario 2 requires modifications in several database definitions, and is therefore more time-consuming
	<LI>Scenario 2 fully leverages the new database features in Oracle Designer 6i.
</UL>

<P>This scenario is appropriate when:</P>

<UL>
	<LI>your application is still in development
	<LI>your application is in production, but major functional modifications are to be made, or expected
	<LI>your application requires modifications which can only be implemented using new functionality in Oracle Designer
	6i.
</UL>

<P>Note that all scenarios result in an actual usage of Oracle 9i and Oracle Designer 6i and therefore you will
be optimally served by Oracle Support on your Oracle tool stack.</P>
<H1><A NAME="Chapter%202%20Designer%209i%20New%20DATABA"></A>Chapter 2 Oracle Designer 6i New DATABASE Features</H1>
<P>Depending on which Designer release you are coming from, many features of Oracle Designer 6i may be new to you.&nbsp;</P>
<P>This chapter presents a brief overview of new features that are of particular interest when migrating your database
design from previous Designer releases. It is by no means an exhaustive list of all new features, and it does not
try to explain each new feature in detail.&nbsp; Rather, it introduces the relevant features and points you to
where you can find more information in the Oracle Designer 6i online help.</P>
<P>The terminology of the different database element types is varied among the different Designer releases. The
following table gives an overview of a subset of the available database object types in Oracle Designer 1.3.2,
Oracle Designer 2.1.x/6.0 and Oracle Designer 6<I>i</I>.</P>
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%">
	<CAPTION>
		<P><B>Database objects since Oracle Designer 1.3.2</B>
	</CAPTION>
<thead> 
  												<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>#
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>Oracle Designer 1.3.2
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>Oracle Designer 2.1.2/6.0
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>Oracle Designer 6<I>i</I>
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
	</TR>
</thead> 
  												<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>TABLE
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>TABLE
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>TABLE DEF.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>VIEW
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>VIEW
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>VIEW DEF.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>SNAPSHOT
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>SNAPSHOT
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>MAT.VIEW DEF.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>SEQUENCE
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>SEQUENCE
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>SEQUENCE DEF.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>CLUSTER DEF.
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>CLUSTER DEF.
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>CLUSTER DEF.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>PL/SQL MODULE
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>PL/SQL DEF.
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>PL/SQL DEF.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&lt;NA&gt;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>OBJ.&nbsp; TYPE
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>OBJ.&nbsp; TYPE
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&lt;NA&gt;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>COLL.&nbsp; TYPE
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>COLL.&nbsp; TYPE
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&lt;NA&gt;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>OBJ.&nbsp; TABLE
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>OBJ.&nbsp; TABLE DEF.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&lt;NA&gt;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>OBJ.&nbsp; VIEW
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>OBJ.&nbsp; VIEW DEF.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&lt;NA&gt;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&lt;NA&gt;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>JAVA DEF.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&lt;NA&gt;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&lt;NA&gt;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>QUEUE DEF.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="7%" VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&lt;NA&gt;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>&lt;NA&gt;
		</TD>
		<TD WIDTH="30%" VALIGN="TOP" class="Normal">
			<P>QUEUE TABLE DEF.
		</TD>
	</TR>
</TABLE>
</P>
<P>Note that you could not define all properties of Object Tables and Object Views in Oracle Designer 2.1.x/6.0.</P>
<P>This chapter is organized by Designer release.&nbsp; You should begin reading at the section for your &quot;from&quot;
Designer release, and then continue reading the sections for any later releases. For example, if you are migrating
from Designer 1.3.2,&nbsp; you need to read all four sections below.&nbsp; If you are migrating from Designer 2.1.2,
you may skip the section on Designer 1.3.2 and read the sections for Designer 2.1.2, 6.0 and 6i.</P>
<H2><A NAME="Migrating%20from%20Designer%201.3.2"></A>Migrating from Designer 1.3.2</H2>
<P>The following new Oracle Designer 6i database features are applicable if you are migrating from Designer 13.2:</P>

<UL>
	<LI>Design Editor
	<LI>Database implementation
	<LI>Obsoleteness of the create property
	<LI>Usage of the batch generation and batch design capture
	<LI>Database capture changes (pka reverse engineering)
	<LI>Separate menu for generating administrative objects
</UL>

<H3><A NAME="Design%20Editor"></A>Design Editor</H3>
<P>The functionality provided by individual Designer&nbsp;Release 1 design level tools is now incorporated into
a single tool called the Design Editor. Each of the Designer Release 1 tools maps onto a Design Editor component.&nbsp;
It is essential that you understand how to use the Designer Editor before beginning your migration.</P>
<P>
<TABLE BORDER="1" CELLPADDING="6" CELLSPACING="0" WIDTH="492">
<thead> 
  												<TR>
		<TD WIDTH="156" VALIGN="TOP" class="Normal">
			<P>Release 1.x tool
		</TD>
		<TD WIDTH="336" VALIGN="TOP" class="Normal">
			<P>Release 2.x Design Editor components
		</TD>
	</TR>
</thead> 
  												<TR>
		<TD WIDTH="156" VALIGN="TOP" class="Normal">
			<P>RON
		</TD>
		<TD WIDTH="336" VALIGN="TOP" class="Normal">
			<P>Design Editor Navigator</P>
			<P>The Design Editor Navigator is a key component within the Design Editor.&nbsp; It is similar to the RON, but
			contains only objects specific to the design phase.</P>
			<P>You can use drag and drop, instead of clicking on menu options or toolbar buttons, to perform a wide range of
			tasks.&nbsp; For example, you can create a server model diagram from one or more table definitions by dragging
			the tables from the Design Editor Navigator component onto the worksurface.</P>
			<P>In addition the database definitions within the Design Editor Navigator are spread across three DE tabs:</P>
			<P>Server Model - contains all “pure” database definitions like table definition properties (alias) columns, constraints
			and triggers</P>
			<P>DB Admin - handles the database implementation properties of existing data database definitions like storage,
			tablespaces and access rights</P>
			<P>Distribution - handles typical database distribution aspects like nodes, replication and (public) database links</P>

			<P>Note that at the same time all DDL generators are removed from the RON. You have to use the DE to generate DDL
			scripts.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="156" VALIGN="TOP" class="Normal">
			<P>RON Property Palette
		</TD>
		<TD WIDTH="336" VALIGN="TOP" class="Normal">
			<P>Design Editor Property Palettes and Property Dialog boxes<BR>
			<BR>
			When you create and edit Repository definitions in the Design Editor, you can use either Property Dialog boxes
			(new for R2) or Property Palettes.<BR>
			<BR>
			Property Dialog boxes are wizard style elements which walk you through complex tasks.&nbsp; They are especially
			useful when creating whole new tables and columns as they walk you through all of the required tasks in order.&nbsp;
			They are also useful as a tool for learning Designer.<BR>
			<BR>
			Property Palettes provide you with a direct way of entering/editing information for all of the properties that
			exist for an object.&nbsp; Property palettes are the quickest way of setting properties for existing objects, because
			all properties are displayed in a single palette.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="156" VALIGN="TOP" class="Normal">
			<P>Server Model Diagrammer
		</TD>
		<TD WIDTH="336" VALIGN="TOP" class="Normal">
			<P>Server Model Diagrams<BR>
			<BR>
			Server Model Diagrams are created by dragging one or more tables from the Design Editor Navigator to the worksurface.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="156" VALIGN="TOP" class="Normal">
			<P>Preferences Navigator
		</TD>
		<TD WIDTH="336" VALIGN="TOP" class="Normal">
			<P>Preferences Palette<BR>
			<BR>
			Preference values are set using the Preference Palette within the Design Editor.&nbsp;&nbsp; Note that you can
			only define Server Generator preferences at application level.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="156" VALIGN="TOP" class="Normal">
			<P>Module Logic Navigator
		</TD>
		<TD WIDTH="336" VALIGN="TOP" class="Normal">
			<P>Logic Editor<BR>
			<BR>
			You can directly launch the module logic navigator - using the right mouse button option Edit logic - for a PL/SQL
			function, package or procedure. As a result a separate text editor is launched to add or modify the PL/SQL code.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="156" VALIGN="TOP" class="Normal">
			<P>Module Structure Diagrammer
		</TD>
		<TD WIDTH="336" VALIGN="TOP" class="Normal">
			<P>Module Network/ PL/SQL Composition viewer<BR>
			<BR>
			A module network viewer enables you to display module networks horizontally in the Design Editor Navigator.&nbsp;
			This allows you to clearly see the relationships between the PL/SQL modules in a network.
		</TD>
	</TR>
</TABLE>
</P>
<P>For more information about the Design Editor, see also the Design Editor online help topic “Features added in
previous releases”.</P>
<H4><A NAME="Database%20implementation"></A>Database implementation</H4>
<P>Designer 2.1.x has introduced a significant change in the meta-model for database objects also known as database
implementation. To fully understand the significance of this change, first a description of the meta model of database
objects in Designer 1.3.2 will be given, <A NAME="3-3"></A>followed by a description of the database meta-model
of Designer 2.1.x and above.</P>
<H4><A NAME="Database%20meta%20model%20of%20Oracle%20De"></A>Database meta model of Oracle Designer 1.3.2</H4>
<P>In Oracle Designer 1.3.2 - in the context of database implementation - the following elements were defined as
Primary Access Elements:</P>

<UL>
	<LI>Database
	<LI>User
	<LI>Group (database roles)
	<LI>Relation definition (database implementation properties)
	<LI>Tablespace
	<LI>Rollback segment
	<LI>Storage definition.
</UL>

<P>At the same time the following elements were defined as Secondary Access Elements or association:</P>

<UL>
	<LI>Database objects grants for users
	<LI>Database objects grants for roles.
</UL>

<P><IMG SRC="images/3image002.gif" WIDTH="415" HEIGHT="291" ALIGN="BOTTOM" BORDER="0" v:shapes="_x0000_s1032">
<BR clear = "all">
 The above database elements and their category (PAC or SAC) are depicted in the figure below: Database meta model
in Oracle Designer 1.3.2.</P>
<H4><A NAME="Database%20meta%20model%20since%20Oracle"></A>Database meta model since Oracle Designer 2.1.x</H4>
<P>Since Oracle Designer 2.1x (and therefore also in Oracle Designer 6i) only the following elements are defined
as Primary Access Elements - within the context of database implementation:</P>

<UL>
	<LI>Database
	<LI>Storage definition.
</UL>

<P>At the same time, the following elements are defined as Secondary Access Elements or associations:</P>

<UL>
	<LI>User
	<LI>Group
	<LI><A NAME="3-4"></A>Relation definition implementation (database implementation properties)
	<LI>Database objects privileges for users or groups
	<LI>Tablespace
	<LI>Rollback segment.
</UL>

<P>The above database elements and their category (PAC or SAC) are depicted in the figure below: Database implementation
meta model in Oracle Designer 6<I>i.</I></P>
<P><IMG SRC="images/3image004.gif" WIDTH="396" HEIGHT="428" ALIGN="BOTTOM" BORDER="0" v:shapes="_x0000_s1033">
<BR clear = "all">
 Note that this meta model change was already introduced in Oracle Designer 2.1.&nbsp;</P>
<P>This significant meta model change (most database implementation elements and their properties are now defined
in the context of a database) has the following consequences:</P>

<UL>
	<LI>Uniqueness. The above listed secondary access elements (and/or associations) are unique only within the context
	of a specific database.&nbsp; For example the user 'Scott' can exist within the context of database1 and also within
	the context of database2.
	<LI>Check-out and check-in context. Any change to the database properties and/or to its secondary access elements
	or associations must be preceded with a check-out, if you have an enabled repository version of the database.&nbsp;
	The check-in/check-out context is extensive since there are so many secondary database implementation properties.&nbsp;
	For example a change in a relation definition implementation property like a storage clause must be preceded within
	a check-out of the owning database.
	<LI>Short-cuts (aka shares). You can not short-cut (or share) a secondary access element, or association, separately.&nbsp;
	You can only short-cut primary access elements: the database and storage definitions.&nbsp; As a consequence if
	you short-cut the database you also implicitly short-cut its secondary elements and associations without the possibility
	to reference these secondary elements individually.
	<LI>Post-migration database objects steps consequences. The migration wizard of Designer 2.1/6.0 will create specific
	migration database definitions like a R2_UPGRADE_DATABASE database and a database user R2_UPGRADE_USER. We will
	deal with these steps in Chapter 3 &quot;General Migration Issues&quot;.
</UL>

<P>Note that the above mentioned consequences were also, to a certain extent, applicable to Oracle Designer 2.1/6.0.&nbsp;
In these previous Oracle Designer releases you should replace check-in and check-out context with 'working context'
and short-cuts with shares.&nbsp;</P>
<P>In Oracle Designer 6<I>i</I> it is no longer necessary to share an element from another container (application
system) first and then reference the shared element in the context container.&nbsp; You can reference an element
from another container immediately as long as it is 'visible' in the same workarea.&nbsp; In addition you can make
the referenced elements more 'visible' by creating short-cuts in the context container for these elements.&nbsp;
Another advantage of creating short-cuts is that you &quot;publish&quot; the previously defined elements.&nbsp;
It will most certainly stop you from creating a duplicate element.</P>
<P>Note also that the “migration wizard” of Designer 2.1.x and/or Designer 6.0 translates your data model to specific
database implementations. These specific translations are described in detail in the next chapter.</P>
<H3><A NAME="Obsoleteness%20of%20the%20create%20prope"></A>Obsoleteness of the Create? property</H3>
<P>The Create? property for each primary database object is no longer available, since Oracle Designer 2.1.x. For
example you could use this property as a logical removal indicator. Instead of physically removing a specific database
element you could set the create property to “No”.&nbsp; Similar behavior in Oracle Designer 6i is available using
database implementation (see also Chapter 2 “General database migration issues”).</P>
<P>Note that the Create? property on a secondary level like columns and constraints is transformed into the Complete?
property.&nbsp; The migration wizard brings the Create? property value forward into the Complete? property value.
Subsequently the Database Object Generator will not generate the syntax for secondary elements with a Complete?
property set to 'No'.&nbsp;</P>
<H3><A NAME="Usage%20of%20the%20batch%20generation%20an"></A>Use of batch generation and batch design capture</H3>
<P>Oracle Designer 2.1.x has introduced a batch utility for database object generation and design capturing that
is available from the menu Tools &gt; Batch Generate and Tools &gt; Batch Design Capture.&nbsp;</P>
<P>These batch generators could be applicable in the following circumstances:</P>

<UL>
	<LI>To create a persistent set of database objects in a specific workarea stored in one or more gbu files.
	<LI>To generate DDL files for a persistent set of database objects on a different location and/or on a different
	point in time.
</UL>

<P>Batch generation for database objects comprises the following steps:</P>

<OL>
	<LI>Choose your specific workarea in the Design Editor (File Menu; Change Workarea)
	<LI>Launch the Batch Generate menu from the Tools menu.
	<LI>Choose your container within a specific workarea.
	<LI>Choose the group of objects you would like to generate for a specific session.&nbsp; The following groups within
	the context of database objects are available: Server Model (SRM); Database Administration (DBA); Module Component
	API (MAPI); Table API (TAPI); Reference Code (RF).
	<LI value="5">Enable/disable the runtime Database Object Generator options (if applicable) (see Chapter 2 &quot;New
	Database features&quot;, section &quot;Server Generator Options&quot;).
	<LI>Highlight a specific user within the context of a specific database.
	<LI>Select your database objects.
	<LI>Save the generation details to a specific 'Database Generation Batch' file with for example the following naming
	standard &lt;Workarea name&gt;_&lt;container&gt;_SRM/DBA/MAPI/TAPI/RF_&lt;database selection indication&gt; .gbu,
	e.g. WA_DEVELOPMENT_QMS_SRM_SEL1.gbu.&nbsp; Note that the 'gbu' files only contain parameters, i.e. no database
	syntax.&nbsp;
	<P>Repeat steps 4 to 8 until no more groups are necessary.
	<LI value="9">Collect all 'gbu' files.
	<LI>Run dwzrun61 from the command line multiple times, for example from a different location, for each group using
	the specific 'gbu' file to generate all your different kinds of database objects.
</OL>

<P>You have to re-run the batch generator for database objects each time in the following circumstances:</P>

<UL>
	<LI>different Database Object Generator options
	<LI>different set of database objects.
</UL>

<P>Note that you do not have to re-run the batch generator (regenerate the gbu files) for database objects if one
or more database object definitions are changed since it does not contain any syntax.</P>
<H3><A NAME="Database%20capture%20changes"></A>Database capture changes</H3>
<P>Reverse engineering is called database capture since Designer 2.1.x.&nbsp;&nbsp; Database capture offers the
following new functionality:</P>

<UL>
	<LI>General capture preferences and preferences for capturing specific database object types (e.g. views, PL/SQL
	definitions).
	<LI>Views and PL/SQL definitions can now be captured as declarative definitions instead of free-format text.
</UL>

<P>In addition, since Designer 6<I>i</I>, there is a set of General Capture preferences:</P>

<UL>
	<LI>[RECCOM] Capture Comments
	<LI>[RECGRT] Capture Grants &nbsp;&nbsp;&nbsp;&nbsp;
	<LI>[RECSYN] Capture Synonyms
	<LI>[DTAPIT] Capture TAPI Generated Triggers with Tables
</UL>

<P>Note that the design capture of database objects may need to be preceded with a check-out of matching objects
in a versioned repository.&nbsp;</P>
<H3><A NAME="Separate%20menu%20for%20generating%20adm"></A>Separate menu for generating administrative objects</H3>
<P>Oracle Designer 6i has a separate tab (introduced in 2.1x) for generating administrative database objects (e.g.
Databases, tablespaces).&nbsp; In Oracle Designer 1.3.2 part of these administrative database objects could explicitly
(e.g. roles) and implicitly (e.g. database links) be generated from the DDL generator.&nbsp;</P>
<P>The Server Generator for database administrative elements supports - explicitly - the generation of the following
administrative elements:</P>

<UL>
	<LI>Databases
	<LI>Database links
	<LI>Directories
	<LI>Profiles
	<LI>Replication Groups
	<LI>Roles
	<LI>Rollback Segments
	<LI>Tablespaces
	<LI>Users.
</UL>

<H2><A NAME="Migrating%20from%20Designer%202.1.2%20an"></A>Migrating from Designer 2.1.2 and/or Designer 6.0</H2>
<P>The following new Oracle Designer 6i database features are applicable if you are migrating from Designer 2.1.x&nbsp;
or above:</P>

<UL>
	<LI>Server Generator preferences - introduced in <I>6i</I>
	<LI>Database Generation notes and Server Generator generation tabs
	<LI>Overview of Table API changes
	<LI>Dependency Analysis - what happened to summary table usages? - introduced in 6i
</UL>

<H3><A NAME="Server%20Generator%20preferences%20–%20i"></A>Server Generator preferences - introduced in <I>6i</I></H3>
<P>Oracle Designer 6<I>i</I> has introduced preferences for the Server Generator.&nbsp; These preferences are however
only applicable at application level.&nbsp; You cannot set Server Generator preferences for one or more specific
database objects.&nbsp;</P>
<P>The following general Server Generator preferences categories are applicable - available via the Server Generator
Product Flavor:</P>

<UL>
	<LI>General&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<LI>Generation - General
	<LI>Generation -TAPI and view
	<LI>Design capture preferences for tables, views, materialized views, PL/SQL definitions,&nbsp; Oracle object types
	<LI>Reconcile report preferences
</UL>

<P>For a detailed overview of Server Generator preferences see the Preference Navigator and the online help.</P>
<H3><A NAME="Database%20Generation%20notes%20and%20Se"></A>Database Generation notes and Server Generator generation
tabs</H3>
<P>The database generation - implemented via a variety of “Tabbed” windows - is significantly changed since Designer
1.3.2 and some minor changes were&nbsp; introduced since Designer 2.1.x.&nbsp; This section discusses the following
Database Generation subjects:</P>

<UL>
	<LI>General Generator Options
	<LI>Obsolete Database Generation options
	<LI>New or changed database object generation options
</UL>

<H4><A NAME="General%20Generator%20Options"></A>General Generator Options</H4>
<P>Specific general Generator Options that previously were defined as preferences are now available as options
accessible from the Design Editor.</P>
<P>You can launch the General Generator Options Windows (see below) from the menu Options/Generate Options/General
in order to modify these general settings.</P>
<P><IMG SRC="images/3image006.jpg" WIDTH="404" HEIGHT="423" ALIGN="BOTTOM" BORDER="0" v:shapes="_x0000_s1034">
<BR clear = "all">
</P>
<P>The fields on above picture means the following:</P>
<P><B>Scope of Code Control Table</B></P>
<P>The Scope of Code Control and Scope of Reference Code are no longer preferences but settings that you can modify
via the above displayed window.&nbsp; The following scopes are valid for Code Controls:</P>

<UL>
	<LI>Container Wide Table
	<LI>Single Table
	<LI>Table for each Code Control (new).
</UL>

<P>The following scopes are valid for References Codes - no changes:</P>

<UL>
	<LI>Container Wide Table
	<LI>Single Table.
</UL>

<P>The 'create table' syntax for the Reference Code Table and the 'insert into ..' statements for the allowable
values for reference codes can be generated via the Database Object Generation tab (see below).</P>
<P><B>Tablespace Of Reference Code Table</B></P>
<P>You can add to the 'create table' syntax for the Reference Code Table the preferred tablespace by adding here
the tablespace name, e.g. QMS_STATIC_TS.</P>
<H4><A NAME="Obsolete%20options%20for%20Oracle%20Desi"></A>Obsolete options for Oracle Designer 6i Database object
generation options</H4>
<P>The following Oracle Designer 1.3.2 DDL options are no longer available in Oracle Designer 6i:</P>

<UL>
	<LI>Overwrite files. All files are automatically overwritten, there is no warning if the files already exist.
	<LI>Comment syntax.&nbsp; All comment in the DDL files starts by default with '—'.
</UL>

<H4><A NAME="Oracle%20Designer%206i%20Database%20Obje"></A>Oracle Designer 6<I>i</I> Database Object generation
options (target tab)</H4>
<P>This section will discuss the options on the target tab of the menu option Generate &gt; Generate Database from
Server Model.</P>
<P><IMG SRC="images/3image008.jpg" WIDTH="401" HEIGHT="406" ALIGN="BOTTOM" BORDER="0" v:shapes="_x0000_s1035">
<BR clear = "all">
</P>
<P><B>DDL files only option</B></P>
<P>The Database Object Generator will generate the 'full' DDL files if you enable the 'DDL files only' files.&nbsp;
It ignores any existing database definition for a given schema.</P>
<P><B>Database option</B></P>
<P>If you enable the database option, then the Server Generator generates DDL scripts to create (or alter) database
objects directly against a schema in an Oracle database, using a Net8 connection (using the username, password
and connect string). Note that a separate reconcile option is no longer available (since Oracle Designer 2.1.x).
You will receive a reconcile file called &lt;<B>pre-fix</B>&gt;.lis automatically that contains a full reconcile
report between the Oracle Designer 6i definition and the database for the given schema name.</P>
<P>In this mode the Database Object Generator will create specific DDL files based upon existing database definitions
for the given schema name.&nbsp; For example if the table already exists but not a specific column, then an 'alter
table add column …' statement is generated.&nbsp; If you would like the full 'create table …' definition you should
choose the 'DDL files only'.&nbsp;</P>
<P><B>Stop on error</B></P>
<P>Indicates whether DDL generation (and execution) should be terminated if an error is detected.</P>
<P><B>Upload generated files to repository</B></P>
<P>You can use this option only when the chosen directory - in the directory field - is mapped to the repository
and the directory does <B>not</B> already contain downloaded DDL files that are read-only. Note that the files
are not saved in the repository if the directory is not mapped. You should careful consider the enabling of an
automatic file upload after generation since you cannot control individual files and the DDL generator may stop
because of existing read-only files.</P>
<H4><A NAME="New%20Oracle%20Designer%209i%20Database%20"></A>New Oracle Designer 6i Database Object generation
options (Options button)</H4>
<P><A NAME="3-5"></A>This section will discuss the fields on the <B>[Options ...] </B>button, that is available
on the Database generation tab on the bottom (see previous screen shot of database generation window depicted above).<FONT
COLOR="red"></FONT></P>

<P><IMG SRC="images/3image010.jpg" WIDTH="357" HEIGHT="396" ALIGN="BOTTOM" BORDER="0" v:shapes="_x0000_s1036">
<BR clear = "all">
</P>
<P><B>Generate Indexes</B></P>
<P>Indicates whether indexes defined against table/cluster/materialized view definitions are to be generated when
the table, cluster or materialized view is generated. Note that you can no longer select specific indexes as in
Oracle Designer 1.3.2.</P>
<P><B>Generate Integrity Constraints</B></P>
<P>Indicates whether integrity constraints defined against a table are to be generated when the table definition
is generated, i.e. primary key constraints, unique key constraints, foreign key constraints and check constraints.</P>
<P>To prevent constraints from being generated when a table is generated, uncheck this option.</P>
<P><B>Automatic Creation of REF_CODES</B></P>
<P>Indicates whether reference code tables containing domain/column allowable values are to be generated automatically.&nbsp;
A create table block in the '.tab' file for the reference codes and a separate insert script (&lt;pre-fix&gt;.avt)
with the reference code allowable values is generated if you enable the automatic creation of REF_CODES.</P>
<P><B>Foreign Key Generation Requires Join Table</B></P>
<P>Indicates whether one or both of the tables involved in a foreign key must be selected for it to be generated.&nbsp;
Uncheck this option if you want all foreign keys definitions, independent of your context.</P>
<P>Note that if you previously relied on foreign keys always being generated when generating to file - despite
your selection - you will need to uncheck this option.</P>
<P><B>Generate Triggers</B></P>
<P>Indicates whether triggers defined against table definitions are to be generated, when the table is generated.&nbsp;</P>
<P>Note that you can no longer select specific listed triggers as in Oracle Designer 1.3.2.&nbsp; You could however
enable/disable specific triggers via the complete property of a trigger.&nbsp; Trigger syntax will not be generated
if you disable the complete property.&nbsp;</P>
<P><B>Generate Grants and Synonyms for Users and Roles</B></P>
<P>Indicates whether any GRANT privileges and SYNONYMS defined for an object are to be generated to other users
and roles.&nbsp; If a privilege has been granted for a user or role in another schema, a CREATE SYNONYM statement
is generated for the object so that the object can be uniquely identified across different schemas.&nbsp; Note
that you cannot select specific user grants and role grants as in Oracle Designer 1.3.2 from this Server Generator
TAB.&nbsp; Note also that you can generate separately the 'create role syntax' and 'create user syntax' from the
Generate Database Administration Objects utility.</P>
<P><B>Assign Objects to Replication Code</B></P>
<P>Indicates whether statements to associate database objects with a predefined replication group are to be generated.&nbsp;</P>
<P>If the target for generation is a database, the objects will be created in the replication group on the database.&nbsp;
If the target for generation is a DDL script file, statements are generated to place the objects in the replication
group.</P>
<P>Note that the replication group itself is generated using the Generate Database Administration Objects utility
(see below).</P>
<H3><A NAME="Table%20API%20changes"></A>Table API changes</H3>
<P>The Table API creates a set of application-specific PL/SQL API packages that provide insert, update, delete
and lock procedures for each application table.&nbsp; In addition it validates the data provided by the calling
application and generates default values when appropriate before the table is modified or inserted.&nbsp; Note
that a table API - with limited functionality - was already available in Oracle Designer 1.3.2 as part of the Webserver
Generator.&nbsp;</P>
<P>The Table API in Oracle Designer 6i covers the following functionality:</P>

<UL>
	<LI>validates constraints
	<UL>
		<LI>validates arcs
		<LI>validates allowable values in reference code tables
		<LI>validates allowable values in domain tables
	</UL>
	<LI>auto-generates the following column values:
	<UL>
		<LI>unique and sequential values for columns that derive their values from a sequence definition
		<LI>pre-defined default values
		<LI>derived values
		<LI>change history information for AutoGen Type columns such as Created by, Modified by etc.
	</UL>
	<LI>converts column values to uppercase
	<LI>maintains journaling information
	<LI>maintains denormalized columns
</UL>

<P>Note that above overview does not distinguish between API functionality introduced in Designer 2.1, 6.0 and
that introduced in Designer 6<I>i</I>.</P>
<P>You can also add your own TABLE API logic before or after a specific DML operation. The Oracle Designer 6<I>i</I>
meta model captures the full event model of database logic - introduced in Designer 2.1.x.&nbsp; There are in addition
to the table API table API triggers to complete server logic.&nbsp; You can generate the table API and table API
triggers via the Generate table API menu.&nbsp;</P>
<P>Note that CDMruleframe (part of the Headstart Utilities) makes extensive usage of the TABLE API and the option
to add specific application logic. For more information about CDMruleframe www.otn.oracle.com.</P>
<H3><A NAME="Dependency%20Analysis%20or%20what%20happ"></A>Dependency Analysis or what happened to summary table
usages?</H3>
<P>Since Oracle Designer 6<I>i</I> a Dependency Manager tool is introduced that allows you to store (additional)
dependencies between structured elements and files and vice versa in a complete separate table structure - separate
from the “normal” table structure for structured elements like tables, views, PL/SQL definitions, etc. Note that
you also store dependencies between structured database elements only (like tables and pl/sql definitions) or dependencies
between files only (like install scripts) and files that contain the syntax of a package.&nbsp; In general, dependency
analysis gives you more control of your development and deployment environment by allowing you to efficiently manage
your application development and release environment, thereby ensuring higher quality software.</P>
<P>You could ask yourself &quot;Why do I need additional dependency information for database objects?&nbsp; They
are already stored in a structured way, are'nt they?&quot;.&nbsp; Yes they are, but not all dependencies are stored
atomically.&nbsp; The table usage for PL/SQL definitions and the database object usage for files are examples of
this.</P>
<P>As a consequence of the introduction of the Dependency Manager, summary table usages for PL/SQL modules (and
other modules like Forms or Reports) are no longer available and you have to realize that the Oracle Designer 6i
migration wizard does not bring forward previously stored summary table usages as dependencies.&nbsp; For example,
you have to rebuild the dependencies for packages - previously stored in the summary table usages -&nbsp; via the
dependency manager. You will however&nbsp; receive much more dependency information than table usages only (e.g.
procedure and function calls).</P>
<P>For more detailed information you can consult the online help for the Dependency Manager</P>
<H1><A NAME="Chapter%203%20General%20Migration%20issu"></A>Chapter 3 General Migration issues</H1>
<P>There are a number of actions you must take regardless of which migration scenario you choose.</P>
<P>This chapter is organized by Designer release.&nbsp; You should begin reading at the section for your &quot;from&quot;
Designer release, and then continue reading the sections for any later releases.&nbsp; For example, if you are
migrating from Designer 1.3.2, you need to read all sections below.&nbsp; If you are migrating from Designer 2.1.2,
you may skip the section on Designer 1.3.2 and read the sections for Designer 2.1.2 and 6.0.</P>
<H2><A NAME="Migrating%20from%201.3.2"></A>Migrating from 1.3.2</H2>
<P>This section covers general database migration issues when migrating from Designer Release 1.3.2.&nbsp; If you
are migrating from a later release, you may skip this section.</P>
<H3><A NAME="Multiple%20database%20implementation"></A>Multiple database implementations</H3>
<P>Oracle Designer 2.1.x has introduced a distinction between database implementation independent properties and
dependent properties of database objects - see also chapter 2 of this part (Part 3).&nbsp; All database implementation
dependent properties are defined within the context of a database against a specific schema (e.g. the storage definition
property of table implementation).</P>
<P>At the same time, all database implementation independent properties are - still - defined against the database
objects (e.g. the alias property of a table).</P>
<P>This distinction between database implementation dependent and independent database properties allows you to
define multiple implementations of the same database object.&nbsp; For example, you could introduce a schema in
a specific database that represents a 'light' table implementation (test purposes) with associated tablespaces
and (small) storage definitions.&nbsp; At the same time you could define another schema in another database that
represents a 'production' table implementation with much larger tablespaces and storage definitions.&nbsp; Such
a distinction was not available in Oracle Designer 1.3.2.&nbsp;</P>
<P>The migration wizard from Oracle Designer 2.1.x (or Oracle Designer 6.0) creates for each database object a
database implementation. It creates a specific database (R2_UPGRADE_DATABASE) and a specific user (R2_UPGRADE_USER)
during the migration process.&nbsp; The R2_UPGRADE_DATABASE will contain all existing users and a special user
called R2_UPGRADE_USER.&nbsp; Subsequently the user R2_UPGRADE_USER within the existing database(s) contains one
or more database objects and the associated database implementation properties if you have defined one or more
database implementation properties in Oracle Designer 1.3.2.</P>
<P>It is highly recommended to reevaluate this migration result with respect to databases and database schemas.
For example you could rename the migration database name R2_UPGRADE_DATABASE - or add another database - to a more
meaningful name, reflecting the data collection within that database. Subsequently you could rename the upgrade
user R2_UPGRADE_USER - or add another schema - within the database to a more meaningful schema name, reflecting
the database elements owned by that schema.&nbsp;</P>
<P>These actions should take place at the 'DB admin' tab in the Design Editor.&nbsp; Subsequently you can create
another database implementation - by creating a database schema in another database - if you need an additional
database implementation for a specific database object.</P>
<P>It is however not necessary to create databases in Oracle Designer 6i for each (promotion) database.&nbsp; The
database implementation properties in each promotion database may not necessarily be different.&nbsp; For example
the storage clause for a specific table in the test database may be the same as in the acceptance database.</P>
<P>Note that you can still generate a 'skeleton' DDL script - a script without database implementation syntax -
from the 'Server Model' tab in the Design Editor. Such a 'skeleton' script does not contain database implementation
properties as tablespaces or storage clauses and may be useful for development purposes.</P>
<H3><A NAME="Obsoleteness%20of%20the%20create%20prope"></A>Obsoleteness of the Create? property</H3>
<P>The Create? property for primary database objects (e.g. tables, views) has been removed while the create property
at the secondary level (e.g. constraints, columns) is brought forward in the “Complete?” property.&nbsp; With the
latter set to ‘N’ you circumvent the DDL creation of this secondary element.</P>
<P>You may adopt the following strategy for primary database objects to simulate a Designer 1.3.2 behavior with
respect to the Create? property for primary database objects. First associate all database objects with a database
schema or user within the context of a specific database. Secondly get a list of all database objects with the
create property set to ‘N’ from your Designer 1.3.2 repository. Thirdly remove these database implementations from
your database user. Subsequently generate only in the context of the DB admin tab - thus database implementations
only.&nbsp; Note that this strategy has the disadvantage that your generated DDL will always contain implementation
syntax like references to tablespaces and/or storage clauses.</P>
<H2><A NAME="Migrating%20from%202.1.2%20or%206.0"></A>Migrating from 2.1.2 or 6.0</H2>
<P>This section covers general migration issues when migrating from Designer Release 2.1.2 or 6.0.&nbsp; These
issues can also affect migrations from 1.3.2.&nbsp; The upgrade from these two releases is the same.&nbsp; If you
are migrating from a later release, you may skip this section.</P>
<H3><A NAME="Server%20Generator%20preference%20PARS"></A>Server Generator preference PARSER and consequences for
the generated syntax of PL/SQL definitions in combination with new pl/sql property Private Declaration</H3>
<P>Oracle Designer 6i comes with a set of server generator preferences - at application level only - as was already
mentioned before. One of the Server&nbsp; Generator preferences - PARSER at the “Generation general” node - influences
the generated syntax significantly by adding for example “BEGIN”, “END” and “DECLARE” strings in the PL/SQL code.&nbsp;
The default value of this preference is set to ‘N’ and this works fine for all free format PL/SQL definitions (packages,
procedures, functions and triggers) - see also the section below about PL/SQL definitions and their storage methods.
However if you have one or more PL/SQL definitions stored with the structured or non-free format method, then the
PARSER Server Generator preference should be set to ‘Y’ and in addition you may have to move (parts of) PL/SQL
code - specifically the declaration section - from the PL/SQL block property&nbsp; to the new Private Declaration
property.</P>
<P>For example the correct trigger syntax is generated if you set the preference PARSER value to =’N’ and if you
move the following lines in the PL/SQL block property to the Private Declaration property:</P>
<PRE>l_rowid rowid := qms_rowid_queue.qms_get_rowid;</PRE>
<PRE>&nbsp;l_empno qms_emp.empno%type;</PRE>
<PRE>&nbsp; l_mgrno qms_emp.mgr%type;</PRE>
<PRE>&nbsp; l_job qms_emp.job%type;</PRE>
<PRE>&nbsp; cursor c_emp (p_rowid in rowid)    is</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp; select emp.empno</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;,emp.mgr</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,emp.job</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp; from&nbsp;&nbsp; qms_emp emp</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp; where&nbsp; emp.rowid = p_rowid;</PRE>
<P>These lines above together with the remainder in the PL/SQL block property is constructed by the DDL generator
as:</P>
<PRE>PROMPT Creating Trigger 'QMS_EMP_AS'</PRE>
<PRE>CREATE OR REPLACE TRIGGER QMS_EMP_AS</PRE>
<PRE>&nbsp;AFTER DELETE OR INSERT OR UPDATE</PRE>
<PRE>&nbsp;ON QMS_EMP</PRE>
<PRE>DECLARE-- PL/SQL Specification</PRE>
<PRE>l_rowid rowid := qms_rowid_queue.qms_get_rowid;</PRE>
<PRE>&nbsp; l_empno qms_emp.empno%type;</PRE>
<PRE>&nbsp; l_mgrno qms_emp.mgr%type;</PRE>
<PRE>&nbsp; l_job qms_emp.job%type;</PRE>
<PRE>&nbsp; cursor c_emp (p_rowid in rowid)    is</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp; select emp.empno</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,emp.mgr</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,emp.job</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp; from&nbsp;&nbsp; qms_emp emp</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp; where&nbsp; emp.rowid = p_rowid;</PRE>
<PRE>-- PL/SQL Block</PRE>
<PRE>begin </PRE>
<PRE>&nbsp; while l_rowid is not null    loop</PRE>
<PRE>&nbsp;&nbsp;&nbsp; begin</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open c_emp(l_rowid);</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fetch c_emp</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; into&nbsp;&nbsp; l_empno</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,l_mgrno</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,l_job;</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close c_emp;</PRE>
<PRE>&nbsp;&nbsp;&nbsp; end;</PRE>
<PRE>&nbsp;&nbsp;&nbsp; if inserting or updating    then</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not qms_has_job_mgr(l_mgrno)    then</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* raise error stating    the employee is not a real manager */</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_application_error(-20000,'QMS-00049');</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if;</PRE>
<PRE>&nbsp;&nbsp;&nbsp; end if;</PRE>
<PRE>&nbsp;&nbsp;&nbsp; if updating and l_job &lt;&gt;    'MANAGER' then</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not qms_manage_emp(l_empno)    then</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* raise error stating    the job cannot be changed because</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the employee still    manages some employee */ </PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_application_error(-20000,'QMS-00050');</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if;</PRE>
<PRE>&nbsp;&nbsp;&nbsp; end if; </PRE>
<PRE>&nbsp;&nbsp;&nbsp; l_rowid:=qms_rowid_queue.qms_get_rowid;</PRE>
<PRE>&nbsp;&nbsp;&nbsp; </PRE>
<PRE>&nbsp; end loop;</PRE>
<PRE>&nbsp; qms_rowid_queue.qms_clear_array;</PRE>
<PRE>exception</PRE>
<PRE>&nbsp;&nbsp; when others then</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp; qms_rowid_queue.qms_clear_array;</PRE>
<PRE>&nbsp;&nbsp;&nbsp;&nbsp; raise;</PRE>
<PRE>end;</PRE>
<PRE CLASS="8GeneralText">/</PRE>
<H3><A NAME="Short-cut%20or%20reference%20strategy%20"></A>Short-cut or reference strategy for database objects</H3>
<P>The scope of short-cutting or referencing a database in Oracle Designer 6<I>i</I> - previously known as sharing
- has become much wider than sharing/referencing a database in Oracle Designer 1.3.2.&nbsp; Short-cutting a database
in Oracle Designer 6<I>i</I> not only implicates a single database short-cut but also a short-cut of all its secondary
elements and associations.&nbsp;</P>
<P>In Oracle Designer 1.3.2 you could share a single database - captured in a single application system - with
multiple other application systems indicating that all these application systems are implemented in a single database.&nbsp;
Your generic share model could like this:</P>
<P><IMG SRC="images/3image012.gif" WIDTH="446" HEIGHT="294" ALIGN="BOTTOM" BORDER="0" v:shapes="_x0000_i1025"></P>
<P>In the above example only one database is defined and shared out to the other application systems.&nbsp; At
the same time the entity DEPARTMENT and the table DEPARTMENTS is shared with another application system. More specifically,
application APPDEPT owns table DEPT and shares this table with APPEMP, that owns table EMP and receives the shared
table DEPT.&nbsp; In addition table EMP has a foreign key to DEPT.&nbsp; Both applications receive a database share
from application APPDES2000.&nbsp; This application provides only shares.&nbsp; The share model described above
reflects that database objects from APPDEPT and APPDEPT are implemented in the same database.&nbsp; Moreover sharing
DES2000 across these application systems was the only way to enforce the generation of the foreign key syntax for
EMP with DEPT via the DDL generator since the foreign key definition is defined within the context of two applications.&nbsp;
You could not generate the foreign key syntax if EMP and DEPT did not share the same database.&nbsp; This behavior
is no longer implemented in Oracle Designer 6<I>i</I>.&nbsp; A foreign key relation between table EMP and the shared
table DEPT is enough to generate the foreign key syntax.&nbsp;</P>
<P>If you decide to keep this share model - or short-cut model in Oracle Designer 6<I>i</I> - then all database
implementation properties for database DES2000 are owned by application APPDES2000.&nbsp; If you want specific
database implementation deviations for table EMP - e.g. another storage clause - then either you must create a
local database in APPEMP or you must create another database in application APPDES2000. &nbsp;</P>
<P>You can keep the above described short-cut model if you exactly want to reflect the database situation in Oracle
Designer 6<I>i</I> and at the same time accept that all database implementation properties are owned by application
APPDES2000.&nbsp;</P>
<P>You can circumvent the above situation by creating a local database in each application - could be the same
database name - and subsequently define the database implementations locally as opposed to centrally.&nbsp;&nbsp;
It is however highly recommended to implement this specific database implementation model already in Oracle Designer
1.3.2 before starting the migration steps as described in Part 2 of this migration guide.&nbsp; You could use Oracle
Echo to reorganize your database properties effectively.&nbsp; Oracle Echo is a consultancy tool that you can use
for reorganization purposes that comes with a consultancy service called 'repository reorganization services'.&nbsp;
You can contact your local Consultancy Sales Representative to acquire more information about this service and
other Oracle Designer/Repository related services.</P>
<H3><A NAME="Storage%20method%20of%20PL/SQL%20definit"></A>Storage method of PL/SQL definitions</H3>
<P>PL/SQL definitions - introduced in Oracle Designer 2.1.x. and known as PL/SQL Modules in Designer 1.3.2 - can
be stored in the Repository in the following ways:</P>

<UL>
	<LI>Non free format - semi-structured.&nbsp; This method is automatically chosen if you capture one or more PL/SQL
	definitions from the database. The following PL/SQL PAC and SAC elements and their properties are used to store
	PL/SQL definitions semi-structured:
	<UL>
		<LI>PL/SQL definition, property package specification: it contains only comment, the specification syntax is determined
		by the program units and their arguments
		<LI>PL/SQL definition, property private declaration: it contains the private part of package body, function or
		procedure
		<LI>PL/SQL definition, property PL/SQL block: it contains the PL/SQL text for functions and procedures
		<LI>PL/SQL definition, property pragma restrictions: it is based upon pragma restrictions in package specification
		<LI>Sub-program units: they are based upon functions and procedure sections in the Package body
		<LI>Arguments: they are based upon parameters in functions and procedures
	</UL>
</UL>


<BLOCKQUOTE>
	<P>Note that program data is not recognized separately, but populated in the private declaration section and also
	that there is no separate property for the pragma 'autonomous transaction'.&nbsp; The pragma 'autonomous transaction'
	must be defined within the private declaration section.</P>
</BLOCKQUOTE>


<UL>
	<LI>Non free format - fully structured.&nbsp; The PL/SQL definition is further broken down - manually - into the
	following elements - on top of the semi-structured method:
	<UL>
		<LI>Sub-program units of type cursor
		<LI>Program data - or local variables.&nbsp;
	</UL>
	<LI>Free format.&nbsp; The PL/SQL definition is stored unstructured in one or more text items.&nbsp; For example
	the package specification is stored in the text item PL/SQL specification and the package body in the text item
	PL/SQL block
	<LI>In an uploaded file or files. As two separate files that contain the PL/SQL definition of the package specification
	(e.g. ECHO_UTIL.pks) and another file containing the package body (e.g. ECHO_UTIL.pkb) of the package ECHO_UTIL
	or as a single file containing specification and body.
</UL>

<P>The following table gives an overview of the advantages and disadvantages of the above mentioned PL/SQL definition
storing methods:</P>
<P>
<TABLE BORDER="1" CELLPADDING="6" CELLSPACING="0">
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P>Dimension
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Semi-structured
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>a/d
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Structured
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>a/d
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Free format
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>a/d
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>As file(s)
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>a/d
		</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P>Dependencies
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Run Dependen-cy Analyzer for additional usages (e.g. tables, views)
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Run Dependency Analyzer for additional usages (e.g. tables, views)
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>All dependen-cies via Dependen-cy Analyzer
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>All dependen-cies via Dependency Analyzer
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P>Multi user
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>yes, multiple developers can build or change the package components
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>yes, multiple developers can build or change the package components
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>no, only one developer can build or change the package
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>no, only one developer can build or change the package
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P>Reusability
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Partly reusable components
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+/-
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>e.g. Functions, Procedure, Cursors
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>No reusability
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>No reusability
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P>Editor
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>via the Design Editor on - less multiple places
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+/-
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>via the Design Editor on multiple places in different formats
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>via Design Editor either in text items PL/SQL block and/or specification
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>No usage of Design Editor.&nbsp; You do not have to edit the package on multiple places, but directly in a text
			editor
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P>Productive-ness
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Little more productive in build phase
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Probably less, changes must be defined declarative
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Little more productive in build phase
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Most productive in the build phase
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P>CDMRule frame integration
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Structured integration.&nbsp; You could include generated CDMrule PL/SQL definitions in text items and CDMrule
			could include custom PL/SQL definitions
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Structured integration.&nbsp; You could call generated CDMrule PL/SQL definitions and CDMrule could call custom
			PL/SQL definitions
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Non structured integration.&nbsp; You could include generated CDMrule PL/SQL definitions in text items and CDMrule
			could include custom PL/SQL definitions
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Non structured integration.&nbsp; You could include generated CDMrule PL/SQL definitions in text items and CDMrule
			could include custom PL/SQL definitions
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P>Compila-tion
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Generates separate files.&nbsp; Compilation of body only is an option
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Generates separate files.&nbsp; Compilation of body only is an option
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Generates separate files.&nbsp; Compilation of body only is an option
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Compilation of body only if necessary
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P>Usage of Headstart utilities
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Full usage of Headstart utilities
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Full usage
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Limited usage of Headstart utilities
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>No usage of Headstart utilities
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P>Implementation properties (e.g. grants to users and/or roles)
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Structured storage of implementation properties
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Structured storage of implementation properties
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Structured storage of implementation properties
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Additional effort to store implementation properties like access rights
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P><I>Usage of pragma autonomous transaction [see note below]</I>
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>in Private Declaration text property
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>in Private Declaration text property
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>&nbsp;
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>In one or more PL/SQL blocks in the package body
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>In one or more PL/SQL blocks in the package body
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" class="Normal">
			<P>Migration effort
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>A move of PL/SQL blocks to private declaration property
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>A move of PL/SQL blocks to private declaration property
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>-
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>No migration effort
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>++
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>Capture in one or more files and subsequently uploaded
		</TD>
		<TD VALIGN="TOP" class="Normal">
			<P>+
		</TD>
	</TR>
</TABLE>
</P>
<P>Note: The usage of the pragma autonomous transaction is very useful, for example for error handling.&nbsp; You
can commit your log and error messages to a specific table independent of the state of your main transaction (failure
or success).&nbsp;</P>
<P>As can be seen from the last row or dimension in the above table the migration effort will vary for each of
the described storage methods for PL/SQL definition. There is almost no migration effort involved if your PL/SQL
definitions were stored as free format, while most effort is involved with the structured or semi structured format.</P>
<P>In previous Designer releases there was a strong tendency to use the structured or semi-structured format -
the latter is still the default during design capture. With the introduction of the Dependency Manager there is
less need for (semi)-structured format. The impact analysis based on files is almost as rich as the (semi)-structured
format. Note however that the file format does not support the structured storage (and generation of&nbsp;grant
scripts) of access rights against PL/SQL definitions .</P>
<H3><A NAME="Usage%20of%20the%20dependency%20manager%20"></A>Usage of the dependency manager to bring forward the
summary table usages</H3>
<P>The summary table usages are replaced by the output of the Dependency Manager as can also be seen from the table
presented above - in the row dependencies. You therefore have to parse all dependencies for all database objects
- including PL/SQL definitions - after a migration to Oracle Designer 6i - to retrieve similar functionality. Note
that you can parse dependencies for an entire container and its content or even for an entire workarea.</P>
<H1><A NAME="Chapter%204%20Scenario%201| %20Migrate,%20"></A>Chapter 4 Scenario 1:&nbsp; Migrate, Regenerate All,
No Redesign</H1>
<P>In this scenario, you will regenerate your database objects from Oracle Designer 6i.</P>
<P>The goal of this scenario is to be able to generate your database objects out of Oracle Designer 6i and achieve
the same results you got when generating out of your previous Designer release.&nbsp; No attempt is made to redesign
your existing application to make use of new features available in Oracle Designer 6i.</P>
<P>This chapter assumes that you already have performed all the actions against the database objects described
in Chapter 3 &quot;General Migration Issues&quot;.</P>
<H2><A NAME="Migrating%20from%201.3.2"></A>Migrating from 1.3.2</H2>
<P>This section covers migrating from Designer Release 1.3.2.&nbsp; If you are migrating from a later release,
you may skip this section.</P>
<P>There are no known specific migration issues arising from Designer 1.3.2. - provided that you have applied the
steps described in the sections ‘Migrating from 1.3.2’ and 'Migrating from 2.1.2 or 6.0' in the General Migration
Issues chapter of this part.</P>
<H2><A NAME="Migrating%20from%20Designer%202.1%20or%206"></A>Migrating from Designer 2.1 or 6.0</H2>
<P>This section covers migrating from Designer Release 1.3.2.&nbsp; If you are migrating from a later release,
you may skip this section.</P>
<P>First perform all the steps described in the section 'Migrating from 2.1.2 or 6.0' in the General Migration
Issues chapter of this part.</P>
<P>Secondly evaluate the following identified migration issues with respect to database objects coming from Designer
2.1 or 6.0:</P>
<H3><A NAME="Free%20format%20View%20DDL%20creation%20er"></A>Free format View DDL creation errors</H3>
<P>The DDL of free format defined views - and materialized free format views - may result in syntax errors like
a missing from clause. You can correct the view definition - and therefore ultimately the DDL syntax - by reevaluating
the view select text property. Next to the “select” lines, add the “from” and the “where” clause.</P>
<H4><A NAME="Different%20handling%20of%20quotes%20in%20"></A>Different handling of quotes in the column default
property value</H4>
<P>The behavior of the DDL generator with respect to default column values is changed when quotes are used around
the default property value,e.g. ‘Y’, ‘N’. If you want to keep the literal string (including the quotes) in the
generated DDL you have to set the next column property Default value type to “literal”.&nbsp; The DDL generator
generates the following syntax:</P>
<P>… ,JOB VARCHAR2(9) DEFAULT '''P''' NOT NULL</P>
<P>…</P>
<P>If you do <B>not</B> want the quotes you have to set the next column property Default value type to “Database
function call”.</P>
<P>The DDL generator generates then the following syntax:</P>
<P>…</P>
<P>,JOB VARCHAR2(9) DEFAULT 'P' NOT NULL</P>
<P>…</P>
<P>Note that migration wizard set this “Default value type” property&nbsp;default to literal.</P>
<H3><A NAME="Differences%20in%20names%20for%20valid%20v"></A>Differences in names for valid values constraints</H3>
<P>The database object generator shows a different behavior in generating valid values constraints. It generates
for each valid value constraint a separate check constraint - this behavior was already introduced in Designer
2.1.2. - and it generates a unique constraint name for each DDL session - new in Designer 6<I>i</I>.&nbsp; A valid
value constraint for example can be enforced via a domain with allowable values.</P>
<P>This new behavior will most likely result in a recreation of the valid value constraints each time you generate
DDL syntax against an existing schema that already contains all or part of the database objects. Provided obviously
that these database objects contain valid values. Note that this DDL behavior is persistent despite any changes
in the valid values.</P>
<P>There are two ways to circumvent this behavior and as a result get more control over these kinds of constraints:</P>
<P>1. Create custom explicit check constraints in the repository with the same check syntax as the generated constraint.
Note that you then have to revaluate these custom constraints each time the valid values are altered. Note also
that you have to disable the following database object generation option: “Generate valid value constraints”.</P>
<P>2. Use the CDM Ruleframe framework to propagate these valid value constraints as separate CDM ruleframe business
rules. You also have to disable the “Generate valid value constraints” database object generation option. You can
find more information about the CDM ruleframe framework for enforcing business rules at OTN (<A HREF="http://www.otn.oracle.com"
target="_blank">www.otn.oracle.com</A>)</P>
<H1><A NAME="Chapter%205%20Migrate,%20Regenerate%20Al"></A>Chapter 5 Migrate, Regenerate All with Redesign</H1>
<P>In this scenario, you will regenerate your relational and object type database objects from Oracle Designer
6i. You will use the new oracle 9i database features provided by Oracle Designer 6i.&nbsp; As you regenerate database
object each module, you will make use of new features as appropriate.</P>
<P>The goal of this scenario is to take advantage of the new database features available in Oracle Designer 6i.&nbsp;
As with Scenario 1, you want to be able to generate your application and get the same database layer you got from
your previous release of Designer.&nbsp; However, many new features have been added to Oracle Designer 6i to make
more use of Oracle9i enhancements.</P>
<P>This chapter is organized by Designer release.&nbsp; You should begin reading at the section for your &quot;from&quot;
Designer release, and then continue reading the sections for any later releases.&nbsp; For example, if you are
migrating from Designer 1.3.2, you need to read all the sections below.&nbsp; If you are migrating from Designer
2.1.2, you may skip the section on Designer 1.3.2 and read the sections for Designer 2.1.2 and 6.0.</P>
<P>Note that the enhancement or redesign steps in this Chapter must be preceded or accompanied by the actions in
Chapter 3 and Chapter 4.</P>
<P>You should also note that most of the new features (e.g. partition key entries, table partitions) may not be
visible for existing table implementations - for a specific migrated database.&nbsp; These implementations are
introduced in Oracle8 or later and your database 'Oracle Version' property is probably still set to <B>Oracle7</B>.&nbsp;
However you can make these specific properties and/or entries visible by changing the 'Oracle Version' Database
property to <B>Oracle 8<I>i</I> </B>or<B> Oracle 9<I>i</I>.</B></P>
<H2><A NAME="Migrating%20from%201.3.2"></A>Migrating from 1.3.2</H2>
<P>This section covers migration from Designer Release 1.3.2.&nbsp; If you are migrating from a later release,
you may skip this section.</P>
<P>The following new Oracle9<I>i</I> subjects - already introduced in Oracle 8 - are discussed:</P>

<UL>
	<LI>Table and index partitioning
	<LI>Bitmap and reverse indexes
	<LI>Global and local indexes
	<LI>New database triggers properties
	<LI>New column properties
	<LI>New view database implementation dependent and independent properties
	<LI>New materialized view database implementation dependent and independent properties
	<LI>Deferrable constraints
	<LI>Scope properties
	<LI>New grant properties to roles or users
</UL>

<P>Note that almost all the above listed improvements do not require any structural change and can therefore be
classified as cost effective. &nbsp;</P>
<H3><A NAME="Table%20Partitioning"></A>Table Partitioning</H3>
<P>Partitioning physically divides your table in horizontal pieces on different locations to boost performance,
making use of multiple reads/writes.&nbsp; It is dependent on your frequently used access paths which columns are
candidates for partition keys.&nbsp; For example suppose table EMP of Oracle (50,000 employees!) is frequently
accessed on LAND_OF_ORIGINATION then that column is a fine partition key candidate. In&nbsp;general you should
try to use columns that hold static values since the row is stored initially on a specific physical location.&nbsp;
You should try to avoid a table reorganization as a result of an uneven distribution of rows among the partitions.
You can find the following secondary table partitioning properties at the implementation level - provided that
your database version is set to Oracle8 or higher:</P>

<UL>
	<LI>Table partitions. Tables can be decomposed into smaller pieces called partitions.&nbsp; Partitions are particularly
	useful where tables have grown so big that they have become difficult to manage.&nbsp; Each table partition definition
	that is recorded in the repository represents a partition into which a table is to be divided on a database. You
	can influence the physical storage of the partitions via the “Value Less Than” property.&nbsp; For example appropriate
	values for this property could be (A-F, G-M, etc.) for the starting alphanumeric character of the LAND_OF_ORIGINATION
	column in the Oracle EMP example.
	<LI>Partitioning key entries. A partition key entry defines the usage of a particular column in the partitioning
	key of a table or an index. Each partitioning key can be based on one column only. Partition key entries are stored
	against table implementations or index storages in the repository. They can be created for global index storage
	definitions, but not local index storage definitions.
</UL>

<P>The migration wizard does not add a Partition Key Entry nor does it define table partitions for a specific table
implementation.</P>
<H3><A NAME="Bitmap%20indexes"></A>Bitmap indexes</H3>
<P>Bitmap indexes are widely used in data warehousing applications, which have large amounts of data and ad hoc
queries but a low level of concurrent transactions. For such applications, bitmap indexing provides:</P>

<UL>
	<LI>Reduced response time for large classes of ad hoc queries
	<LI>A substantial reduction of space usage compared to other indexing techniques
	<LI>Dramatic performance gains even on hardware with a relatively small number of CPUs or small amount of memory
	<LI>Very efficient maintenance during parallel DML and loads
</UL>

<P>Fully indexing a large table with a traditional B-tree index can be prohibitively expensive in terms of space
because the indexes can be several times larger than the data in the table.&nbsp; Bitmap indexes are typically
only a fraction of the size of the indexed data in the table. Bitmap indexes can substantially improve performance
of queries with the following characteristics:</P>

<UL>
	<LI>The WHERE clause contains multiple predicates on low- or medium-cardinality columns.&nbsp;
	<LI>The individual predicates on these low- or medium-cardinality columns select a large number of rows.&nbsp;
	<LI>Bitmap indexes have been created on some or all of these low- or medium-cardinality columns.&nbsp;
	<LI>The tables being queried contain many rows.
</UL>

<P>You could transform any non-bitmap (and non-unique) index that fulfills the above criteria into a bitmap index
by changing the index type into a bitmap.</P>
<H3><A NAME="User%20Object%20Index%20Storage%20proper1"></A>User Object Index Storage property: Index Type - at
database implementation level</H3>
<P>Indicates whether the storage details are for a local or global index.&nbsp; An Oracle7 index is equivalent
to an Oracle8 global index</P>
<P>A B-tree index on a partitioned table can be local or global.&nbsp; Global indexes must be fully rebuilt after
a direct load, which can be very costly when loading a relatively small number of rows into a large table.&nbsp;
For this reason, it is strongly recommended that indexes on partitioned tables should be defined as local indexes
unless there is a well-justified performance requirement for a global index.&nbsp; Bitmap indexes on partitioned
tables are always local.&nbsp; See also &quot;Table Partitioning&quot; for further details, above.</P>
<P>This property does not receive any value by the migration wizard.</P>
<H3><A NAME="User%20Object%20Index%20Storage%20proper"></A>User Object Index Storage property: Reverse or Nosort?
- at database implementation level</H3>
<P>Indicates whether Reverse or Nosort options are to be used for this index.</P>
<P>One cause of sorting is the creation of indexes.&nbsp; Creating an index for a table involves sorting all rows
in the table based on the values of the indexed columns.&nbsp; Oracle also allows you to create indexes without
sorting.&nbsp; If the rows in the table are loaded in ascending order, then you can create the index faster without
sorting.&nbsp;</P>
<P>Presorting your data and loading it in order may not always be the fastest way to load a table.&nbsp; Specifically
if you have a single-CPU computer, then you should sort your data before loading, if possible.&nbsp; Then create
the index with the NOSORT clause.</P>
<P>Creating a REVERSE key index, compared to a standard index, reverses the bytes of each column indexed (except
the rowid) while keeping the column order.&nbsp; Such an arrangement can help avoid performance degradation in
an Oracle Parallel Server environment where modifications to the index are concentrated on a small set of leaf
blocks.&nbsp; By reversing the keys of the index, the insertions become distributed across all leaf keys in the
index.</P>
<P>This property does not receive any value by the migration wizard.</P>
<H3><A NAME="Global%20Index%20Partitions%20as%20a%20sec"></A>Global Index Partitions as a secondary element of
User Object Index Storage - at database implementation level</H3>
<P>A global index partition represents a partition into which an index has been divided.&nbsp; The index partition
can have different physical characteristics to the index; for example, it can be stored in a different tablespace
and can have its own storage parameters.</P>
<P>The partitioning of a global index is completely independent of the partitioning of its associated table.&nbsp;
A global index is partitioned based on its own specific partition key, which is not necessarily the same as the
partition key of the table.</P>
<P>In a global partitioned index, the keys in a particular index partition may refer to rows stored in more than
one underlying table partition or sub-partition.&nbsp; A global index can only be range-partitioned, but it can
be defined on any type of partitioned table.&nbsp;</P>
<P>A global index is created by specifying the GLOBAL attribute.&nbsp;</P>
<P>A global partitioned index contains a single B-tree with entries for all rows in all partitions. Each index
partition may contain keys that refer to many different partitions or sub-partitions in the table. See also Chapter
11 &quot;Partitioned Tables and Indexes&quot; in Oracle 8<I>i</I> Concepts.</P>
<P>The migration wizard does not add a Global Index Partition for each table implementation.</P>
<H3><A NAME="Local%20Index%20Partitions%20as%20a%20seco"></A>Local Index Partitions as a secondary element of User
Object Index Storage - at database implementation level</H3>
<P>A local index partition represents a partition into which an index has been divided.&nbsp; The index partition
can have different physical characteristics to the index, for example, it can be stored in a different tablespace
and can have its own storage parameters.</P>
<P>Each local index partition has exactly the same number of partitions (with exactly the same &quot;VALUE LESS
THAN&quot; boundaries) as the number of partitions that have been defined for the table.&nbsp; The tablespace and
the storage parameters for a local index partition do not have to be the same as those used for the table partitions.</P>
<P>In a <B>local </B>index, all keys in a particular index partition refer only to rows stored in a single underlying
table partition.&nbsp;A local index is created by specifying the LOCAL attribute.&nbsp;</P>
<P>Oracle constructs the local index so that it is equipartitioned with the underlying table.&nbsp; Oracle partitions
the index on the same columns as the underlying table, creates the same number of partitions or subpartitions,
and gives them the same partition bounds as corresponding partitions of the underlying table.&nbsp;</P>
<P>Local indexes have the following advantages:</P>

<UL>
	<LI>Only one index partition needs to be rebuilt when a maintenance operation other than SPLIT PARTITION or ADD
	PARTITION is performed on an underlying table partition.&nbsp;
	<LI>The duration of a partition maintenance operation remains proportional to partition size if the partitioned
	table has only local indexes.&nbsp;
	<LI>Local indexes support partition independence.&nbsp;
	<LI>Local indexes support smooth roll-out of old data and roll-in of new data in historical tables.
</UL>

<P>See also Chapter 11 &quot;Partitioned Tables and Indexes&quot;, in Oracle 8<I>i</I> Concepts.</P>
<P>The migration wizard does not add a Local Index Partition for each table implementation.</P>
<H3><A NAME="Database%20Trigger%20property|%20Fire%20"></A>Database Trigger property: Fire When Propagated?</H3>
<P>Indicates whether or not the trigger is to fire when the data has been propagated, for example, in a multi-master
replication environment or with views (instead of triggers).&nbsp; Here the trigger code would perform the validation
of the rows being modified and, if valid, propagate the changes to the underlying tables.</P>
<H3><A NAME="New%20column%20properties"></A>New column properties</H3>
<H4><A NAME="Def%20Template/Library%20Object"></A>Def Template/Library Object</H4>
<P>The name of an object in a template or object library. This property will be populated within the context of
a module - like a display property - each time it is referenced in a module and subsequently used by the Oracle
Forms Generator.&nbsp; You could for example define a trigger on the double mouse-click behind this library object.</P>
<P>Enable this column property by referencing an item from your object library.</P>
<H4><A NAME="Server%20Defaulted%3F"></A>Server Defaulted?</H4>
<P>Indicates whether a default value should be supplied by application logic residing on the database server if
no value is supplied by a client side application.&nbsp; This tells the generator it should requery the row after
insert/update to display the server derived data. The migration wizard sets the value of this property to ‘N’.</P>
<H4><A NAME="Server%20Derived%3F"></A>Server Derived?</H4>
<P>Indicates whether the column's value is derived on the database server, via a database trigger, and therefore
should not be set or provided by the client side.&nbsp; The table API will generate server API code for an auto-generated
column (e.g. Date Created, User Created) if this property is enabled.&nbsp; The migration wizard sets the value
of this property to ‘N’.</P>
<H4><A NAME="Derivation%20Expression%20Type"></A>Derivation Expression Type</H4>
<P>Indicates the type of derivation expression (e.g. null, function call, SQL expression) that is used to specify
the column value. Obviously you have to provide a specific value for this property if you have defined a derivation
expression. The migration wizard does not set a specific value.</P>
<H4><A NAME="Where/Validation%20type"></A>Where/Validation type</H4>
<P>Indicates whether the Where/Validation condition property defines a Function Call or a SQL Expression. Obviously
you have to provide a specific value for this property if you have defined a where validation expression. The migration
wizard does not set a specific value</P>
<H3><A NAME="View%20properties"></A>View properties</H3>
<H4><A NAME="Object%20type%20view%20property"></A>Object type view property</H4>
<P>Identifies the Oracle object type on which the object view is to be based.&nbsp; For an existing object view
definition, this property can be changed to reference a different object type.&nbsp; However you cannot change
an object view into a relational view by removing the object type reference from this property.&nbsp;&nbsp; You
cannot reference an object type from an existing relational view.&nbsp; Use the utility 'Create Oracle Object Type'
to migrate existing relational views definitions.&nbsp; See also the section &quot;Oracle Object Types&quot;.</P>
<H4><A NAME="Non-free%20format%20View%20property|%20O"></A>Non-free format View property: Optimizer Hint Clause
- also applicable for Materialized Views</H4>
<P>A hint clause to be used where the view is defined declaratively.&nbsp; The optimizer uses the hint to choose
an execution plan for the SQL statement. You should add an optimizer hint clause if you specifically want to use
the rule-based optimizer.&nbsp; The default behavior of a database is the usage of the cost-base optimizer based
upon the computed statistics. The migration wizard does not set a specific value.</P>
<H4><A NAME="Base%20Table%20Locations|%20new%20databa"></A>Base Table Locations: new database implementation secondary
element for views</H4>
<P>Create a base table location if the underlying table, view or materialized view is implemented in a different
schema.&nbsp; This is because the Database Object Generator must be told which underlying objects it is to use
when creating a view or materialized view on a database.&nbsp;</P>
<P>For example, if view B is based on table A, then you can use a base table location if the latter is to be implemented
for a different user.</P>
<P>By default, views and materialized views are implemented in the same schema as the element on which they are
based.&nbsp; Where this is the case, base table locations are not required</P>
<H3><A NAME="Materialized%20view%20implementation"></A>Materialized view implementation independent properties</H3>
<H4><A NAME="Updateable"></A>Updateable</H4>
<P>Indicates whether the materialized view can be updated, i.e., whether INSERT, UPDATE and DELETE statements can
be performed on the materialized view.&nbsp; Only simple materialized views can be updated.</P>
<P>A materialized view is always synchronized with its source via a materialized view refresh (or a refresh of
the surrounding refresh group).&nbsp; You may consider making changes to the data in a materialized view in the
following circumstances:</P>

<UL>
	<LI>Intermediate (partly) synchronization of the materialized view on specific DML operations on the source
	<LI><A NAME="3-7"></A>Allow to make specific changes on the materialized view directly (for example in a replicated
	environment)
</UL>

<P>The following default migration value is applicable: 'No'.</P>
<H4><A NAME="Cluster"></A>Cluster</H4>
<P>The name of the cluster in which the materialized view exists.&nbsp; It is used to place a materialized view
on a cluster if the same grouping of columns are frequently selected from a table or tables.</P>
<H4><A NAME="Materialized%20view%20implementation"></A>Materialized view implementation dependent properties</H4>
<P>The following materialized view implementation dependent properties must be reevaluated:</P>

<UL>
	<LI>Materialised view log properties. Materialized view log properties for a table implementation
	<LI>Cached. Specifies whether the block retrieved for this materialized view is placed at the most recently used
	end of the Last Recently Used (LRU) list.&nbsp; When set to Not Cached, retrieved blocks are placed at the least
	recently used end of the LRU.&nbsp; Placing the data at the most recently used end can improve performance. It
	is useful to set this property to Cached for small lookup tables
	<LI>Materialized View Group. The name of a set of materialized views on the same database (but not necessarily
	in the same schema on that database) that are to be refreshed at the same time and at the same interval.&nbsp;
	The definition specified for Materialized View Group is the definition that would apply to a Refresh Group.&nbsp;
	A Materialized View Group is the counterpart of a Master Replication Group.
	<LI>Build Type. Identifies whether the materialized view is to be populated immediately after executing the DDL,
	or whether it is to be deferred.
	<LI>Query Rewrite? Identifies whether the materialized view is eligible to be used for query rewrite.&nbsp; Valid
	values: Null, Disable, Enabled
</UL>

<H3><A NAME="Deferrable%20constraints"></A>Deferrable constraints</H3>
<P>You can defer constraints for validity until the end of the transaction.&nbsp; A constraint is deferred if the
system checks that it is satisfied only on commit.&nbsp; If a deferred constraint is violated, then commit causes
the transaction to roll back.</P>
<P>If a constraint is immediate (not deferred), then it is checked at the end of each statement.&nbsp; If it is
violated, the statement is rolled back immediately.</P>
<P>If a constraint causes an action (for example, delete cascade), that action is always taken as part of the statement
that caused it, whether the constraint is deferred or immediate.</P>
<P>You can enable the defer status of a constraint by applying one of the following values for the constraint “Defer
Status” property :</P>

<UL>
	<LI>Initially deferred. The constraint is deferrable and, by default, checked at the end of the transaction.
	<LI>Initially immediate. The constraint is deferrable and, by default, checked at the end of each DML statement.
</UL>

<P>The Migration wizard brings the Not Deferred status value forward.</P>
<P>If you are using CDMrule frame or are planning to use it you should only use non-deferrable constraints. For
more information about CDMrule frame browse to <A HREF="http://www.otn.oracle.com" target="_blank">www.otn.oracle.com</A>.</P>
<H3><A NAME="Scope%20properties%20(global%20synonym"></A>Scope properties (global synonym name and scope) for each
database implementation object</H3>
<P>Each implementation of a database object (e.g. table, view, sequence) has received the following additional
scope properties:</P>

<UL>
	<LI>Global Synonym Name. The name to be used by the Database Object Generator when creating synonyms for this object.
	Default Migration value: null
	<LI>Scope. The scope of visibility of the database object (Database or World).&nbsp; This is used by the Database
	Object Generator when database links and synonyms need to be created. Default Migration value: Database
</UL>

<H3><A NAME="New%20or%20changed%20Granted%20to%20Users%20"></A>New or changed Granted to Users or Roles properties</H3>
<H4><A NAME="Create%20Synonym%3F"></A>Create Synonym?</H4>
<P>Indicates whether a synonym is automatically created by the Database Object Generator when the database object
is in a different schema to the user or role. This property receives by default a 'No' string by the migration
wizard.</P>
<H4><A NAME="Execute%3F"></A>Execute?</H4>
<P>Indicates that the EXECUTE privilege is granted to the user or role.&nbsp; Not applicable for tables.&nbsp;
This property receives by default a 'No' string by the migration wizard.</P>
<H4><A NAME="Read%3F"></A>Read?</H4>
<P>Indicates that the READ privilege is granted to the user or role.</P>
<P>The Read privilege provides secured access to the files stored in the operating system directory to which the
directory object serves as a pointer.</P>
<P>The directory object contains the full pathname of the operating system directory where the files reside.&nbsp;
Because the files are actually stored outside the database, Oracle server processes also need to have appropriate
file permissions on the file system server.&nbsp; Granting object privileges on the directory database object to
individual database users, rather than on the operating system, allows Oracle to enforce security during file operations.
This property receives by default a 'No' string by the migration wizard.</P>
<H4><A NAME="Enqueu%3F"></A>Enqueu?</H4>
<P>Indicates that the ENQUEUE privilege is granted to the user or role.&nbsp; This privilege applies only to queue
implementations. This property receives by default a 'No' string by the migration wizard.</P>
<H4><A NAME="Dequeu%3F"></A>Dequeu?</H4>
<P>Indicates that the DEQUEUE privilege is granted to the user or role.&nbsp; This privilege applies only to queue
implementations. This property receives by default a 'No' string by the migration wizard.</P>
<H2><A NAME="Migrating%20from%20Designer%202.1%20or%206"></A>Migrating from Designer 2.1 or 6.0</H2>
<P>This section covers some database migration issues when migrating from Designer Release 6.0.&nbsp; <FONT COLOR="red"></FONT></P>

<P>The following new Oracle9i new database features - already introduced in Oracle 8<I>i</I> - will be discussed:</P>

<UL>
	<LI>Index tables only
	<LI>Function based indexes
	<LI>Compute statistics for indexes
	<LI>Domain key constraints
	<LI>Deterministic clauses for PL/SQL definitions
	<LI>Object types
	<LI>Java definitions
</UL>

<P>Note that the introduction of object types and Java definitions involves a substantial structural change and
are therefore less cost effective than the other Oracle9i new features.</P>
<H3><A NAME="Index%20table%20only"></A>Index table only</H3>
<P>Typically large tables with only a small number of columns like intersection tables are candidates for index-organized
only.</P>
<P>You can change a “normal” table to an index organized table by enabling the table property Index-organized?.&nbsp;
Note that the migration wizard does not enable this specific table property.</P>
<H4><A NAME="Pct%20Theshold%20–%20at%20database%20imple"></A>Pct Theshold - at database implementation level</H4>
<P>Used in the case of an 'index only table' to specify a percentage of the block size. This property does not
receive any value by the migration wizard.</P>
<H4><A NAME="Overflow%20Tablespace–%20at%20database"></A>Overflow Tablespace- at database implementation level</H4>
<P>Used in the case of an 'index only table' to specify the name of the tablespace that is used for overflow purposes.
This property does not receive any value by the migration wizard.</P>
<H3><A NAME="Function%20Based%20indexes"></A>Function Based indexes</H3>
<P>Function based indexes are introduced in Oracle8<I>i</I> and are a very cost effective means of boosting your
application performance without changing the underlying database structure.</P>
<P>You can define function based indexes at the index entry level (e.g. column level) and define the function expression
in the “Index Function” property like upper(ename). In addition you should set the “type” property to “function
based” as opposed to “column based”.</P>
<H3><A NAME="Compute%20statistics%20for%20Indexes"></A>Compute statistics for Indexes</H3>
<P>Indicates whether statistics are to be collected on creation of the index. Typically you would set this value
to 'yes' in the context of migration since all tables will contain data.&nbsp; Re-creation of the indexes will
then automatically lead to the collection of statistics. Note that the migration wizard disables this property
by default.</P>
<H3><A NAME="Domain%20Key%20Constraints"></A>Domain Key Constraints</H3>
<P>Oracle Designer 6i introduces a new SAC (secondary element) for tables called Domain Key Constraints.&nbsp;</P>
<P>Domain key constraints allow you to model domains using a table other than the predefined one normally used
by Oracle Designer.&nbsp;</P>
<P>A domain key constraint allows a generated application to access a specific range of domain values, from a table
containing multiple domains.&nbsp; The domain key constraint specifies that values entered in the domain key columns
do not conflict with a predefined range of acceptable values.</P>
<P>You may want to do this for several reasons, e.g., you may already have a domain table that you would like to
design capture and continue to use, or you may want more control over how domain values are shown within a model</P>
<P>You add a domain key constraint for a specific table as a new secondary constraint type next to the ‘normal’
constraints like foreign key or check constraints.&nbsp;</P>
<H4><A NAME="Primary%20Key%20,%20Unique%20Key%20or%20Fore"></A>Primary Key , Unique Key or Foreign Key column property:
Conversion Format Mask?</H4>
<P>The format to be used when a date or number column is joined to varchar2 column in a domain table.&nbsp; If
a format is not specified here, the application generators use a set of rules to define the format.&nbsp; Note
that this property is not used by the Database Object Generator. It applies only to key components of domain key
constraints</P>
<H4><A NAME="Foreign%20Key%20column%20property|%20Sec"></A>Foreign Key column property: Second Join Column?</H4>
<P>The name of a column in the join table that is the derivation for all or part of this foreign key.</P>
<H3><A NAME="Usage%20of%20the%20Deterministic%3F%20clau"></A>Usage of the Deterministic? clause for PL/SQL functions</H3>
<P>Allows the system to use a saved copy of the function's return result - Functions only - if such a copy is available.&nbsp;
The saved copy could come from a materialized view, a function based index, or a redundant call to the same function
in the same SQL statement.</P>
<P>The Query optimizer can choose whether to use a saved copy or re-call the function.&nbsp; The function should
reliably return the same result value whenever it is called with the same values for its arguments.&nbsp; Therefore
do not define the function to use package variables or to access the database in any way that might effect the
function's return result, because the results of doing so will not be captured if the system chooses not to call
the function</P>
<P>You can simply make use of the deterministic feature by enabling the Deterministic? property for PL/SQL functions.</P>
<H3><A NAME="Object%20Types"></A>Object Types</H3>
<P>Oracle object types (aka user-defined types) provide a way of creating user-defined datatypes for the Oracle8<I>i</I>
database server.&nbsp; These datatypes can be used in addition to the built-in datatypes provided by the server.&nbsp;</P>
<P>You could use Oracle object types:</P>

<UL>
	<LI>to define a datatype of a column in a relational table
	<LI>to create a table based on a specific Oracle object type, i.e. an object table
	<LI>as part of the definition of another Oracle object type, i.e. as an attribute of the new Oracle object type.
</UL>

<P>Oracle object types can be considered as templates for creating instances of objects.&nbsp; Typically, the objects
have a set of common attributes and methods (operations), and may be structured in a hierarchy.</P>
<P>Use the Create Oracle Object Type and Create Object View utilities to migrate a server model based on a relational
table design to an object design.&nbsp;</P>
<P>There are three key stages to migrating a relational design:</P>

<UL>
	<LI>Create Oracle object types from the relational tables/views
	<LI>Modify the default Oracle object type definitions
	<LI>Create object views for the Oracle object types
</UL>

<H4><A NAME="Stage%201%20-%20Create%20Oracle%20object%20t"></A>Stage 1 - Create Oracle object types from the relational
tables/views</H4>
<P>The first stage is to build Oracle object type definitions based on the structure of the relational table/views
in your current server model.&nbsp;</P>
<P>The utility - first option from the utility menu in the Design Editor - creates an Oracle object type for each
selected table/view.&nbsp; It also creates an Oracle object type attribute for each non-foreign key column and
a REF attribute for each foreign key.&nbsp; Note that for REF attributes to be correctly mapped to Oracle object
types, both tables/views referenced by the foreign key need to be selected.</P>
<P>Note that the utility also creates a set of mapping elements to record the relationship between the relational
table/columns and the Oracle object type/attributes.&nbsp; This mapping is only visible in the RON (see below).&nbsp;
This mapping information is used when the Oracle object types are used to implement object views for the relational
table/views (see Stage 3).</P>
<H4><A NAME="Stage%202%20-%20Modify%20the%20default%20Ora"></A>Stage 2 - Modify the default Oracle object types</H4>
<P>Once you have created a set of Oracle object types based on your relational tables/views, you can review your
design from an object-orientated perspective.&nbsp; In this stage you will typically introduce further Oracle8
database server features.&nbsp;</P>
<P>For example:</P>

<UL>
	<LI>Migrate a set of attributes to new embedded Oracle object type
	<LI>Change REF attributes to collections of VARRAY or nested table
	<LI>Change attributes to REF attributes
	<LI>Add/delete attributes (and column mappings).
</UL>

<H4><A NAME="Stage%203%20-%20Create%20object%20views%20fo"></A>Stage 3 - Create object views for the Oracle object
types</H4>
<P>Finally, you can build object view definitions based on the Oracle object type definitions and their mappings
to relational table/views.&nbsp;</P>
<P>The utility - second option from utility menu in the Design Editor - creates an object view for each Oracle
object type you select, together with the required SQL statements to construct the object rows from the underlying
relational tables.&nbsp; It also creates OIDs from the underlying relational tables primary/unique key.</P>
<P>There are no new properties for the primary and secondary implementation independent properties of Oracle Object
Types and there are no specific implementation dependent properties for Oracle Objects Types.</P>
<H3><A NAME="Collection%20types"></A>Collection types</H3>
<P>Oracle collection types are used to define datatypes.&nbsp; They provide support for collections of similar
items, and can be implemented as either of the following:</P>

<UL>
	<LI>Nested tables - These are useful where referential integrity is required and are suited to master-detail and
	one-to-many relationships.&nbsp; Nested tables can have attributes but no methods.&nbsp;
	<LI>VARRAYs - These are useful for providing quick access to small or uniform-sized collections of objects in a
	table.&nbsp; VARRAYs do not have methods or attributes.&nbsp;
</UL>

<P>An example of when you could use a collection type is for managing orders and their associated order lines.&nbsp;
The orders would be stored in a top-level outer table, while the order lines could be stored in a nested table
or VARRAY.&nbsp; The nested table or VARRAY is recorded as a column (on a relational table) or an attribute (on
an object relational table) on the outer table.&nbsp; This column/attribute embeds the collection type within the
outer table and is designed to hold the order lines for each order.</P>
<P>Typically nested tables are used when there is no limit on the potential number of items to be stored.&nbsp;
Conversely, VARRAYs always have a maximum number of elements, that is defined by the user.</P>
<P>Nested tables and VARRAYs cannot be referenced directly, but they can be referenced indirectly via the outer
table.</P>
<H3><A NAME="Object%20Tables"></A>Object Tables</H3>
<P>Object tables are based on Oracle object types.&nbsp; The objects that are stored in each row of the table are
uniquely identified by a system generated identifier, called an object identifier.&nbsp; This object identifier
is maintained automatically by the database.</P>
<H3><A NAME="Object%20Views"></A>Object Views</H3>
<P>Object views allow you to retrieve, update, insert and delete relational data as if they were stored as objects.&nbsp;
This allows you to use the object oriented features of the Oracle 8<I>i</I> database server with existing relational
data. If you want to build an object view that is based on an existing relational table or view, you can use the
Create ObjectView utility (see above).</P>
<H3><A NAME="Transformation%20Mapping%20Sets%20(vis"></A>Transformation Mapping Sets (visible in RON only)</H3>
<P>A transformation mapping set represents the overall 'collective' mapping for transformation from one level to
another, for example, from the type model to the server model.&nbsp; It is made up of the individual mappings of
pairs of specified elements.</P>
<P>There are three transformation types:</P>

<UL>
	<LI>Entitity Object to Relational BC4J mapping
	<LI>Entity Object to Relational Mapping
	<LI>Relational to Object Relational mapping
</UL>

<P>The last mapping type is created automatically by the utilities 'Create Oracle Object Type' and/or the 'Create
Object View'.</P>
<H3><A NAME="Java%20definitions"></A>Java definitions</H3>
<P>Oracle Designer 6i has introduced the option to store Java Definitions in a structured way.&nbsp; It supports
the following Java Definitions:</P>

<UL>
	<LI>Source Definitions
	<LI>Class Definitions
	<LI>Resource Definitions
</UL>

<P>If you use this structured method for Java Definitions in Oracle Designer 6i you will not be able to use the
JDeveloper 9<I>i</I> IE optimally.&nbsp; However you could also store the Java Definitions as text files in the
Oracle Designer 6i repository.&nbsp; Adopting the file approach you will use the Oracle Designer 6i repository
basically as a Source Control Tool to manage the Java files, its versions, its releases and its dependencies.&nbsp;
In addition, the Oracle Designer 6i repository will control the revision data and will keep track of a change history
and the lock of a file when it is in use by a developer.</P>
<P>The following subjects for storing Java Definitions as files will be handled:</P>

<UL>
	<LI>Organization of Oracle Designer 6i repository for storing Java files
	<LI>Interactions between the Oracle Designer 6i / Repository 6i and JDeveloper 9i (release candidate 1 and 2)
	<LI>Dependency analysis for Java files
</UL>

<H4><A NAME="Organization%20of%20Oracle%20Designer%20"></A>Organization of Oracle Designer 6<I>i</I> repository
for storing Java files</H4>
<P>Oracle Designer 6i will be used as the repository to manage all Java files and its versions.&nbsp; Within Oracle
Designer 6i files will be stored in a folder structure that matches the Java package structure.&nbsp; Thus, a Java
package - package names preferably in lowercase! - will also be visible in the Oracle Designer 6i environment.</P>
<H4><A NAME="Interactions%20between%20the%20Oracle%20"></A>Interactions between the Oracle Designer 6i / Repository
6i and JDeveloper 9i (release candidate 1 and 2)</H4>
<P>A significant amount of effort is spent in the integration between the Repository 6i and JDeveloper 9i (release
candidates) based on the assumption that all Jdeveloper 9i components (e..g Java files, XML files) are stored as
files in the repository, rather than structured objects. This tight integration - together with the Oracle Designer
6i capability of storing structured database objects - makes Oracle Designer 6i/Repository 6i/Jdeveloper 9i an
effective and productive development and deployment tool stack.<FONT COLOR="red"></FONT></P>
<H4><A NAME="Dependency%20analysis%20for%20Java%20fil"></A>Dependency analysis for Java files</H4>
<P>You could enrich the repository with dependency information for Java files by analyzing your Java files via
the Dependency Manager for dependencies with other files and structured objects (e.g. table usage).&nbsp;See also
the section about dependency analysis.</P>

<DIV ID="ftn1">
	<P>&nbsp;
</DIV>

<P>
<HR ALIGN="CENTER">

<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="96%" summary>
	<TR>
		<TD VALIGN="TOP">
			<P>
			<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" summary>
				<TR>
					<TD ALIGN="CENTER">
						<P ALIGN="CENTER"><A HREF="mg_part2_6i-2.htm"><IMG SRC="images/larrow.gif" WIDTH="30" HEIGHT="30" ALIGN="BOTTOM"
						ALT="Previous" BORDER="0"></A>
					</TD>
					<TD>
						<P ALIGN="CENTER"><A HREF="mg_part4_6i-2.htm"><IMG SRC="images/rarrow.gif" WIDTH="30" HEIGHT="30" ALIGN="BOTTOM"
						ALT="Next" BORDER="0"></A>
					</TD>
				</TR>
				<TR>
					<TD VALIGN="TOP">
						<P ALIGN="CENTER"><A HREF="mg_part2_6i-2.htm"><SPAN CLASS="copyright">Prev</SPAN></A>
					</TD>
					<TD>
						<P ALIGN="CENTER"><A HREF="mg_part4_6i-2.htm"><SPAN CLASS="copyright">Next</SPAN></A>
					</TD>
				</TR>
			</TABLE>

		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER"><IMG SRC="images/oracle.gif" WIDTH="105" HEIGHT="20" ALIGN="BOTTOM" ALT="Oracle logo" BORDER="0">&nbsp;
			<BR>
			<A HREF="mg_ttl_6i-2.htm"><SPAN CLASS="copyright">Copyright &copy; 2002, Oracle Corporation.</SPAN></A>&nbsp; <BR>
			<SPAN CLASS="copyright">All Rights Reserved.&nbsp;</SPAN>
		</TD>
		<TD ALIGN="RIGHT" VALIGN="TOP">
			<DIV ALIGN="RIGHT">
				<DIV ALIGN="RIGHT">
					<DIV ALIGN="RIGHT">
						<DIV ALIGN="RIGHT">
							<DIV ALIGN="RIGHT">
								<DIV ALIGN="RIGHT">
									<DIV ALIGN="RIGHT">
										<DIV ALIGN="RIGHT">
											<DIV ALIGN="RIGHT">
												<DIV ALIGN="RIGHT">
													<DIV ALIGN="RIGHT">
														<DIV ALIGN="RIGHT">
															<DIV ALIGN="RIGHT">
																<DIV ALIGN="RIGHT">
																	<DIV ALIGN="RIGHT">
																		<DIV ALIGN="RIGHT">
																			<DIV ALIGN="RIGHT">
																				<DIV ALIGN="RIGHT">
																					<DIV ALIGN="RIGHT">
																						<DIV ALIGN="RIGHT">
																							<DIV ALIGN="RIGHT">
																								<DIV ALIGN="RIGHT">
																									<DIV ALIGN="RIGHT">
																										<DIV ALIGN="RIGHT">
																											<DIV ALIGN="RIGHT">
																												<DIV ALIGN="RIGHT">
																													<DIV ALIGN="RIGHT">
																														<DIV ALIGN="RIGHT">
																															<DIV ALIGN="RIGHT">
																																<DIV ALIGN="RIGHT">
																																	<DIV ALIGN="RIGHT">
																																		<DIV ALIGN="RIGHT">
																																			<DIV ALIGN="RIGHT">
																																				<DIV ALIGN="RIGHT">
																																					<DIV ALIGN="RIGHT">
																																						<DIV ALIGN="RIGHT">
																																							<DIV ALIGN="RIGHT">
																																								<DIV ALIGN="RIGHT">
																																									<DIV ALIGN="RIGHT">
																																										<DIV ALIGN="RIGHT">
																																											<DIV ALIGN="RIGHT">
																																												<DIV ALIGN="RIGHT">
																																													<DIV ALIGN="RIGHT">
																																														<DIV ALIGN="RIGHT">
																																															<DIV ALIGN="RIGHT">
																																																<DIV ALIGN="RIGHT">
																																																	<DIV ALIGN="RIGHT">
																																																		<DIV ALIGN="RIGHT">
																																																			<DIV ALIGN="RIGHT">
																																																			<P>
																																																			<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" summary>
																																																				<TR>
																																																					<TD ALIGN="CENTER">
																																																						<P ALIGN="CENTER"><A HREF="mg_toc_6i-2.htm"><IMG SRC="images/conticon.gif" WIDTH="30" HEIGHT="30" ALIGN="BOTTOM"
																																																						ALT="Contents icon" BORDER="0"></A>
																																																					</TD>
																																																				</TR>
																																																				<TR>
																																																					<TD VALIGN="TOP">
																																																						<P ALIGN="CENTER"><A HREF="mg_toc_6i-2.htm"><SPAN CLASS="copyright">Contents</SPAN></A>
																																																					</TD>
																																																				</TR>
																																																			</TABLE>

</DIV>
																																																		</DIV>
																																																	</DIV>
																																																</DIV>
																																															</DIV>
																																														</DIV>
																																													</DIV>
																																												</DIV>
																																											</DIV>
																																										</DIV>
																																									</DIV>
																																								</DIV>
																																							</DIV>
																																						</DIV>
																																					</DIV>
																																				</DIV>
																																			</DIV>
																																		</DIV>
																																	</DIV>
																																</DIV>
																															</DIV>
																														</DIV>
																													</DIV>
																												</DIV>
																											</DIV>
																										</DIV>
																									</DIV>
																								</DIV>
																							</DIV>
																						</DIV>
																					</DIV>
																				</DIV>
																			</DIV>
																		</DIV>
																	</DIV>
																</DIV>
															</DIV>
														</DIV>
													</DIV>
												</DIV>
											</DIV>
										</DIV>
									</DIV>
								</DIV>
							</DIV>
						</DIV>
					</DIV>
				</DIV>
			</DIV>
		</TD>
	</TR>
</TABLE>


</BODY>

</HTML>