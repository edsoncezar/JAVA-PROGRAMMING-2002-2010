<HTML>
<HEAD>
<TITLE>Day 23 -- Working with Data Structures in Java</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;23</FONT>
</H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Working with Data Structures in
Java</FONT></H1>
<P>
<I><B>by Michael Morrison</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#DataStructureFundamentals">
Data Structure Fundamentals</A>
<LI><A HREF="#TheStandardJavaDataStructures">
The Standard Java Data Structures</A>
<UL>
<LI><A HREF="#Enumerations">
Enumerations</A>
<LI><A HREF="#BitSets">
Bit Sets</A>
<LI><A HREF="#Vectors">
Vectors</A>
<LI><A HREF="#Stacks">
Stacks</A>
<LI><A HREF="#Dictionaries">
Dictionaries</A>
<LI><A HREF="#HashTables">
Hash Tables</A>
</UL>
<LI><A HREF="#BuildingYourOwnDataStructures">
Building Your Own Data Structures</A>
<UL>
<LI><A HREF="#LinkedListBasics">
Linked List Basics</A>
<LI><A HREF="#ImplementingaLinkedList">
Implementing a Linked List</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
Few programs can be developed without at least some usage of data
structures, which are responsible for storing and maintaining
information used by a program. Whether you develop your own data
structures from scratch or rely on those developed and tested
by others, you will undoubtedly need to use data structures at
some point in your Java programming endeavors. Today's lesson
takes a look at data structures as they relate to Java. It covers
the following topics:
<UL>
<LI>Data structure basics
<LI>The standard Java data structures
<LI>Building your own data structures
</UL>
<P>
By the end of today's lesson, you'll have a good idea of what
data structures are readily available in the standard Java packages,
along with some data structures you can implement yourself without
too much pain. Let's get started!
<H2><A NAME="DataStructureFundamentals"><FONT SIZE=5 COLOR=#FF0000>
Data Structure Fundamentals</FONT></A></H2>
<P>
Like algorithms in general, data structures are one of those general
concepts in computer science whose usefulness spreads far and
wide. Consequently, a solid understanding of data structures and
when to apply certain ones is the trademark of any good programmer.
Java programming is no different, and you should take data structures
no less seriously in Java than in any other language. Just because
many Java programs come in the form of applets, which sound cuter
and less auspicious than C or C++ applications, doesn't mean that
they don't rely on a solid means of storing and manipulating data.
<P>
Almost every Java applet works with information to some extent.
Even very simple animation applets that display a series of images
must somehow store the images in such a way that the images can
be referenced quickly. In this example, a very elementary data
structure such as an array might be the best solution, since all
that is required of the data structure is the storage of multiple
images. Even so, consider the fact that every program has its
own set of data requirements that greatly affect the applicability
of different data structures. If you don't understand the full
range of programming options in terms of data structures, you'll
find yourself trying to use an array in every program you write.
This tendency to rely on one solution for all your programming
problems will end up getting you into trouble. In other words,
by understanding how to use a wide variety of data structures,
you broaden your perspective on how to solve the inevitable problems
arising from new programming challenges.
<P>
I mentioned arrays being a very simple data structure. In fact,
outside of member variables themselves, arrays are the most simple
data structure supported by Java. An array is simply an aggregate
series of data elements of the same type. I say that arrays are
aggregate because they are treated as a single entity, just like
any other member variable. However, they actually contain multiple
elements that can be accessed independently. Based on this description,
it's logical that arrays are useful any time you need to store
and access a group of information that is all of the same type.
For example, you could store your picks for a lottery in an array
of integers. However, the glaring limitation of arrays is that
they can't change in size to accommodate more (or fewer) elements.
This means that you can't add new elements to an array that is
already full.
<P>
It turns out that the data requirements for many practical programs
reach far beyond what arrays provide. In other languages, it is
often necessary to develop custom data structures whenever the
requirements go beyond arrays. However, the Java class library
provides a set of data structures in the <TT>java.util</TT>
package that give you a lot more flexibility in how to approach
organizing and manipulating data. There still may be situations
in which these standard data structures don't fit your needs,
in which case you'll have to write your own. You'll learn how
to implement your own custom data structures later in today's
lesson.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Unlike the data structures provided by the <TT>java.util</TT> package, arrays are considered such a core component of the Java language that they are implemented in the language itself. Therefore, you can use arrays in Java without importing any packages.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="TheStandardJavaDataStructures"><FONT SIZE=5 COLOR=#FF0000>
The Standard Java Data Structures</FONT></A></H2>
<P>
The data structures provided by the Java utility package are very
powerful and perform a wide range of functions. These data structures
consist of the following interface and five classes:
<UL>
<LI><TT>Enumeration</TT>
<LI><TT>BitSet</TT>
<LI><TT>Vector</TT>
<LI><TT>Stack</TT>
<LI><TT>Dictionary</TT>
<LI><TT>Hashtable</TT>
</UL>
<P>
The <TT>Enumeration</TT> interface
isn't itself a data structure, but it is very important within
the context of other data structures. The <TT>Enumeration</TT>
interface defines a means to retrieve successive elements from
a data structure. For example, <TT>Enumeration</TT>
defines a method called <TT>nextElement</TT>
that is used to get the next element in a data structure that
contains multiple elements.
<P>
The <TT>BitSet</TT> class implements
a group of bits, or flags, that can be set and cleared individually.
This class is very useful in cases where you need to keep up with
a set of boolean values; you just assign a bit to each value and
set or clear it as appropriate.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>flag</I> is a boolean value that is used to represent one of a group of on/off type states in a program.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>Vector</TT> class is similar
to a traditional Java array, except that it can grow as necessary
to accommodate new elements. Like an array, elements of a <TT>Vector</TT>
object can be accessed via an index into the vector. The nice
thing about using the <TT>Vector</TT>
class is that you don't have to worry about setting it to a specific
size upon creation; it shrinks and grows automatically when necessary.
<P>
The <TT>Stack</TT> class implements
a last-in-first-out (LIFO) stack of elements. You can think of
a stack literally as a vertical stack of objects; when you add
a new element, it gets stacked on top of the others. When you
pull an element off the stack, it comes off the top. In other
words, the last element you added to the stack is the first one
to come back off.
<P>
The <TT>Dictionary</TT> class is an
abstract class that defines a data structure for mapping keys
to values. This is useful in cases where you want to be able to
access data via a particular key rather than an integer index.
Since the <TT>Dictionary</TT> class
is abstract, it provides only the framework for a key-mapped data
structure rather than a specific implementation.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>key</I> is a numeric identifier used to reference, or look up, a value in a data structure.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
An actual implementation of a key-mapped data structure is provided
by the <TT>Hashtable</TT> class. The
<TT>Hashtable</TT> class provides
a means of organizing data based on some user-defined key structure.
For example, in an address list hash table you could store and
sort data based on a key such as ZIP code rather than on a person's
name. The specific meaning of keys in regard to hash tables is
totally dependent on the usage of the hash table and the data
it contains.
<P>
That pretty well sums up the data structures provided by the Java
utility package. Now that you have a cursory understanding of
them, let's dig into each in a little more detail and see how
they work.
<H3><A NAME="Enumerations">
Enumerations</A></H3>
<P>
The <TT>Enumeration</TT> interface
provides a standard means of iterating through a list of sequentially
stored elements, which is a common task of many data structures.
Even though you can't use the interface outside the context of
a particular data structure, understanding how it works will put
you well on your way to understanding other Java data structures.
With that in mind, take a look at the only two methods defined
by the <TT>Enumeration</TT> interface:
<BLOCKQUOTE>
<PRE>
public abstract boolean hasMoreElements();
public abstract Object nextElement();
</PRE>
</BLOCKQUOTE>
<P>
The <TT>hasMoreElements</TT> method
is used to determine if the enumeration contains any more elements.
You will typically call this method to see if you can continue
iterating through an enumeration. An example of this is calling
<TT>hasMoreElements</TT> in the conditional
clause of a <TT>while</TT> loop that
is iterating through an enumeration.
<P>
The <TT>nextElement</TT> method is
responsible for actually retrieving the next element in an enumeration.
If no more elements are in the enumeration, <TT>nextElement</TT>
will throw a <TT>NoSuchElementException</TT>
exception. Since you want to avoid generating exceptions whenever
possible, you should always use <TT>hasMoreElements</TT>
in conjunction with <TT>nextElement</TT>
to make sure there is another element to retrieve. Following is
an example of a <TT>while</TT> loop
that uses these two methods to iterate through a data structure
object that implements the <TT>Enumeration</TT>
interface:
<BLOCKQUOTE>
<PRE>
// e is an object that implements the Enumeration interface
while (e.hasMoreElements()) {
  Object o = e.nextElement();
  System.out.println(o);
}
</PRE>
</BLOCKQUOTE>
<P>
This sample code prints out the contents of an enumeration using
the <TT>hasMoreElements</TT> and <TT>nextElement</TT>
methods. Pretty simple!<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Since <TT>Enumeration</TT> is an interface, you'll never actually use it as a data structure directly. Rather, you will use the methods defined by <TT>Enumeration</TT> within the context of other data structures. The significance of this architecture is 
that it provides a consistent interface for many of the standard data structures, which makes them easier to learn and use.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="BitSets">
Bit Sets</A></H3>
<P>
The <TT>BitSet</TT> class is useful
whenever you need to represent a group of boolean flags. The nice
thing about the <TT>BitSet</TT> class
is that it allows you to use individual bits to store boolean
values without the mess of having to extract bit values using
bitwise operations; you simply refer to each bit using an index.
Another nice feature about the <TT>BitSet</TT>
class is that it automatically grows to represent the number of
bits required by a program. Figure 23.1 shows the logical organization
of a bit set data structure.
<P>
<A HREF="f23-1.gif"><B>Figure 23.1 : </B><I>The logical organization of a bit set data
structure</I>.</A>
<P>
For example, you can use <TT>BitSet</TT>
as an object that has a number of attributes that can easily be
modeled by boolean values. Since the individual bits in a bit
set are accessed via an index, you can define each attribute as
a constant index value:
<BLOCKQUOTE>
<PRE>
class someBits {
  public static final int readable = 0;
  public static final int writeable = 1;
  public static final int streamable = 2;
  public static final int flexible = 3;
}
</PRE>
</BLOCKQUOTE>
<P>
Notice that the attributes are assigned increasing values, beginning
with <TT>0</TT>. You can use these
values to get and set the appropriate bits in a bit set. But first,
you need to create a <TT>BitSet</TT>
object:
<BLOCKQUOTE>
<PRE>
BitSet bits = new BitSet();
</PRE>
</BLOCKQUOTE>
<P>
This constructor creates a bit set with no specified size. You
can also create a bit set with a specific size:
<BLOCKQUOTE>
<PRE>
BitSet bits = new BitSet(4);
</PRE>
</BLOCKQUOTE>
<P>
This creates a bit set containing four boolean bit fields. Regardless
of the constructor used, all bits in new bit sets are initially
set to <TT>false</TT>. Once you have
a bit set created, you can easily set and clear the bits using
the <TT>set</TT> and <TT>clear</TT>
methods along with the bit constants you defined:
<BLOCKQUOTE>
<PRE>
bits.set(someBits.writeable);
bits.set(someBits.streamable);
bits.set(someBits.flexible);
bits.clear(someBits.writeable);
</PRE>
</BLOCKQUOTE>
<P>
In this code, the <TT>writeable</TT>,
<TT>streamable</TT>, and <TT>flexible</TT>
attributes are set, and then the <TT>writeable</TT>
bit is cleared. Notice that the fully qualified name is used for
each attribute, since the attributes are declared as static in
the <TT>someBits</TT> class.
<P>
You can get the value of individual bits in a bit set using the
<TT>get</TT> method:
<BLOCKQUOTE>
<PRE>
boolean canIWrite = bits.get(someBits.writeable);
</PRE>
</BLOCKQUOTE>
<P>
You can find out how many bits are being represented by a bit
set using the <TT>size</TT> method.
An example of this follows:
<BLOCKQUOTE>
<PRE>
int numBits = bits.size();
</PRE>
</BLOCKQUOTE>
<P>
The <TT>BitSet</TT> class also provides
other methods for performing comparisons and bitwise operations
on bit sets such as <TT>AND</TT>,
<TT>OR</TT>, and <TT>XOR</TT>.
All these methods take a <TT>BitSet</TT>
object as their only parameter.
<H3><A NAME="Vectors">
Vectors</A></H3>
<P>
The <TT>Vector</TT> class implements
a growable array of objects. Since the <TT>Vector</TT>
class is responsible for growing itself as necessary to support
more elements, it has to decide when and by how much to grow as
new elements are added. You can easily control this aspect of
vectors upon creation. Before getting into that, however, take
a look at how to create a basic vector:
<BLOCKQUOTE>
<PRE>
Vector v = new Vector();
</PRE>
</BLOCKQUOTE>
<P>
That's about as simple as it gets! This constructor creates a
default vector containing no elements. Actually, all vectors are
empty upon creation. One of the attributes important to how a
vector sizes itself is the initial capacity of a vector, which
is how many elements the vector allocates memory for by default.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <I>size</I> of a vector is the number of elements currently stored in the vector.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <I>capacity</I> of a vector is the amount of memory allocated to hold elements, and is always greater than or equal to the size.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The following code shows how to create a vector with a specified
capacity:
<BLOCKQUOTE>
<PRE>
Vector v = new Vector(25);
</PRE>
</BLOCKQUOTE>
<P>
This vector is created to immediately support up to 25 elements.
In other words, the vector will go ahead and allocate enough memory
to support 25 elements. Once 25 elements have been added, however,
the vector must decide how to grow itself to accept more elements.
You can specify the value by which a vector grows using yet another
<TT>Vector</TT> constructor:
<BLOCKQUOTE>
<PRE>
Vector v = new Vector(25, 5);
</PRE>
</BLOCKQUOTE>
<P>
This vector has an initial size of 25 elements, and will grow
in increments of 5 elements whenever its size grows to more than
25 elements. This means that the vector will first jump to 30
elements in size, then 35, and so on. A smaller grow value for
a vector results in more efficient memory management, but at the
cost of more execution overhead since more memory allocations
are taking place. On the other hand, a larger grow value results
in fewer memory allocations, but sometimes memory may be wasted
if you don't use all the extra space created.
<P>
Unlike with arrays, you can't just use square brackets (<TT>[]</TT>)
to access the elements in a vector; you have to use methods defined
in the <TT>Vector</TT> class. To add
an element to a vector, you use the <TT>addElement</TT>
method:
<BLOCKQUOTE>
<PRE>
v.addElement(&quot;carrots&quot;);
v.addElement(&quot;broccoli&quot;);
v.addElement(&quot;cauliflower&quot;);
</PRE>
</BLOCKQUOTE>
<P>
This code shows how to add some vegetable strings to a vector.
To get the last string added to the vector, you can use the <TT>lastElement</TT>
method:
<BLOCKQUOTE>
<PRE>
String s = (String)v.lastElement();
</PRE>
</BLOCKQUOTE>
<P>
The <TT>lastElement</TT> method retrieves
the last element added to the vector. Notice that you have to
cast the return value of <TT>lastElement</TT>,
since the <TT>Vector</TT> class is
designed to work with the generic <TT>Object</TT>
class. Although <TT>lastElement</TT>
certainly has its usefulness, you will probably find more use
with the <TT>elementAt</TT> method,
which allows you to index into a vector to retrieve an element.
Following is an example of using the <TT>elementAt</TT>
method:
<BLOCKQUOTE>
<PRE>
String s1 = (String)v.elementAt(0);
String s2 = (String)v.elementAt(2);
</PRE>
</BLOCKQUOTE>
<P>
Since vectors are zero based, the first call to <TT>elementAt</TT>
retrieves the <TT>&quot;carrots&quot;</TT>
string, and the second call retrieves the <TT>&quot;cauliflower&quot;</TT>
string. Just as you can retrieve an element at a particular index,
you can also add and remove elements at an index using the <TT>insertElementAt</TT>
and <TT>removeElementAt</TT> methods:
<BLOCKQUOTE>
<PRE>
v.insertElementAt(&quot;squash&quot;, 1);
v.insertElementAt(&quot;corn&quot;, 0);
v.removeElementAt(3);
</PRE>
</BLOCKQUOTE>
<P>
The first call to <TT>insertElementAt</TT>
inserts an element at index 1, between the <TT>&quot;carrots&quot;</TT>
and <TT>&quot;broccoli&quot;</TT>
strings. The <TT>&quot;broccoli&quot;</TT>
and <TT>&quot;cauliflower&quot;</TT>
strings are moved up a space in the vector to accommodate the
inserted <TT>&quot;squash&quot;</TT>
string. The second call to <TT>insertElementAt</TT>
inserts an element at index <TT>0</TT>,
which is the beginning of the vector. In this case, all existing
elements are moved up a space in the vector to accommodate the
inserted <TT>&quot;corn&quot;</TT>
string. At this point, the contents of the vector look like this:
<BLOCKQUOTE>
<PRE>
&quot;corn&quot;
&quot;carrots&quot;
&quot;squash&quot;
&quot;broccoli&quot;
&quot;cauliflower&quot;
</PRE>
</BLOCKQUOTE>
<P>
The call to <TT>removeElementAt</TT>
removes the element at index <TT>3</TT>,
which is the <TT>&quot;broccoli&quot;</TT>
string. The resulting contents of the vector consist of the following
strings:
<BLOCKQUOTE>
<PRE>
&quot;corn&quot;
&quot;carrots&quot;
&quot;squash&quot;
&quot;cauliflower&quot;
</PRE>
</BLOCKQUOTE>
<P>
You can use the <TT>setElementAt</TT>
method to change a specific element:
<BLOCKQUOTE>
<PRE>
v.setElementAt(&quot;peas&quot;, 1);
</PRE>
</BLOCKQUOTE>
<P>
This method replaces the <TT>&quot;carrots&quot;</TT>
string with the <TT>&quot;peas&quot;</TT>
string, resulting in the following vector contents:
<BLOCKQUOTE>
<PRE>
&quot;corn&quot;
&quot;peas&quot;
&quot;squash&quot;
&quot;cauliflower&quot;
</PRE>
</BLOCKQUOTE>
<P>
If you want to clear out the vector completely, you can remove
all the elements with the <TT>removeAllElements</TT>
method:
<BLOCKQUOTE>
<PRE>
v.removeAllElements();
</PRE>
</BLOCKQUOTE>
<P>
The <TT>Vector</TT> class also provides
some methods for working with elements without using indexes.
These methods actually search through the vector for a particular
element. The first of these methods is the <TT>contains</TT>
method, which simply checks to see if an element is in the vector:
<BLOCKQUOTE>
<PRE>
boolean isThere = v.contains(&quot;celery&quot;);
</PRE>
</BLOCKQUOTE>
<P>
Another method that works in this manner is the <TT>indexOf</TT>
method, which finds the index of an element based on the element
itself:
<BLOCKQUOTE>
<PRE>
int i = v.indexOf(&quot;squash&quot;);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>indexOf</TT> method returns
the index of the element in question if it is in the vector, or
<BR>
<TT>-1</TT> if not. The <TT>removeElement</TT>
method works similarly in that it removes an element based on
the element itself rather than on an index:
<BLOCKQUOTE>
<PRE>
v.removeElement(&quot;cauliflower&quot;);
</PRE>
</BLOCKQUOTE>
<P>
If you're interested in working with all the elements in a vector
sequentially, you can use the <TT>elements</TT>
method, which returns an enumeration of the elements:
<BLOCKQUOTE>
<PRE>
Enumeration e = v.elements();
</PRE>
</BLOCKQUOTE>
<P>
Recall from earlier in today's lesson that you can use an enumeration
to step through elements sequentially. In this example, you can
work with the enumeration <TT>e</TT>
using the methods defined by the <TT>Enumeration</TT>
interface.
<P>
You may find yourself wanting to work with the size of a vector.
Fortunately, the <TT>Vector</TT> class
provides a few methods for determining and manipulating the size
of a vector. First, the <TT>size</TT>
method determines the number of elements in the vector:
<BLOCKQUOTE>
<PRE>
int size = v.size();
</PRE>
</BLOCKQUOTE>
<P>
If you want to explicitly set the size of a vector, you can use
the <TT>setSize</TT> method:
<BLOCKQUOTE>
<PRE>
v.setSize(10);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>setSize</TT> method expands
or truncates the vector to accommodate the new size specified.
If the vector is expanded because of a larger size, null elements
are inserted as the newly added elements. If the vector is truncated,
any elements at indexes beyond the specified size are discarded.
<P>
If you recall, vectors have two different attributes relating
to size: size and capacity. The size is the number of elements
in the vector and the capacity is the amount of memory allocated
to hold all elements. The capacity is always greater than or equal
to the size. You can force the capacity to exactly match the size
using the <TT>trimToSize</TT> method:
<BLOCKQUOTE>
<PRE>
v.trimToSize();
</PRE>
</BLOCKQUOTE>
<P>
You can also check to see what the capacity is, using the <TT>capacity</TT>
method:
<BLOCKQUOTE>
<PRE>
int capacity = v.capacity();
</PRE>
</BLOCKQUOTE>
<P>
You'll find that the <TT>Vector</TT>
class is one of the most useful data structures provided in the
Java API. Hopefully this tour of the class gives you an idea of
how powerful vectors are and how easy it is to use them.
<H3><A NAME="Stacks">
Stacks</A></H3>
<P>
Stacks are a classic data structure used to model information
that is accessed in a specific order. The <TT>Stack</TT>
class in Java is implemented as a last-in-first-out (LIFO) stack,
which means that the last item added to the stack is the first
one to come back off. Figure 23.2 shows the logical organization
of a stack.
<P>
<A HREF="f23-2.gif"><B>Figure 23.2 : </B><I>The logical organization of a stack data
structure</I>.</A>
<P>
You may be wondering from Figure 23.2 why the numbers of the elements
don't match their position from the top of the stack. Keep in
mind that elements are added to the top, so <TT>Element0</TT>,
which is on the bottom, was the first element added to the stack.
Likewise, <TT>Element3</TT>, which
is on top, is the last element added to the stack. Also, since
<TT>Element3</TT> is at the top of
the stack, it will be the first to come back off.
<P>
The <TT>Stack</TT> class only defines
one constructor, which is a default constructor that creates an
empty stack. You use this constructor to create a stack like this:
<BLOCKQUOTE>
<PRE>
Stack s = new Stack();
</PRE>
</BLOCKQUOTE>
<P>
You add new elements to a stack using the <TT>push</TT>
method, which pushes an element onto the top of the stack:
<BLOCKQUOTE>
<PRE>
s.push(&quot;One&quot;);
s.push(&quot;Two&quot;);
s.push(&quot;Three&quot;);
s.push(&quot;Four&quot;);
s.push(&quot;Five&quot;);
s.push(&quot;Six&quot;);
</PRE>
</BLOCKQUOTE>
<P>
This code pushes six strings onto the stack, with the last string
(<TT>&quot;Six&quot;</TT>) remaining
on top. You pop elements back off the stack using the <TT>pop</TT>
method:
<BLOCKQUOTE>
<PRE>
String s1 = (String)s.pop();
String s2 = (String)s.pop();
</PRE>
</BLOCKQUOTE>
<P>
This code pops the last two strings off the stack, leaving the
first four strings remaining. This code results in the <TT>s1</TT>
variable containing the <TT>&quot;Six&quot;</TT>
string and the <TT>s2</TT> variable
containing the <TT>&quot;Five&quot;</TT>
string.
<P>
If you want to get the top element on the stack without actually
popping it off the stack, you can use the <TT>peek</TT>
method:
<BLOCKQUOTE>
<PRE>
String s3 = (String)s.peek();
</PRE>
</BLOCKQUOTE>
<P>
This call to <TT>peek</TT> returns
the <TT>&quot;Four&quot;</TT> string
but leaves the string on the stack. You can search for an element
on the stack using the <TT>search</TT>
method:
<BLOCKQUOTE>
<PRE>
int i = s.search(&quot;Two&quot;);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>search</TT> method returns
the distance from the top of the stack of the element if it is
found, or <TT>-1</TT> if not. In this
case, the <TT>&quot;Two&quot;</TT>
string is the third element from the top, so the <TT>search</TT>
method returns <TT>2</TT> (zero based).
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
As in all Java data structures that deal with indexes or lists, the <TT>Stack</TT> class reports element position in a zero-based fashion. This means that the top element in a stack has a location of 0, and the fourth element down in a stack has a location 
of 3.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The only other method defined in the <TT>Stack</TT>
class is <TT>empty</TT>, which determines
whether a stack is empty:
<BLOCKQUOTE>
<PRE>
boolean isEmpty = s.empty();
</PRE>
</BLOCKQUOTE>
<P>
Although maybe not quite as useful as the <TT>Vector</TT>
class, the <TT>Stack</TT> class provides
the functionality for a very common and established data structure.
<H3><A NAME="Dictionaries">
Dictionaries</A></H3>
<P>
The <TT>Dictionary</TT> class defines
a framework for implementing a basic key-mapped data structure.
Although you can't actually create <TT>Dictionary</TT>
objects since the class is abstract, you can still learn a lot
about key-mapped data modeling by learning how the <TT>Dictionary</TT>
class works. You can put the key-mapped approach to work using
the <TT>Hashtable</TT> class, which
is derived from <TT>Dictionary</TT>,
or by deriving your own class from <TT>Dictionary</TT>.
You learn about the <TT>Hashtable</TT>
class in the next section of today's lesson.
<P>
The <TT>Dictionary</TT> class defines
a means of storing information based on a key. This is similar
in some ways to how the <TT>Vector</TT>
class works, in that elements in a vector are accessed via an
index, which is a specific type of key. However, keys in the <TT>Dictionary</TT>
class can be just about anything. You can create your own class
to use as the keys for accessing and manipulating data in a dictionary.
Figure 23.3 shows how keys map to data in a dictionary.
<P>
<A HREF="f23-3.gif"><B>Figure 23.3 : </B><I>The logical organization of a dictionary
data structure</I>.</A>
<P>
The <TT>Dictionary</TT> class defines
a variety of methods for working with the data stored in a dictionary.
All these methods are defined as abstract, meaning that derived
classes will have to implement all of them to actually be useful.
The <TT>put</TT> and <TT>get</TT>
methods are used to put objects in the dictionary and get them
back. Assuming <TT>dict</TT> is a
<TT>Dictionary</TT>-derived class
that implements these methods, the following code shows how to
use the <TT>put</TT> method to add
elements to a dictionary:
<BLOCKQUOTE>
<PRE>
dict.put(&quot;small&quot;, new Rectangle(0, 0, 5, 5));
dict.put(&quot;medium&quot;, new Rectangle(0, 0, 15, 15));
dict.put(&quot;large&quot;, new Rectangle(0, 0, 25, 25));
</PRE>
</BLOCKQUOTE>
<P>
This code adds three rectangles to the dictionary, using strings
as the keys. To get an element from the dictionary, you use the
<TT>get</TT> method and specify the
appropriate key:
<BLOCKQUOTE>
<PRE>
Rectangle r = (Rectangle)dict.get(&quot;medium&quot;);
</PRE>
</BLOCKQUOTE>
<P>
You can also remove an element from the dictionary with a key
using the <TT>remove</TT> method:
<BLOCKQUOTE>
<PRE>
dict.remove(&quot;large&quot;);
</PRE>
</BLOCKQUOTE>
<P>
You can find out how many elements are in the dictionary using
the <TT>size</TT> method, much as
you did with the <TT>Vector</TT> class:
<BLOCKQUOTE>
<PRE>
int size = dict.size();
</PRE>
</BLOCKQUOTE>
<P>
You can also check whether the dictionary is empty using the <TT>isEmpty</TT>
method:
<BLOCKQUOTE>
<PRE>
boolean isEmpty = dict.isEmpty();
</PRE>
</BLOCKQUOTE>
<P>
Finally, the <TT>Dictionary</TT> class
includes two methods for enumerating the keys and values contained
within: <TT>keys</TT> and <TT>elements</TT>.
The <TT>keys</TT> method returns an
enumeration containing all the keys contained in a dictionary,
while the <TT>elements</TT> method
returns an enumeration of all the key-mapped values contained.
Following is an example of retrieving both enumerations:
<BLOCKQUOTE>
<PRE>
Enumeration keys = dict.keys();
Enumeration elements = dict.elements();
</PRE>
</BLOCKQUOTE>
<P>
Note that since keys are mapped to elements on a one-to-one basis,
these enumerations are of equal length.
<H3><A NAME="HashTables">
Hash Tables</A></H3>
<P>
The <TT>Hashtable</TT> class is derived
from <TT>Dictionary</TT> and provides
a complete implementation of a key-mapped data structure. Similar
to dictionaries, hash tables allow you to store data based on
some type of key. Unlike dictionaries, hash tables have an efficiency
associated with them defined by the load factor of the table.
<P>
The <I>load factor</I> of a hash table is a number between 0.0
and 1.0 that determines how and when the hash table allocates
space for more elements.
<P>
Like vectors, hash tables have a capacity, which is the amount
of memory allocated for the table. Hash tables allocate more memory
by comparing the current size of the table with the product of
the capacity and the load factor. If the size of the hash table
exceeds this product, the table increases its capacity by rehashing
itself.
<P>
Load factors closer to 1.0 result in a more efficient use of memory
at the expense of a longer look-up time for each element. Similarly,
load factors closer to 0.0 result in more efficient look-ups but
also tend to be more wasteful with memory. Determining the load
factor for your own hash tables is really dependent on the usage
of the hash table and whether your priority is on performance
or memory efficiency.
<P>
You create hash tables using one of three methods. The first method
creates a default hash table:
<BLOCKQUOTE>
<PRE>
Hashtable hash = new Hashtable();
</PRE>
</BLOCKQUOTE>
<P>
The second constructor creates a hash table with the specified
initial capacity:
<BLOCKQUOTE>
<PRE>
Hashtable hash = new Hashtable(20);
</PRE>
</BLOCKQUOTE>
<P>
Finally, the third constructor creates a hash table with the specified
initial capacity and load factor:
<BLOCKQUOTE>
<PRE>
Hashtable hash = new Hashtable(20, 0.75);
</PRE>
</BLOCKQUOTE>
<P>
All the abstract methods defined in <TT>Dictionary</TT>
are implemented in the <TT>Hashtable</TT>
class. Since these methods perform the exact same function in
<TT>Hashtable</TT>, there's no need
to cover them again. However, they are listed here just so you'll
have an idea of what support <TT>Hashtable</TT>
provides:
<BLOCKQUOTE>
<PRE>
elements
get
isEmpty
keys
put
remove
size
</PRE>
</BLOCKQUOTE>
<P>
In addition to these methods, the <TT>Hashtable</TT>
class implements a few others that perform functions specific
to supporting hash tables. One of these is the <TT>clear</TT>
method, which clears a hash table of all its keys and elements:
<BLOCKQUOTE>
<PRE>
hash.clear();
</PRE>
</BLOCKQUOTE>
<P>
The <TT>contains</TT> method is used
to see if an object is stored in the hash table. This method searches
for an object value in the hash table rather than a key. The following
code shows how to use the <TT>contains</TT>
method:
<BLOCKQUOTE>
<PRE>
boolean isThere = hash.contains(new Rectangle(0, 0, 5, 5));
</PRE>
</BLOCKQUOTE>
<P>
Similar to <TT>contains</TT>, the
<TT>containsKey</TT> method searches
a hash table, but it searches based on a key rather than a value:
<BLOCKQUOTE>
<PRE>
boolean isThere = hash.containsKey(&quot;Small&quot;);
</PRE>
</BLOCKQUOTE>
<P>
I mentioned earlier that a hash table will rehash itself when
it determines that it must increase its capacity. You can force
a rehash yourself by calling the <TT>rehash</TT>
method:
<BLOCKQUOTE>
<PRE>
hash.rehash();
</PRE>
</BLOCKQUOTE>
<P>
That pretty much sums up the important methods implemented by
the <TT>Hashtable</TT> class. Even
though you've seen all the methods, you still may be wondering
exactly how the <TT>Hashtable</TT>
class is useful. The practical usage of a hash table is actually
in representing data that is too time-consuming to search or reference
by value. In other words, hash tables often come in handy when
you're working with complex data, where it's much more efficient
to access the data using a key rather than by comparing the data
objects themselves. Furthermore, hash tables typically compute
a key for elements, which is called a hash code. For example,
an object such as a string can have an integer hash code computed
for it that uniquely represents the string. When a bunch of strings
are stored in a hash table, the table can access the strings using
integer hash codes as opposed to using the contents of the strings
themselves. This results in much more efficient searching and
retrieving capabilities.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>hash code</I> is a computed key that uniquely identifies each element in a hash table.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
This technique of computing and using hash codes for object storage
and reference is exploited heavily throughout the Java system.
This is apparent in the fact that the parent of all classes, <TT>Object</TT>,
defines a <TT>hashCode</TT> method
that is overridden in most standard Java classes. Any class that
defines a <TT>hashCode</TT> method
can be efficiently stored and accessed in a hash table. A class
wishing to be hashed must also implement the <TT>equals</TT>
method, which defines a way of telling if two objects are equal.
The <TT>equals</TT> method usually
just performs a straight comparison of all the member variables
defined in a class.
<P>
Hash tables are an extremely powerful data structure that you
will probably want to integrate into some of your programs that
manipulate large amounts of data. The fact that they are so widely
supported in the Java API via the <TT>Object</TT>
class should give you a clue as to their importance in Java programming.
<H2><A NAME="BuildingYourOwnDataStructures"><FONT SIZE=5 COLOR=#FF0000>
Building Your Own Data Structures</FONT></A></H2>
<P>
Even though the Java utility package provides some very powerful
and useful data structures, there may be situations in which you
need something a little different. I encourage you to make the
most of the standard Java data structures whenever possible, since
reusing stable code is always a smarter solution than writing
your own code. However, in cases where the standard data structures
just don't seem to fit, you may need to turn your attention toward
other options.
<P>
Throughout the rest of today's lesson you'll learn all about one
of these other options. More specifically, you'll learn about
linked lists, which are a very useful type of data structure not
provided in the standard Java data structures. Not only will you
learn about linked lists, but you'll also develop your own linked
list class that you can reuse in your own Java programs. You'll
see that building custom data structures isn't all that difficult.
Let's get started!
<H3><A NAME="LinkedListBasics">
Linked List Basics</A></H3>
<P>
Like vectors and arrays, linked lists are used to store a sequential
list of objects. The primary difference between these data structures
is that arrays and vectors are better at referencing elements
via a numeric index, whereas linked lists are better at accessing
data in a purely sequential manner. In other words, linked lists
aren't suited for the type of random access provided by arrays
and vectors. This may seem like a limitation of linked lists,
but it is in fact what makes them unique as a data structure;
they are much more efficient when it comes to adding, inserting,
and removing elements.
<P>
To get a better idea of why linked lists have the properties mentioned,
take a look at the logical organization of linked lists shown
in Figure 23.4.
<P>
<A HREF="f23-4.gif"><B>Figure 23.4 : </B><I>The logical organization of a doubly linked
list data structure</I>.</A>
<P>
The figure shows the linked list having a distinct start and end,
which is somewhat different from arrays and vectors. Sure, arrays
and vectors have a first element and a last element, but the elements
have no more significance than any other elements. The start and
end of linked lists are a strict requirement since linked lists
don't hold elements in a fixed amount of memory. This actually
touches on the biggest difference between linked lists and vectors/arrays.
Linked lists simply hold references to the start and end elements
contained within, whereas vectors and arrays contain references
to all of their elements.
<P>
Another key point to note from Figure 23.4 is that each element
in a linked list contains a reference to both the element before
and the element after it. This is how elements in linked lists
are accessed: by traversing the list through the references to
successive elements. In other words, to get the third element
in a linked list, you have to start with the first element and
follow its reference to the second element, and then repeat the
process to get to the third element. This may seem like a tedious
process, but it actually works quite well in some situations.
<P>
In the discussion thus far, I've glossed over one fine point in
regard to linked lists, and that is the two types of linked lists.
The type shown in Figure 23.4 is called a <I>doubly linked list</I>
because it contains references to both the element following and
the element preceding a particular element. Another popular type
of linked list is the <I>singly linked list</I>, where each element
contains only a reference to the element following it. Figure
23.5 shows the logical organization of a singly linked list.
<P>
<A HREF="f23-5.gif"><B>Figure 23.5 : </B><I>The logical organization of a singly linked
list data structure</I>.</A>
<P>
Since doubly linked lists tend to be more general and therefore
have a wider range of application, you'll focus on them in today's
lesson. Besides, a doubly linked list is really just a singly
linked list with more features, which means you can use it just
like a singly linked list if you want.
<H3><A NAME="ImplementingaLinkedList">
Implementing a Linked List</A></H3>
<P>
Now that you have an idea of what a linked list is, let's go ahead
and take a stab at developing a fully functioning linked list
class. Before jumping into the details of a specific linked list
implementation, however, consider the fact that the linked list
class you're developing is actually an extension to the standard
Java data structures you learned about earlier today. This means
that it is to your advantage to design the class to fit in well
with the design of the existing data structures. A good approach,
then, would be to model the linked list class around the <TT>Vector</TT>
class, at least in regard to some of the basic techniques of manipulating
elements through methods. The reason for this is so anyone else
using your linked list class can easily see how to use the class
based on their understanding of other standard Java classes like
<TT>Vector</TT>. This mindset in terms
of extending the standard Java classes is very important when
it comes to writing reusable code.
<P>
Even though I've been discussing the linked list implementation
in terms of a single class, it turns out that it takes a few classes
to realistically build a complete linked list. These classes consist
of a linked list class, a linked list entry class, and a linked
list enumeration class. The linked list class models the list
itself and is the only class anyone using the linked list will
come into contact with. The other two classes are helper classes
that provide some type of behind-the-scenes functionality for
the linked list class. The linked list entry class models an individual
element within the linked list, and the linked list enumerator
class provides support for the <TT>Enumeration</TT>
interface.
<P>
Since it is by far the most simple of the three classes, let's
start by looking at the linked list entry class, which is called
<TT>LinkedListEntry</TT>:
<BLOCKQUOTE>
<PRE>
class LinkedListEntry {
  protected Object          val = null;
  protected LinkedListEntry next = null;
  protected LinkedListEntry prev = null;

  public LinkedListEntry(Object obj) {
    // Make sure the object is valid
    if (obj == null)
      throw new NullPointerException();

    val = obj;
  }
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>LinkedListEntry</TT> class
contains three member variables that keep up with the value of
the entry (the element being stored) and a reference to the next
and previous elements. This class has a single constructor defined,
which simply checks the validity of the object being stored in
the entry and assigns it to the entry's <TT>val</TT>
member variable.
<P>
Based on the simplicity of <TT>LinkedListEntry</TT>,
you're probably guessing that most of the functionality of the
linked list is provided by the main linked list class. You guessed
right! This class is called <TT>LinkedList</TT>
and contains a few member variables, which follow:
<BLOCKQUOTE>
<PRE>
protected LinkedListEntry start = null;
protected LinkedListEntry end = null;
protected int             numElements;
</PRE>
</BLOCKQUOTE>
<P>
The <TT>start</TT> and <TT>end</TT>
member variables hold references to the beginning and end elements
in the list, while the <TT>numElements</TT>
member keeps up with the size of the list. There are also a variety
of methods defined in the <TT>LinkedList</TT>
class that resemble methods in the <TT>Vector</TT>
class. One of the most important methods is <TT>addElement</TT>,
which adds a new element to the end of the list. The source code
for <TT>addElement</TT> is shown in
Listing 23.1.
<HR>
<BLOCKQUOTE>
<B>Listing 23.1. The </B><TT><B>LinkedList</B></TT><B>
class's </B><TT><B>addElement</B></TT><B>
method.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: public void addElement(Object obj) {
 2:   // Make sure the object is valid
 3:   if (obj == null)
 4:     throw new NullPointerException();
 5:
 6:   // Create the new entry
 7:   LinkedListEntry newElement = new LinkedListEntry(obj);
 8:   numElements++;
 9:
10:   // See if the new element is the start of the list
11:   if (start == null) {
12:     start = newElement;
13:     end = newElement;
14:   }
15:   else {
16:     end.next = newElement;
17:     newElement.prev = end;
18:     end = newElement;
19:   }
20: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>addElement</TT> method first checks to make sure the new object is valid. It then creates an entry to hold the object and checks to see if the new element will be placed at the start of the list. <TT>addElement</TT> then adjusts the references of 
elements related to the new element so the list's structure is maintained.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
Just as the <TT>addElement</TT> method
is important for adding a new element to the end of the list,
the <TT>insertElementAt</TT> method
is useful for inserting a new element at any point in the list.
Listing 23.2 contains the source code for <TT>insertElementAt</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 23.2. The </B><TT><B>LinkedList</B></TT><B>
class's </B><TT><B>insertElementAt</B></TT><B>
method.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: public void insertElementAt(Object obj, Object pos) {
 2:   // Make sure the objects are valid
 3:   if (obj == null || pos == null)
 4:     throw new NullPointerException();
 5:
 6:   // Make sure the position object is in the list
 7:   LinkedListEntry posEntry = find(pos);
 8:   if (posEntry == null)
 9:     throw new NullPointerException();
10:
11:   // Create the new entry
12:   LinkedListEntry newElement = new LinkedListEntry(obj);
13:   numElements++;
14:
15:   // Link in the new entry
16:   newElement.next = posEntry;
17:   newElement.prev = posEntry.prev;
18:   if (posEntry == start)
19:     start = newElement;
20:   else
21:     posEntry.prev.next = newElement;
22:   posEntry.prev = newElement;
23: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>insertElementAt</TT> method takes two parameters that specify the new object to be added to the list, along with the object at the position where the new object is to be inserted. <TT>insertElementAt</TT> first makes sure both objects are valid; 
then it checks to see if the position object is in the list. If things are okay at this point, a new entry is created to hold the new object, and the references of adjacent elements are adjusted to reflect the insertion.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
At this point you have two methods that allow you to add and insert
elements to the linked list. However, there still isn't any means
to remove elements from the list. Enter the <TT>removeElement</TT>
method! Listing 23.3 contains the source code for <TT>removeElement</TT>,
which allows you to remove an element by specifying the object
itself.
<HR>
<BLOCKQUOTE>
<B>Listing 23.3. The </B><TT><B>LinkedList</B></TT><B>
class's </B><TT><B>removeElement</B></TT><B>
method.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: public boolean removeElement(Object obj) {
 2:   // Make sure the object is valid
 3:   if (obj == null)
 4:     throw new NullPointerException();
 5:
 6:   // Make sure the object is in the list
 7:   LinkedListEntry delEntry = find(obj);
 8:   if (delEntry == null)
 9:     return false;
10:
11:   // Unlink the entry
12:   numElements--;
13:   if (delEntry == start)
14:     start = delEntry.next;
15:   else
16:     delEntry.prev.next = delEntry.next;
17:   if (delEntry == end)
18:     end = delEntry.prev;
19:   else
20:     delEntry.next.prev = delEntry.prev;
21:   return true;
22: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>removeElement</TT> method first checks to see if the object passed in is valid, and then searches to make sure the object is in the list. It performs the search by calling the <TT>find</TT> method, which is a private method you'll learn about in 
just a moment. Upon finding the entry in the list, the <TT>removeElement</TT> method unlinks the entry by adjusting the references of adjacent entries.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>find</TT> method is a private
method used internally by the <TT>LinkedList</TT>
class to find entries in the list based on the object they store.
Following is the source code for the <TT>find</TT>
method:
<BLOCKQUOTE>
<PRE>
private LinkedListEntry find(Object obj) {
  // Make sure the list isn't empty and the object is valid
  if (isEmpty() || obj == null)
    return null;

  // Search the list for the object
  LinkedListEntry tmp = start;
  while (tmp != null) {
    if (tmp.val == obj)
      return tmp;
    tmp = tmp.next;
  }
  return null;
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>find</TT> method first checks
to make sure the list isn't empty and that the object in question
is valid. It then traverses the list using a <TT>while</TT>
loop, checking the <TT>val</TT> member
variable of each entry against the object passed in. If there
is a match, the entry holding the object is returned; otherwise,
<TT>null</TT> is returned.
<P>
The <TT>find</TT> method isn't public
because you don't want outside users of the <TT>LinkedList</TT>
class to know anything about the <TT>LinkedListEntry</TT>
class. In other words, the <TT>LinkedListEntry</TT>
class is a purely internal helper class, so the <TT>LinkedListEntry</TT>
object returned from <TT>find</TT>
wouldn't make any sense to a user of <TT>LinkedList</TT>.
Even though <TT>find</TT> is private,
there is a public method that can be used to see if an object
is in the list. This method is called <TT>contains</TT>;
its source code follows:
<BLOCKQUOTE>
<PRE>
public boolean contains(Object obj) {
  return (find(obj) != null);
}
</PRE>
</BLOCKQUOTE>
<P>
As you can see, all the <TT>contains</TT>
method does is call <TT>find</TT>
and compare the return value to <TT>null</TT>.
Since <TT>find</TT> only returns a
non-<TT>null</TT> value if an object
is found, this little trick works perfectly!
<P>
You may have noticed earlier that the <TT>find</TT>
method made a call to the <TT>isEmpty</TT>
method to see if the list was empty. The code for this method
follows:
<BLOCKQUOTE>
<PRE>
public boolean isEmpty() {
  return (start == null);
}
</PRE>
</BLOCKQUOTE>
<P>
Since the <TT>start</TT> reference
in <TT>LinkedList</TT> only contains
a <TT>null</TT> value if the list
is empty, the <TT>isEmpty</TT> method
simply checks to see if it is in fact set to <TT>null</TT>.
This is a very simple and effective way to see if the list is
empty.
<P>
That pretty much sums up the <TT>LinkedList</TT>
class, except for how it supports the <TT>Enumeration</TT>
interface. In deciding how to support the <TT>Enumeration</TT>
interface, your best bet is to look to the <TT>Vector</TT>
class. The <TT>Vector</TT> class supports
the <TT>Enumeration</TT> interface
through a method called <TT>elements</TT>.
The <TT>elements</TT> method returns
an object of type <TT>Enumeration</TT>
that can be used to enumerate the elements in a vector. Let's
use this same approach to add enumeration capabilities to the
linked list. Following is the source code for the <TT>elements</TT>
method in the <TT>LinkedList</TT>
class:
<BLOCKQUOTE>
<PRE>
public Enumeration elements() {
  return new LinkedListEnumerator(this);
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>elements</TT> method is probably
a lot simpler than you expected. That's because the work of actually
supporting the <TT>Enumeration</TT>
interface is left to the <TT>LinkedListEnumerator</TT>
class. Listing 23.4 contains the source code for the <TT>LinkedListEnumerator</TT>
class.
<HR>
<BLOCKQUOTE>
<B>Listing 23.4. The </B><TT><B>LinkedListEnumerator</B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class LinkedListEnumerator implements Enumeration {
 2:   protected LinkedListEntry pos;
 3:
 4:   public LinkedListEnumerator(LinkedList list) {
 5:     pos = list.start;
 6:   }
 7:
 8:   public boolean hasMoreElements() {
 9:     return (pos != null);
10:   }
11:
12:   public Object nextElement() {
13:     // Make sure the current object is valid
14:     if (pos == null)
15:       throw new NoSuchElementException();
16:
17:     // Increment the list and return the object
18:     LinkedListEntry tmp = pos;
19:     pos = pos.next;
20:     return tmp.val;
21:   }
22: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The first thing to notice in the <TT>LinkedListEnumerator</TT> class is that it implements the <TT>Enumeration</TT> interface, which is evident in the class definition. The <TT>LinkedListEnumerator</TT> class contains one member variable, <TT>pos</TT>, 
which keeps up with the current entry in the enumeration. The constructor simply sets the <TT>pos</TT> member to the start of the list.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Other than saying so in the class definition, implementing the
<TT>Enumeration</TT> interface involves
supporting two methods: <TT>hasMoreElements</TT>
and <TT>nextElement</TT>. The <TT>hasMoreElements</TT>
method simply checks to see if the <TT>pos</TT>
member is non-<TT>null</TT>, in which
case there are more elements to enumerate. The <TT>nextElement</TT>
method makes sure the current entry is valid and then returns
the object stored in this entry. And that's really all there is
to the <TT>LinkedListEnumerator</TT>
class!
<P>
You now have a complete linked list class that is ready to be
put to use in a practical Java program. I'll leave it up to you
to figure out a neat application of it. Incidentally, all the
source code for the linked list classes is located on the accompanying
CD-ROM.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
In today's lesson you have learned all about data structures and
their relevance to Java programming. You began the lesson with
a brief overview of data structures in general and why it is important
to have a solid understanding of how to use them. You then moved
on to learning about the standard data structures provided in
the Java utility package. These standard data structures provide
a range of options that cover many practical programming scenarios.
However, for those cases where you need something a little different
to hold data, you also learned about a type of data structure
that isn't provided by the Java utility package: linked lists.
You even implemented a linked list class that you can reuse in
your own Java programs. This knowledge, combined with an understanding
of the standard Java data structures, should serve as a solid
foundation for your handling of data in practical programming
scenarios.
<P>
If you thought the topic of data structures was a little dry,
don't worry, because tomorrow's lesson gets much more exciting.
Tomorrow you'll learn about advanced animation techniques and
the handling of distributed media. You'll even use your newfound
understanding of vectors to implement some really neat animation
classes!
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>If Java arrays are data structures, why aren't they implemented as classes?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Actually, Java arrays are implemented as classes; they just aren't used as classes in the traditional sense of calling methods, and so on. Even though you won't find a class called 
<TT>Array</TT> in the Java API documentation, you can rest assured that under Java's hood there is an array class that is at least vaguely similar to the <TT>Vector</TT> class.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Do all of the standard Java data structures implement the <TT><B>Enumeration</B></TT> interface?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>No, because the design of the <TT>Enumeration</TT> interface is based on a sequential data structure. For example, the <TT>Vector</TT> class is sequential and fits in perfectly with supporting 
the <TT>Enumeration</TT> interface. However, the <TT>BitSet</TT> class is very much nonsequential, so supporting the <TT>Enumeration</TT> interface wouldn't make any sense.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I still don't totally see the importance of using a hash table. What gives?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>The concept of calculating a hash code for a complex piece of data is important because it allows you to lessen the overhead involved in searching for the data. The hash code allows you to home 
in on a particular point in a large set of data before you begin the arduous task of searching based on the data itself, which can greatly improve performance.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>How are linked lists different from vectors when it comes to the storage of individual elements?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=55><CENTER><B>A:</FONT></B></CENTER>
</TD><TD>Vectors manage the memory requirements of all elements by allocating a certain amount of memory upon creation. When a vector is required to grow, it will allocate memory large enough to hold the existing data and the new data, and then copy 
everything to it. Even if a vector only holds references to objects, it must still manage the memory that holds the references. Linked lists don't manage any of the memory for the elements contained in the list, except for references to the <TT>start</TT> 
and <TT>end</TT> elements.
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch22.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch24.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
